<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>tigerose&#39;s site</title>
  
  <subtitle>In me the tiger sniffs the rose</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-07-05T14:35:23.784Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>tigerose</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>调试JS代码</title>
    <link href="http://yoursite.com/2020/07/05/js-debug/"/>
    <id>http://yoursite.com/2020/07/05/js-debug/</id>
    <published>2020-07-05T14:04:01.000Z</published>
    <updated>2020-07-05T14:35:23.784Z</updated>
    
    <content type="html"><![CDATA[<p>记录下近期对JS代码的调试过程</p><h2 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h2><p>启动程序之后,打开google浏览器对应页面,按F12或者Ctrl+Shift+I进入 <strong>开发者工具页面</strong></p><p>目前主要使用的功能有:</p><ol><li><p>Performance. 性能评估,比如我想看下页面刷新的性能瓶颈所在,先点击 <em>Record</em> 按钮,然后进行页面操作,当页面刷新完成,再点击 <em>Stop</em> 按钮,则会生成性能报告,可以看到资源消耗,JS代码的执行逻辑等</p></li><li><p>Sources. 性能报告页面的 <em>Main</em> 部分,可以通过点击色块查看其所在的js代码文件,如 <em>react-xx.js</em> 点击则会跳转到 <strong>Sources</strong> 功能栏,有了源文件就可以进行断点调试;这里注意部分js文件是压缩后的文件,建议手动修改程序替换成可读性更强的原始代码文件,方便调试</p></li><li><p>Console. 查看程序的打印输出,比如我想知道某个函数的执行时间,可以在js代码中进行修改</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.time(<span class="string">"foo"</span>);</span><br><span class="line">foo();</span><br><span class="line"><span class="built_in">console</span>.timeEnd(<span class="string">"foo"</span>);</span><br></pre></td></tr></table></figure><p> 当js代码执行之后,可以在console输出中看到foo的执行时间</p></li><li><p>Network. 查看文件传输的时间,判断下瓶颈是否在网络带宽,以及是否数据量太大导致数据的转换和传输耗时较久</p></li></ol><h2 id="性能调优"><a href="#性能调优" class="headerlink" title="性能调优"></a>性能调优</h2><p>通过性能分析,发现耗时最长的模块的操作是对数据的颜色计算,场景是我有1M个点需要显示,那么需要将它们从一个[2,1,4,10…]的 <em>颜色数组</em> 转换成RGB表示,js代码使用for循环进行操作,也就是线性复杂度,计算耗时随数据量的增大而线性增大</p><p>通过debug观察发现颜色数组会有不少重复的数值,而同样的输入会导致相同的输出,然后对整个数据的1M个点进行统计分析,发现重复率相当高,也就是for循环中有大量的重复计算</p><p>很自然想到增加缓存,用空间换时间来加速,当遇到计算过的数据时,直接返回计算结果,从而大大提高了程序执行的效率</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cache = &#123;&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (cache[colorIn[i]])</span><br><span class="line">    &#123;</span><br><span class="line">        colorOut[i] = cache[colorIn[i]];</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    colori = getColor(colorIn, i);</span><br><span class="line">    opacityi = getOpacity(opacityIn, i);</span><br><span class="line">    colorOut[i] = calculateColor(colori, opacityi);</span><br><span class="line">    cache[colorIn[i]] = colorOut[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;记录下近期对JS代码的调试过程&lt;/p&gt;
&lt;h2 id=&quot;性能分析&quot;&gt;&lt;a href=&quot;#性能分析&quot; class=&quot;headerlink&quot; title=&quot;性能分析&quot;&gt;&lt;/a&gt;性能分析&lt;/h2&gt;&lt;p&gt;启动程序之后,打开google浏览器对应页面,按F12或者Ctrl+Shift
      
    
    </summary>
    
    
    
      <category term="JS" scheme="http://yoursite.com/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>职级晋升答辩</title>
    <link href="http://yoursite.com/2020/06/07/rank-promotion/"/>
    <id>http://yoursite.com/2020/06/07/rank-promotion/</id>
    <published>2020-06-07T02:03:30.000Z</published>
    <updated>2020-06-07T02:44:01.910Z</updated>
    
    <content type="html"><![CDATA[<p>前段时间参加了公司的职级晋升答辩,这里结合知乎回答和个人经验,简单总结下</p><h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>明确职级晋升答辩的目的:</p><blockquote><p>规定时间内,通过ppt精准阐述你能达到下一个职级的理由</p></blockquote><p>有资格参加答辩,说明本身产出和业绩是ok的,但这只与绩效有关,晋升关注的是<strong>能力层级</strong><br>因此需要在有限时间内,讲清楚为什么你达到了更高层级的要求,产出只是为了说明达到了要求的具体案例支撑</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>自我介绍之后,描述下自己在项目中负责的模块(可使用业务整体的架构图)</p><p>分析业务现状,趋势及挑战-&gt;明确核心路径或打法-&gt;拆分问题</p><p>对每一个问题:<br>现状与难点-&gt;解决思路-&gt;做了哪些核心工作-&gt;对应的产出如何</p><p>按照这个思路来总结自己的工作成果,自己要把逻辑理顺,然后拆分逻辑到每一页ppt中,并进行答辩讲解准备</p><h2 id="ppt制作"><a href="#ppt制作" class="headerlink" title="ppt制作"></a>ppt制作</h2><h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><p>使用公司模板即可;如果没有模板,选择偏严肃些的背景,无需进行过多风格创作</p><h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><p>注意下中文排版格式:</p><ul><li>空格的应用</li><li>英文大小写符合规范且统一</li><li>符号应用正确</li></ul><p>文字精炼,关键词可考虑<strong>高亮加粗</strong></p><h3 id="图表"><a href="#图表" class="headerlink" title="图表"></a>图表</h3><p>图表很重要,尽量每一页都能有;减少文字堆积,换成简洁的图表</p><p>项目总结部分,可以加架构图,或者业务图,或者产品展示图</p><p>具体成果,一般都可以加优化前后对比图或者表格</p><p>专利软著,可以截图文章标题部分</p><h3 id="未来计划"><a href="#未来计划" class="headerlink" title="未来计划"></a>未来计划</h3><p>ppt结尾一般会有个人的计划,可从以下方面考虑:</p><ul><li>公司项目或产品技术方案的优化</li><li>思考怎么打造更高效的团队</li><li>工程师在行业内如何发展</li></ul><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>ppt 尽量精炼,多展示结果,由人来简单讲解过程;把具体细节留到评委问答环节</p><p>提前准备好评委可能问到的问题,回答过问题可以主动延伸一下,自己掌握节奏,另外可以有效拖延时间,降低被问到刁钻问题的概率</p><h2 id="ppt讲解"><a href="#ppt讲解" class="headerlink" title="ppt讲解"></a>ppt讲解</h2><blockquote><p>STAR法则<br>情景(Situation)+任务(Task)+行动(Action)+结果(Result)<br>一种结构化的描述方式,能让你的阐述更有层次性和逻辑性</p></blockquote><ol><li>情景<ul><li>业务背景</li><li>非常简要</li></ul></li><li>任务<ul><li>承担的任务或职责</li><li>遇到的问题,挑战,难点</li></ul></li><li>行动<ul><li>为了达成目标,如何展开行动的,采取了哪些措施来解决问题</li><li>讲清楚思路,做了哪些核心操作即可,细节等着提问环节回答</li></ul></li><li>结果<ul><li>最终结果如何,包括业务的,技术的,团队的</li><li>自己的总结和反思</li><li>(如果从现在的角度回去审视这件事,你会有哪些不一样的做法)-评委爱问的问题</li></ul></li></ol><p>一句话总结: <em>什么背景下,遇到了什么痛点,我的思路是怎么样的,具体做了哪些重要的事,最终结果如何?</em></p><p>例如:随着数据通量的提高,软件面临速度方面的挑战,我通过进行性能瓶颈分析,并针对性的进行xxx的优化,使程序性能提高xx倍,从而达到了产品发布的速度要求,提高了产品竞争力.</p><h2 id="逐字稿"><a href="#逐字稿" class="headerlink" title="逐字稿"></a>逐字稿</h2><p>重要的演讲,提前做好逐字稿(防止打断之后漏掉核心内容)<br>逐字稿就是把将要讲的内容,具体到每一个字写出来,相当于背稿子,可以有效提高熟练度,减少紧张感</p><p>我是将逐字稿使用markdown 格式写好,然后转pdf 打印出来,找个安静的环境进行全文阅读并背诵;使用markdown 好处是可以自己标注重点,哪里是过渡等</p><p>由于时间有限,如5min, 并且现场很可能有人掐着时间,因此务必提前多次演练,熟能生巧</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前段时间参加了公司的职级晋升答辩,这里结合知乎回答和个人经验,简单总结下&lt;/p&gt;
&lt;h2 id=&quot;目的&quot;&gt;&lt;a href=&quot;#目的&quot; class=&quot;headerlink&quot; title=&quot;目的&quot;&gt;&lt;/a&gt;目的&lt;/h2&gt;&lt;p&gt;明确职级晋升答辩的目的:&lt;/p&gt;
&lt;blockquo
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>读&lt;富爸爸,穷爸爸&gt;</title>
    <link href="http://yoursite.com/2020/05/13/rich-dad/"/>
    <id>http://yoursite.com/2020/05/13/rich-dad/</id>
    <published>2020-05-13T13:16:19.000Z</published>
    <updated>2020-05-13T13:41:44.551Z</updated>
    
    <content type="html"><![CDATA[<p><strong>老鼠赛跑游戏</strong>:通过学习会计和投资知识,跳出”努力工作,提高收入的同时支出也随之提高”的陷阱</p><p><strong>现状</strong>:学校教育专注于学术知识和专业技能,忽视了理财技能的培养</p><p>核心:</p><ol><li><p>穷人和中产阶级为钱工作,富人不为钱工作</p><p>单靠工作来挣工资,很难财务自由;不断用头脑思考,不求回报地工作,有可能发现比拿工资更快的挣钱方式,因为会看到别人看不到的机会<br>掌握自己的财务,让钱为我所用,就算不工作,依然能产生收益,自动增长</p></li><li><p>规则:明白资产和负债的区别,并购买资产  </p><p>资产就是能把钱放进口袋的东西,负债就是把钱从口袋拿走的东西<br>想消费的时候,先增加资产项,让它产生的现金流来给自己买单</p></li><li><p>关注自己的事业</p><p>职业的重心是收入项;事业的重心是资产项<br>关注自己的事业,在继续工作的时候不断构建资产项,而不是负债或者一旦买回家就没有价值的个人物品<br>资产分类:</p><ul><li>不需要人到场就可以正常运作的业务. 我拥有它们,但由别人经营和管理</li><li>股票</li><li>债券</li><li>共同基金</li><li>能够产生收入的房地产. 如出租,出售</li><li>票据(借据)</li><li>版税. 如音乐,手稿,专利</li><li>其他任何有价值,可产生收入或具有增值潜力并且很好销路的东西</li></ul></li><li><p>关于公司和税收  </p><p>海上贸易兴盛时,富人通过创办公司来分担每次航行的风险<br>税收初衷是为了惩罚富人,但最终是中产阶级在支付税金<br>资本家利用公司来避税:企业所得税低于个人所得税,可以用税前收入进行支出</p></li><li><p>知识储备  </p><ul><li><p>基础  </p><ul><li>会计. 财务知识</li><li>投资. 钱生钱</li><li>了解市场. 供给与需求的科学</li><li>法律. 合理减税,以及诉讼中获得保护  </li></ul></li><li><p>高级</p><ul><li>如何寻找其他人都忽视的机会</li><li>如何增加资金. 寻找银行贷款之外的方式</li><li>如何把聪明人组织起来. 当你需要建议的时候,一定要选择明智的顾问</li></ul></li><li><p>管理能力</p><ul><li>对现金流的管理</li><li>对系统(包括自己,时间及家庭)的管理</li><li>对人员的管理</li></ul></li><li><p>其他</p><ul><li>销售和市场营销</li></ul></li></ul></li><li><p>克服困难</p><ul><li>恐惧心理. 害怕失败和挫折</li><li>愤世嫉俗. 要消除外界噪音,关注自己想要的东西</li><li>懒惰</li><li>不良习惯. 如学会先支付自己</li><li>自负. 切忌傲慢自大,对某问题有欠缺,应该找领域专家或专业书籍来教育自己</li></ul></li><li><p>开始行动</p><ul><li>发掘内心想要和不想要的</li><li>做出好的选择. 投资于教育,充实头脑</li><li>慎重选择朋友. 向他人学习致富的知识</li><li>掌握一种模式. 如除了工作之外的挣钱模式</li><li>给经纪人优厚的报酬. 为专业服务付费</li><li>先给予再获取</li><li>模仿和学习偶像</li></ul></li><li><p>实践</p><ul><li>停下手头的活,评估哪些有效</li><li>向有经验的人请教. 要先付出,如请人吃饭</li><li>参与培训和辅导班</li><li>深入市场</li></ul></li></ol><p>一句话总结:</p><p><strong>通过工作产生稳定收入,同时关注自己的事业,学习财商知识,购买资产项,目标是资产收益超过日常支出,达到财务自由</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;老鼠赛跑游戏&lt;/strong&gt;:通过学习会计和投资知识,跳出”努力工作,提高收入的同时支出也随之提高”的陷阱&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;现状&lt;/strong&gt;:学校教育专注于学术知识和专业技能,忽视了理财技能的培养&lt;/p&gt;
&lt;p&gt;核心:&lt;/p&gt;
&lt;ol&gt;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>基因注释</title>
    <link href="http://yoursite.com/2020/04/30/gene-annotation/"/>
    <id>http://yoursite.com/2020/04/30/gene-annotation/</id>
    <published>2020-04-30T12:49:05.000Z</published>
    <updated>2020-04-30T12:59:22.580Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基因注释"><a href="#基因注释" class="headerlink" title="基因注释"></a>基因注释</h1><p>记录下自己对RNA-seq基因注释的学习,并对Drop-seq软件包中的注释模块进行代码研读</p><h2 id="什么是基因注释"><a href="#什么是基因注释" class="headerlink" title="什么是基因注释"></a>什么是基因注释</h2><p>一句话概况注释:<em>找到与reads有overlap的基因片段,并进行标记</em></p><p>这里reads指bam文件中的每一行数据,即测序下机文件fastq与参考基因组进行比对之后生成的数据,其中记录了每条read在参考基因组中的位置,有起始位置和终止位置,表示一段区间</p><p>基因注释文件记录了每个基因片段在参考基因组上的位置,也是一段区间,因此与bam文件结合,通过find overlapping我们可以查找到每条read属于哪个基因片段,将其标记在bam格式的tags中,这对后续的生信分析是有帮助的</p><h2 id="基因注释文件"><a href="#基因注释文件" class="headerlink" title="基因注释文件"></a>基因注释文件</h2><p>GTF/GFF格式是基因注释的常用格式<br>GTF是Gene Transfer Format的缩写,其文件由九列数据组成,以tab分割,示例如下:</p><table><thead><tr><th>seq_id</th><th>source</th><th>type</th><th>start</th><th>end</th><th>score</th><th>strand</th><th>phase</th><th>attributes</th></tr></thead><tbody><tr><td>chr1</td><td>HAVANA</td><td>exon</td><td>11869</td><td>12227</td><td>.</td><td>+</td><td>.</td><td>gene_id “ENSG00000223972.5”; transcript_id “ENST00000456328.2”;…</td></tr><tr><td>染色体编号</td><td>注释来源</td><td>类型</td><td>在参考序列的起始位置</td><td>终止位置</td><td>得分,说明注释信息的可能性</td><td>位于参考序列的正负链</td><td>仅对类型为CDS有效,表示起始编码的位置</td><td>包含众多属性的列表</td></tr></tbody></table><p>虽然数据有九列之多,但并不是所有都会用到,常用的有:</p><ol><li>seq_id. 要查找overlap,首先得是同一条染色体</li><li>type. 有多种类型,如gene/transcript/exon/CDS/UTR等,它们之间有层级关系,一般gtf文件中多行数据对应一条基因的完整信息,以type为gene的行为起始;每条gene可以表示为树状结构,gene为根节点,第二层为transcript,第三层为诸如exon CDS等</li><li>start/end. 根据起始终止位置可以建立interval,这是find overlapping的基础</li><li>strand. 正负链可以作为过滤条件,假如一条read与多个基因有overlap,可以根据方向是否相同过滤掉部分基因</li><li>attributes. 一些列键值对属性,常用的信息包括名称,id之类</li></ol><h2 id="注释流程分析"><a href="#注释流程分析" class="headerlink" title="注释流程分析"></a>注释流程分析</h2><p>流程可分为三步:</p><ol><li><strong>读入gtf文件</strong>. 从磁盘将gtf文件加载进内存,并提取需要的信息,毕竟gtf有许多信息是我们不需要的</li><li><strong>建立区间树</strong>. 即interval tree,使用区间树是为了高效查询,为了达到最佳性能,一般使用基于红黑树的区间树实现,因为红黑树是平衡树,查找时间复杂度O(lgN),不会出现退化成链表的最坏情况</li><li><strong>查找区间并注释</strong>. 遍历bam文件中每条read,根据其在参考序列中的位置构建interval,与前面建立的interval tree进行overlap的查找,找到之后,进行一些逻辑计算,并更新read的tags,输出到bam</li></ol><h2 id="Drop-seq代码研读"><a href="#Drop-seq代码研读" class="headerlink" title="Drop-seq代码研读"></a>Drop-seq代码研读</h2><p>Drop-seq是使用java开发的程序包,其中的<em>TagReadWithGeneExonFunction</em> 模块实现了添加注释的功能</p><h3 id="主流程"><a href="#主流程" class="headerlink" title="主流程"></a>主流程</h3><p>主流程核心代码为:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加载基因注释文件,并构建区间树</span></span><br><span class="line"><span class="keyword">final</span> OverlapDetector&lt;Gene&gt; geneOverlapDetector = GeneAnnotationReader.loadAnnotationsFile(ANNOTATIONS_FILE, bamDict);</span><br><span class="line"><span class="comment">// 打开输出bam文件</span></span><br><span class="line">SAMFileWriter writer= <span class="keyword">new</span> SAMFileWriterFactory().makeSAMOrBAMWriter(header, <span class="keyword">true</span>, OUTPUT);</span><br><span class="line"><span class="comment">// 遍历输入bam中的每条read</span></span><br><span class="line"><span class="keyword">for</span> (SAMRecord r: inputSam) &#123;</span><br><span class="line">    <span class="comment">// 对完成比对的read,进行find overlapping操作并添加注释</span></span><br><span class="line">    <span class="keyword">if</span> (!r.getReadUnmappedFlag())</span><br><span class="line">        r=setAnnotations(r, geneOverlapDetector);</span><br><span class="line">    <span class="comment">// 输出注释后的read</span></span><br><span class="line">    writer.addAlignment(r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其结果是根据overlap的genes信息,添加三个Tag,示例:</p><blockquote><p>GE:Z:WASH7P    XF:Z:CODING        GS:Z:-</p></blockquote><ul><li>GE为gene name  </li><li>XF为locus function  </li><li>GS为正负链</li></ul><h3 id="加载gtf并构建interval-tree"><a href="#加载gtf并构建interval-tree" class="headerlink" title="加载gtf并构建interval tree"></a>加载gtf并构建interval tree</h3><p>核心代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用来解析gtf每行数据,提取需要的字段</span></span><br><span class="line"><span class="keyword">final</span> FilteringGTFParser parser = <span class="keyword">new</span> FilteringGTFParser(gtfFlatFile);</span><br><span class="line"><span class="comment">// gene name相同的gtf行,代表它们是一个gene的数据,使用它们构建GeneFromGTF数据类型,</span></span><br><span class="line"><span class="comment">// 此类型继承自Interval类型</span></span><br><span class="line"><span class="keyword">final</span> GeneFromGTFBuilder geneBuilder = <span class="keyword">new</span> GeneFromGTFBuilder(parser);</span><br><span class="line"><span class="comment">// 初始化interval tree</span></span><br><span class="line"><span class="keyword">final</span> OverlapDetector&lt;GeneFromGTF&gt; overlapDetector = <span class="keyword">new</span> OverlapDetector&lt;&gt;(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">while</span> (geneBuilder.hasNext())&#123;</span><br><span class="line">        <span class="comment">// 将每条gene添加到interval tree,其内部按照chromosome进行分类</span></span><br><span class="line">        GeneFromGTF gene = geneBuilder.next();</span><br><span class="line">        overlapDetector.addLhs(gene, gene);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>代码实现使用了迭代器,减少内存的消耗</p><p>将gtf每行数据以gene_name为key,放入<code>map&lt;gene_name, List&lt;GTFRecord&gt;&gt;</code>中,这样就将每条gene的数据分类好了<br>geneBuilder 是个<code>iter&lt;List&lt;GTFRecord&gt;&gt;</code>,迭代时,对每个gene将其数据<code>List&lt;GTFRecord&gt;</code> 按gene_version分类成<code>map&lt;gene_version, List&lt;GTFRecord&gt;&gt;</code>,对key也就是所有的gene_version进行排序,取最大的gene_version对应的<code>List&lt;GTFRecord&gt;</code>来构建GeneFromGTF(对部分gtf文件它们的gene_version是null,则对gene_version分类和没做一样)</p><p>重点是构建GeneFromGTF类实例:<br><code>List&lt;GTFRecord&gt;</code>转GeneFromGTF调用接口<code>makeGeneFromMultiVersionGTFRecords()</code></p><ol><li>使用list中第一条GTFRecord的信息初始化GeneFromGTF(因为第一条的类型永远是gene),只有start end属性是取得list中所有数据的最小start,最大end  </li><li>进行一致性检查. 检查list中所有数据,如正反链必须都一致,chr一致等,否则抛出异常</li><li>将所有的非gene数据进行统计处理,更新GeneFromGTF成员变量<code>Map&lt;String, TranscriptFromGTF&gt; transcripts</code>, TranscriptFromGTF类型包括transcript, CDS, coding等相关信息</li></ol><p>最后调用<em>htsjdk</em>库的<code>OverlapDetector.addLhs()</code>将GeneFromGTF作为节点加入线段树中</p><h3 id="注释逻辑"><a href="#注释逻辑" class="headerlink" title="注释逻辑"></a>注释逻辑</h3><p>核心代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> SAMRecord <span class="title">setAnnotations</span> <span class="params">(<span class="keyword">final</span> SAMRecord r, <span class="keyword">final</span> OverlapDetector&lt;Gene&gt; geneOverlapDetector)</span> </span>&#123;</span><br><span class="line">        Map&lt;Gene, LocusFunction&gt; map = AnnotationUtils.getInstance().getLocusFunctionForReadByGene(r, geneOverlapDetector);</span><br><span class="line">        Set&lt;Gene&gt; exonsForRead = AnnotationUtils.getInstance().getConsistentExons (r, map.keySet(), ALLOW_MULTI_GENE_READS);</span><br><span class="line"></span><br><span class="line">        List&lt;Gene&gt; genes = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Gene g: exonsForRead) &#123;</span><br><span class="line">            LocusFunction f = map.get(g);</span><br><span class="line">            <span class="keyword">if</span> (f==LocusFunction.CODING || f==LocusFunction.UTR)</span><br><span class="line">                genes.add(g);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;LocusFunction&gt; allPassingFunctions = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (USE_STRAND_INFO) &#123;</span><br><span class="line">            <span class="comment">// constrain gene exons to read strand.</span></span><br><span class="line">            genes = getGenesConsistentWithReadStrand(genes, r);</span><br><span class="line">            <span class="comment">// only retain functional map entries that are on the correct strand.</span></span><br><span class="line">            <span class="keyword">for</span> (Gene g: map.keySet()) &#123;</span><br><span class="line">                <span class="keyword">boolean</span> strandCheck=readAnnotationMatchStrand(g, r);</span><br><span class="line">                <span class="keyword">if</span> (strandCheck) allPassingFunctions.add(map.get(g));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            allPassingFunctions=<span class="keyword">new</span> ArrayList&lt;&gt;(map.values());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// if strand tag is used, only add locus function values for passing genes.</span></span><br><span class="line">        <span class="keyword">for</span> (Gene g: genes)</span><br><span class="line">            allPassingFunctions.add(map.get(g));</span><br><span class="line"></span><br><span class="line">        LocusFunction f = AnnotationUtils.getInstance().getLocusFunction(allPassingFunctions, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (genes.size()&gt;<span class="number">1</span> &amp;&amp; <span class="keyword">this</span>.ALLOW_MULTI_GENE_READS==<span class="keyword">false</span>)</span><br><span class="line">            log.error(<span class="string">"There should only be 1 gene assigned to a read for DGE purposes."</span>);</span><br><span class="line"></span><br><span class="line">        String finalGeneName = getCompoundGeneName(genes);</span><br><span class="line">        String finalGeneStrand = getCompoundStrand(genes);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (f!=<span class="keyword">null</span>)</span><br><span class="line">            r.setAttribute(<span class="keyword">this</span>.FUNCTION_TAG, f.toString());</span><br><span class="line">        <span class="keyword">if</span> (finalGeneName!=<span class="keyword">null</span> &amp;&amp; finalGeneStrand!=<span class="keyword">null</span>) &#123;</span><br><span class="line">            r.setAttribute(<span class="keyword">this</span>.TAG, finalGeneName);</span><br><span class="line">            r.setAttribute(<span class="keyword">this</span>.STRAND_TAG, finalGeneStrand);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            r.setAttribute(<span class="keyword">this</span>.TAG, <span class="keyword">null</span>);</span><br><span class="line">            r.setAttribute(<span class="keyword">this</span>.STRAND_TAG, <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (r);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>概况一下注释逻辑:对read构建interval,查找overlap的所有基因,计算三个tag: locusFunction, geneName, geneStrand,并更新read  </p><p>对每个gene计算locusFunction的核心代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> LocusFunction <span class="title">getLocusFunctionForRead</span> <span class="params">(<span class="keyword">final</span> SAMRecord rec, <span class="keyword">final</span> Gene g)</span> </span>&#123;</span><br><span class="line">    List&lt;AlignmentBlock&gt; alignmentBlocks = rec.getAlignmentBlocks();</span><br><span class="line"></span><br><span class="line">    LocusFunction [] blockSummaryFunction = <span class="keyword">new</span> LocusFunction[alignmentBlocks.size()];</span><br><span class="line">    Set&lt;Gene&gt; temp = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    temp.add(g);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;alignmentBlocks.size(); i++) &#123;</span><br><span class="line">        AlignmentBlock alignmentBlock =alignmentBlocks.get(i);</span><br><span class="line"></span><br><span class="line">        LocusFunction [] blockFunctions=getLocusFunctionsByBlock(alignmentBlock, temp);</span><br><span class="line">        LocusFunction blockFunction = getLocusFunction(blockFunctions, <span class="keyword">false</span>);</span><br><span class="line">        blockSummaryFunction[i]=blockFunction;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LocusFunction readFunction = getLocusFunction(blockSummaryFunction, <span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">return</span> readFunction;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>计算过程:</p><ol><li>对read每个位点都计算一个LocusFunction(计算过程具体为是否与exons有overlap)</li><li>将一条alignmentBlocks中所有位点的LocusFunctions合并为一个LocusFunction</li><li>将所有alignmentBlocks的LocusFunctions合并为一个LocusFunction</li></ol><p>每次合并都是取最大的LocusFunction,其是一个枚举变量,由小到大为:<br><code>INTERGENIC, INTRONIC, UTR, CODING, RIBOSOMAL</code></p><h3 id="输出统计信息"><a href="#输出统计信息" class="headerlink" title="输出统计信息"></a>输出统计信息</h3><table><thead><tr><th>统计项</th><th>解释</th></tr></thead><tbody><tr><td>AMBIGUOUS_READS_REJECTED</td><td>有多条同方向的overlaped gene</td></tr><tr><td>READ_AMBIGUOUS_GENE_FIXED</td><td>overlaped gene中同向的只有一条,但是还有反向的</td></tr><tr><td>READS_RIGHT_STRAND</td><td>只有一条overlaped gene,并且与read同向</td></tr><tr><td>READS_WRONG_STRAND</td><td>overlaped gene没有同向,只有反向</td></tr><tr><td>TOTAL_READS</td><td>处理的总reads数</td></tr></tbody></table><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://blog.csdn.net/sinat_38163598/article/details/72851239" target="_blank" rel="noopener">GTF基因注释文件详解</a></li><li><a href="https://www.jianshu.com/p/0800a07cfa37" target="_blank" rel="noopener">液滴微流控获取单细胞及Drop-seq_tools分析流程</a></li><li><a href="https://github.com/broadinstitute/Drop-seq" target="_blank" rel="noopener">Drop-seq_github</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;基因注释&quot;&gt;&lt;a href=&quot;#基因注释&quot; class=&quot;headerlink&quot; title=&quot;基因注释&quot;&gt;&lt;/a&gt;基因注释&lt;/h1&gt;&lt;p&gt;记录下自己对RNA-seq基因注释的学习,并对Drop-seq软件包中的注释模块进行代码研读&lt;/p&gt;
&lt;h2 id=&quot;什么是
      
    
    </summary>
    
    
    
      <category term="基因注释" scheme="http://yoursite.com/tags/%E5%9F%BA%E5%9B%A0%E6%B3%A8%E9%87%8A/"/>
    
  </entry>
  
  <entry>
    <title>seqan库的使用</title>
    <link href="http://yoursite.com/2020/04/26/intro-seqan/"/>
    <id>http://yoursite.com/2020/04/26/intro-seqan/</id>
    <published>2020-04-26T12:40:41.000Z</published>
    <updated>2020-04-26T12:56:00.942Z</updated>
    
    <content type="html"><![CDATA[<p>seqan库是进行生物序列分析的一个现代的C++库,目前有seqan2, seqan3两个版本,seqan3正在开发当中<br>我打算应用seqan库实现一个简单的注释程序,因为seqan3暂时还未实现gtf文件的相关操作,因此选用seqan2  </p><p>seqan是header-only的库,因此无需添加lib,只要包含头文件即可使用  </p><h2 id="定义别名"><a href="#定义别名" class="headerlink" title="定义别名"></a>定义别名</h2><p>为了使用简洁,定义常用类型的别名</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> seqan::FragmentStore&lt;&gt; TStore;</span><br><span class="line"><span class="keyword">typedef</span> seqan::Value&lt;TStore::TAnnotationStore&gt;::Type TAnnotation;</span><br><span class="line"><span class="keyword">typedef</span> TAnnotation::TId TId;</span><br><span class="line"><span class="keyword">typedef</span> TAnnotation::TPos TPos;</span><br><span class="line"><span class="keyword">typedef</span> seqan::IntervalAndCargo&lt;TPos, TId&gt; TInterval;</span><br><span class="line"><span class="keyword">typedef</span> seqan::IntervalTree&lt;TPos, TId&gt; TIntervalTree;</span><br><span class="line"><span class="keyword">typedef</span> seqan::String&lt;TIntervalTree&gt; TIntervalTrees;</span><br><span class="line"><span class="keyword">typedef</span> seqan::Iterator&lt;TStore <span class="keyword">const</span>, seqan::AnnotationTree&lt;&gt; &gt;::Type TCIterator;</span><br><span class="line"><span class="keyword">typedef</span> seqan::Iterator&lt;TStore, seqan::AnnotationTree&lt;&gt; &gt;::Type TIterator;</span><br><span class="line"><span class="keyword">typedef</span> seqan::String&lt;TId&gt; TIds;</span><br><span class="line"><span class="keyword">typedef</span> seqan::BamAlignmentRecord BamRecord;</span><br></pre></td></tr></table></figure><h2 id="gtf文件的加载"><a href="#gtf文件的加载" class="headerlink" title="gtf文件的加载"></a>gtf文件的加载</h2><p>直接上代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">seqan::FragmentStore&lt;&gt; store;</span><br><span class="line">seqan::GffFileIn annotationFile;</span><br><span class="line"><span class="keyword">if</span> (!seqan::open(annotationFile, gtf_file.c_str()))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">readRecords(store, annotationFile);</span><br></pre></td></tr></table></figure><p>可以看到,只要几行代码就将gtf文件的数据读取到内存中;使用FragmentStore来管理内存</p><p>gtf数据在内存中的存储,可以被视为关系型数据库,每一行表示一个gene,因此通过唯一ID可以访问gene数据,而gene数据是树状结构,如下图:<br><img src="/images/intro_seqan/seqan-annotation-store.png" alt="seqan-annotation-store"></p><p>想要遍历gtf数据,首先拿到根节点迭代器,然后使用树的遍历方式即可</p><h2 id="构建interval-tree"><a href="#构建interval-tree" class="headerlink" title="构建interval tree"></a>构建interval tree</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">seqan::String&lt;seqan::String&lt;TInterval&gt;&gt; intervals;</span><br><span class="line"><span class="keyword">int</span> numContigs = seqan::length(store.contigStore);</span><br><span class="line">resize(intervals, numContigs);</span><br><span class="line"></span><br><span class="line">TIterator it = seqan::begin(store, seqan::AnnotationTree&lt;&gt;());</span><br><span class="line"><span class="keyword">if</span> (!goDown(it))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">    SEQAN_ASSERT_EQ(getType(it), <span class="string">"gene"</span>);</span><br><span class="line">    TPos beginPos = getAnnotation(it).beginPos;</span><br><span class="line">    TPos endPos = getAnnotation(it).endPos;</span><br><span class="line">    TId contigId = getAnnotation(it).contigId;</span><br><span class="line">    <span class="keyword">if</span> (beginPos &gt; endPos)</span><br><span class="line">        <span class="built_in">std</span>::swap(beginPos, endPos);</span><br><span class="line">    appendValue(intervals[contigId], TInterval(beginPos, endPos, value(it)));</span><br><span class="line">&#125; <span class="keyword">while</span> (goRight(it));</span><br><span class="line"></span><br><span class="line">TIntervalTrees intervalTrees;</span><br><span class="line">resize(intervalTrees, numContigs);</span><br><span class="line"></span><br><span class="line">SEQAN_OMP_PRAGMA(parallel <span class="keyword">for</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numContigs; ++i)</span><br><span class="line">    seqan::createIntervalTree(intervalTrees[i], intervals[i]);</span><br></pre></td></tr></table></figure><p>要构建线段树intervalTrees,首先得有一组线段intervals.通过遍历gtf数据,对每个gene构建一个interval,加入intervals,这里注意chromosome之间无关联,应分别建立数据;最后通过createIntervalTree接口构建intervalTrees,利用chromosome之间独立的特性,使用openmp加速构建过程</p><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打开输入bam</span></span><br><span class="line">seqan::BamFileIn inFile;</span><br><span class="line">seqan::open(inFile, inputBamFilename.c_str());</span><br><span class="line">seqan::BamHeader header;</span><br><span class="line">seqan::readHeader(header, inFile);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打开输出bam,注意初始化header</span></span><br><span class="line">seqan::BamFileOut fileOut;</span><br><span class="line">fileOut.context = seqan::context(inFile);</span><br><span class="line">seqan::setFormat(fileOut, seqan::Bam());</span><br><span class="line">seqan::open(fileOut, outputBamFilename.c_str(), seqan::OPEN_WRONLY |seqan::OPEN_CREATE);</span><br><span class="line">seqan::writeHeader(fileOut, header);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历bam中每条read</span></span><br><span class="line"><span class="keyword">while</span> (!seqan::atEnd(inFile))</span><br><span class="line">&#123;</span><br><span class="line">    seqan::readRecord(record, inFile);</span><br><span class="line">    TPos queryBegin = record.beginPos+<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 这里是根据read的cigar信息计算出长度,省略部分代码</span></span><br><span class="line">    TPos queryEnd = queryBegin + getReferenceLength(record.cigar);</span><br><span class="line"></span><br><span class="line">    TIds result;</span><br><span class="line">    <span class="keyword">if</span> (record.rID &lt; seqan::length(intervalTrees))</span><br><span class="line">        seqan::findIntervals(result, intervalTrees[record.rID], queryBegin, queryEnd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    *result记录了与当前read有overlap的gene在数据库中的唯一ID,由于计算逻辑实现过长</span></span><br><span class="line"><span class="comment">    *接下来省略对locusFunction等的计算代码,result的使用简略记录下,通过迭代器访问原始gtf数据</span></span><br><span class="line"><span class="comment">    *TIterator it;</span></span><br><span class="line"><span class="comment">    *for (unsigned j = 0; j &lt; seqan::length(result); ++j)</span></span><br><span class="line"><span class="comment">    *&#123;</span></span><br><span class="line"><span class="comment">    *   int id = result[j];</span></span><br><span class="line"><span class="comment">    *   goTo(it, id);</span></span><br><span class="line"><span class="comment">    *   ...</span></span><br><span class="line"><span class="comment">    *&#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新read的tag信息,示例会生成tag信息: GE:Z:gene_name (中间的Z表示value为字符串)</span></span><br><span class="line">    <span class="function">seqan::BamTagsDict <span class="title">tags</span><span class="params">(record.tags)</span></span>;</span><br><span class="line">    seqan::setTagValue(tags, <span class="string">"GE"</span>, <span class="string">"gene_name"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出bam</span></span><br><span class="line">    seqan::writeRecord(fileOut, record);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不同的注释逻辑自然实现不同,所以这里仅给出代码结构,更多细节要多阅读seqan库的文档,还是挺详细的</p><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>一些预定义宏可能有加速效果</p><ul><li>SEQAN_ASYNC_IO=1 允许异步输入输出操作</li><li>SEQAN_BGZF_NUM_THREADS=value 读写bam文件使用的线程数</li></ul><p>其他的就是使用性能分析工具如valgrind,gprof等找出瓶颈并针对性优化</p><h2 id="问题总结"><a href="#问题总结" class="headerlink" title="问题总结"></a>问题总结</h2><h3 id="编译问题"><a href="#编译问题" class="headerlink" title="编译问题"></a>编译问题</h3><p>Q:error MSB8036: The Windows SDK version 8.1 was not found<br>A:控制面板-应用程序-修改vs studio-勾选上通用工具中的win10SDK,重新安装</p><p>Q:No CMAKE_CXX_COMPILER could be found<br>A:删掉缓存,重新编译</p><p>Q:windows下的项目配置<br>A:配置属性-C/C++-语言 复合模式选择否,启用运行时类型信息选择是(/GR) OpenMP支持选择是;字符集选择多字节字符集;警告等级选择/W2;添加zlib,用于读取bam文件,注意x86和x64不要搞混</p><p>Q:预处理设置<br>A:</p><blockquote><p>WIN32_WINDOWS<br>SEQAN_ENABLE_DEBUG=1<br>SEQAN_GLOBAL_EXCEPTION_HANDLER=1<br><em>WIN32_WINNT=0x0600<br>WINVER=0x0600<br>_SCL_SECURE_NO_WARNINGS<br>_CRT_SECURE_NO_WARNINGS<br>NOMINMAX<br>SEQAN_HAS_EXECINFO=0<br>SEQAN_HAS_OPENMP=1<br>SEQAN_APP_VERSION=”1.5.8”<br>SEQAN_REVISION=”f5f6583”<br>SEQAN_DATE=”2019-08-02_14:42:28</em>+0000”<br>CMAKE_INTDIR=”Debug”  </p></blockquote><h3 id="代码错误"><a href="#代码错误" class="headerlink" title="代码错误"></a>代码错误</h3><p>Q:getValueByKey接口调用异常<br>A:修改代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注释掉此接口</span></span><br><span class="line"><span class="comment">//template &lt;typename TFragmentStore, typename TSpec, typename TKey&gt;</span></span><br><span class="line"><span class="comment">//inline CharString</span></span><br><span class="line"><span class="comment">//getValueByKey(</span></span><br><span class="line"><span class="comment">//    Iter&lt;TFragmentStore, AnnotationTree&lt;TSpec&gt; &gt; const &amp; it,</span></span><br><span class="line"><span class="comment">//    TKey const &amp; key)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//    return annotationGetValueByKey(*it.store, getAnnotation(it), key);</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// FragmentStore&lt;TSpec, TConfig&gt; &amp; fragStore, 参数加const</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> TSpec, <span class="keyword">typename</span> TConfig, <span class="keyword">typename</span> TAnnotation, <span class="keyword">typename</span> TKey, <span class="keyword">typename</span> TValue&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">bool</span></span><br><span class="line">annotationGetValueByKey (</span><br><span class="line">    TValue &amp; value,</span><br><span class="line">    FragmentStore&lt;TSpec, TConfig&gt; <span class="keyword">const</span> &amp; fragStore,</span><br><span class="line">    TAnnotation <span class="keyword">const</span> &amp; annotation,</span><br><span class="line">    TKey <span class="keyword">const</span> &amp; key)</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="http://www.seqan.de/" target="_blank" rel="noopener">seqan官网</a></li><li><a href="https://github.com/seqan/seqan" target="_blank" rel="noopener">github仓库</a></li><li><a href="http://docs.seqan.de/seqan/master/" target="_blank" rel="noopener">API文档</a></li><li><a href="https://seqan.readthedocs.io/en/master/Tutorial/HowTo/UseCases/SimpleRnaSeq.html" target="_blank" rel="noopener">Simple RNA-Seq</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;seqan库是进行生物序列分析的一个现代的C++库,目前有seqan2, seqan3两个版本,seqan3正在开发当中&lt;br&gt;我打算应用seqan库实现一个简单的注释程序,因为seqan3暂时还未实现gtf文件的相关操作,因此选用seqan2  &lt;/p&gt;
&lt;p&gt;seqan
      
    
    </summary>
    
    
    
      <category term="seqan 基因注释" scheme="http://yoursite.com/tags/seqan-%E5%9F%BA%E5%9B%A0%E6%B3%A8%E9%87%8A/"/>
    
  </entry>
  
  <entry>
    <title>linux进行c++开发经验总结</title>
    <link href="http://yoursite.com/2020/04/12/linux-cpp/"/>
    <id>http://yoursite.com/2020/04/12/linux-cpp/</id>
    <published>2020-04-12T14:37:45.000Z</published>
    <updated>2020-04-12T15:24:59.438Z</updated>
    
    <content type="html"><![CDATA[<p>这一周主要就是在linux下进行c++的开发,以此为契机记录下遇到的问题.</p><h2 id="版本管理"><a href="#版本管理" class="headerlink" title="版本管理"></a>版本管理</h2><p>使用<strong>git</strong>管理源代码</p><p>常用命令包括:<em>clone pull push commit checkout branch tag log</em> 等</p><h3 id="拉取代码报错"><a href="#拉取代码报错" class="headerlink" title="拉取代码报错"></a>拉取代码报错</h3><p>git 1.7版本拉去代码报错:<br><em>error: The requested URL returned error: 401 Unauthorized while accessing</em><br>解决方案:升级最新版本git<br>有时候拉取代码不成功,可以ssh/https两种链接都试试</p><h2 id="代码编写"><a href="#代码编写" class="headerlink" title="代码编写"></a>代码编写</h2><p>vim进行临时的一些修改,vscode用于较大的项目,VS Studio用于windows下的调试  </p><p>目前主要使用<strong>vscode</strong>,开发环境是无界面的linux系统,使用最新版本的vscode有连远程代码仓库的功能,可以在本地windows进行远程代码修改</p><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>简单的工程可以一条gcc命令进行编译,较大的项目还是使用cmake更好一些  </p><p>使用<strong>cmake</strong>编译,首先编写CMakeLists.txt,然后编写脚本配置环境变量如include和library路径,再运行cmake和make命令即可完成编译</p><h3 id="查错"><a href="#查错" class="headerlink" title="查错"></a>查错</h3><p>VERBOSE模式,输出具体的gcc编译命令,方便查错,通过<code>make VERBOSE=1</code> 选项来开启模式</p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>可以通过在CMakeLists.txt中添加预定义宏<br><em>add_definitions(-DAABB=1)</em> 来设置宏AABB值为1,或者<em>add_definitions(-DDEBUG)</em> 来打开DEBUG宏</p><h3 id="编译慢问题"><a href="#编译慢问题" class="headerlink" title="编译慢问题"></a>编译慢问题</h3><p>遇到cmake编译慢问题,通过top命令及ps命令查到自己的进程状态为<em>D</em>,查阅手册D含义是进程处于睡眠状态,也就是进程由于等待IO如磁盘IO,网络IO等,导致较长时间都没有响应<br>判断磁盘IO慢的问题,因此修改编译脚本,将编译的中间结果文件输出到临时的内存空间shm中去,编译后再删除临时文件,减少本地磁盘IO操作,从而加速编译过程</p><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>可以直接本地运行,方便查看占用内存和CPU资源情况,也可以使用公司集群系统投递任务,好处是统一的任务管理调度,不会出现资源竞争情况导致程序运行时间波动</p><h3 id="库版本不对"><a href="#库版本不对" class="headerlink" title="库版本不对"></a>库版本不对</h3><p><em>/lib64/libc.so.6: version `GLIBC_2.14’ not found (required by xxx)</em><br>这种情况是本地的libc库版本太旧,需要更新libc库版本</p><h3 id="查看log"><a href="#查看log" class="headerlink" title="查看log"></a>查看log</h3><p>一般程序会输出log到磁盘文件,想要实时监控日志文件的更新内容,可以使用<code>tail -f filename</code>命令,它会在文件内容有更新时将结果输出到命令窗口</p><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><p>使用<strong>gdb</strong>调试C++程序  </p><ol><li>编译时加 <em>-g -gstabs+</em> 选项,并且去除 <em>-O2</em> 等优化选项</li><li>两种调试方式<ol><li>直接<code>gdb ./prog</code> 进入gdb交互环境,通过命令<code>set args xxx</code>来设置参数,然后<code>r</code>来运行</li><li>通过设置,使程序挂掉时生成core文件,通过<code>gdb ./prog core.xxxx</code>来还原程序挂掉前的状态</li></ol></li></ol><p>gdb常用快捷键:</p><ul><li>bt 查看堆栈</li><li>l 查看当前所处位置的源代码</li><li>b 打断的,如<code>b filename::linenum</code> 打断点到文件的某一行,也可以直接打到某函数位置</li><li>n 下一步</li><li>c 继续运行,直到程序结束或者遇到断点</li><li>s 单步调试</li><li>r 重头运行程序</li><li>p 打印变量内容</li><li>help 查看命令提示</li></ul><h2 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h2><p><strong>gprof</strong>工具<br>linux上分析gcc编译出来的程序的CPU时间,找出最耗时的函数  </p><p>使用:</p><ol><li><code>gcc -pg</code> 选项编译</li><li>运行程序,结束后生成gmon.out</li><li><code>gprof ./prog gmon.out -b</code> 查看输出 </li></ol><p>原理: 在每个函数中插入count函数,这样函数调用时就会计算次数和时间<br>缺点: 无法分析多线程程序;无法观察IO时间</p><p><strong>valgrind</strong>工具<br>可以使用它的<em>Memcheck</em> 功能来进行内存检查,或者<em>Callgrind</em> 进行耗时和函数调用情况分析</p><p>使用:</p><ol><li><code>valgrind --tool=callgrind ./prog_name</code> 运行完会生成callgrind.out.xxx的文件</li><li><em>kcachegrind.exe</em> 打开上一步生成的文件,可以看到函数运行耗时,以及调用的流程图</li></ol><p>知道哪个函数或者哪个操作最耗时,再进一步分析是数据结构选型不适合还是算法没有达到最优,再进行速度提升</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这一周主要就是在linux下进行c++的开发,以此为契机记录下遇到的问题.&lt;/p&gt;
&lt;h2 id=&quot;版本管理&quot;&gt;&lt;a href=&quot;#版本管理&quot; class=&quot;headerlink&quot; title=&quot;版本管理&quot;&gt;&lt;/a&gt;版本管理&lt;/h2&gt;&lt;p&gt;使用&lt;strong&gt;git&lt;/st
      
    
    </summary>
    
    
    
      <category term="linux c++" scheme="http://yoursite.com/tags/linux-c/"/>
    
  </entry>
  
  <entry>
    <title>爬取英文演讲资源</title>
    <link href="http://yoursite.com/2020/04/05/scrapy-mp3/"/>
    <id>http://yoursite.com/2020/04/05/scrapy-mp3/</id>
    <published>2020-04-05T06:55:51.000Z</published>
    <updated>2020-04-05T08:01:58.716Z</updated>
    
    <content type="html"><![CDATA[<p>记录下使用python爬取网页并下载资源的过程.</p><h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><p>前段时间制定计划,每天上下班路上听点英语演讲音频练练听力,用的手机App是喜马拉雅,上面资源很丰富,但是有两个问题,一是<strong>有广告</strong>,想想你快睡着的时候突然来15秒字正腔圆的广告是什么感觉,二是<strong>费流量</strong>,我都是在线听的.  </p><p>因此考虑在PC上提前下载好部分音频,导出到手机,再切换到一个精简去广告的手机App来听,岂不美哉.  </p><p>学习英语的网站有不少,也可以提供下载,但一个一个右键另存为就不符合咱程序员的身份了,因此爬虫搞起!</p><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p>爬取之前,复习下需要的知识,当然这次任务很简单,这里只是总结下.  </p><ol><li>python基础. 如文件存取,正则表达式re,多进程multiprocessing</li><li>html网页结构. 如常见的标签tag,CSS中的class</li><li>爬虫相关的库.<ul><li>urllib. 提供接口来打开网页,下载资源</li><li>BeautifulSoup. 解析网页,提取信息</li></ul></li></ol><p>缺少哪个py库,用<code>pip install xx</code> 来安装</p><h2 id="分析与设计"><a href="#分析与设计" class="headerlink" title="分析与设计"></a>分析与设计</h2><h3 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h3><p>人工打开几个目标网页,查看网页源代码来分析下规律,即如何通过主网页,一步步跳转到最终的资源链接.  </p><p>打开主页,上面显示几十个链接,每一个链接分别是一个具体的演讲页面,其中一个表示如下:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">td</span> <span class="attr">align</span>=<span class="string">"center"</span> <span class="attr">class</span>=<span class="string">"titlepic"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"/tingli/speech/mxlzyj/326635.html"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"/d/file/201906/6fffc975854bf3f3136637cd69cc6397.jpg"</span> <span class="attr">alt</span>=<span class="string">"库克杜兰大学演讲：勇于尝试 敢于做先行者(全文)"</span> <span class="attr">width</span>=<span class="string">"145"</span> <span class="attr">height</span>=<span class="string">"125"</span> <span class="attr">border</span>=<span class="string">"0"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br></pre></td></tr></table></figure><p>因此只要匹配到align属性为’center’,class属性为[‘titlepic’]的td标签,获取第一个href即是一个演讲的链接地址<br>这里要注意给出的链接是需要补齐前缀的</p><p>针对每一个具体的演讲的网页,基本都提供了一个音频的播放器</p><p><img src="/images/scrapy_mp3/speech_player.png" alt=""></p><p>只要点击下载图标按钮,就会切换到另一个网页,内容为</p><p><img src="/images/scrapy_mp3/download_icon.png" alt=""></p><p>这里两个图标分别对应mp3和lrc歌词的资源地址</p><p>分析音频播放器下载按钮的链接,不出意料,是一个js函数,如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;SCRIPT type=text/javascript&gt;</span><br><span class="line">$(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    $(<span class="string">".jp-title"</span>).hover(</span><br><span class="line">            <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                $(<span class="keyword">this</span>).addClass(<span class="string">"jp-title-hover"</span>);</span><br><span class="line">            &#125;,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                $(<span class="keyword">this</span>).removeClass(<span class="string">"jp-title-hover"</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">    $(<span class="string">".jp-title"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        $(<span class="string">".help"</span>).slideToggle();</span><br><span class="line">    &#125;);</span><br><span class="line">    $(<span class="string">".jp-download"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">window</span>.open(<span class="string">'/e/action/down.php?classid=10467&amp;id=326635&amp;mp3=http://mp3.en8848.com/speech/2019tim-cook-tulane.mp3'</span>) ;</span><br><span class="line">    &#125;);</span><br><span class="line">    $(<span class="string">".anniu"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        $(<span class="string">".download"</span>).hide();</span><br><span class="line">    &#125;);</span><br><span class="line">    $(<span class="string">"a[id^='jplayer_tc_']"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;location.href=$(<span class="keyword">this</span>).attr(<span class="string">'href'</span>)&#125;);</span><br><span class="line">&#125;);</span><br><span class="line">&lt;<span class="regexp">/SCRIPT&gt;</span></span><br></pre></td></tr></table></figure><p>重点就是<em>window.open</em> 后的内容,指向最终下载页面的链接.<br>这里可以通过正则表达式来解析链接地址</p><p>分析最终页面,发现内容如下:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">id</span>=<span class="string">"dload"</span> <span class="attr">target</span>=<span class="string">"_blank"</span> <span class="attr">href</span>=<span class="string">"http://mp3.en8848.com/speech/2019tim-cook-tulane.mp3"</span> <span class="attr">class</span>=<span class="string">"download"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">id</span>=<span class="string">"dloadword"</span> <span class="attr">href</span>=<span class="string">"http://mp3.en8848.com/speech/2019tim-cook-tulane.lrc"</span> <span class="attr">class</span>=<span class="string">"download"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>即mp3资源链接即是从播放器下载图标中提取出来的链接中的 <strong>mp3=xxx</strong>的地址<br>lrc歌词改下后缀即可</p><h3 id="提炼总结"><a href="#提炼总结" class="headerlink" title="提炼总结"></a>提炼总结</h3><ol><li>根据提供的主页,通过<strong>特定的td标签</strong>解析出来每一个演讲的链接,即是一个单独的任务</li><li>对每个任务,解析js中<strong>window.open</strong>后跟的链接,即是最终的资源所在;分别下载mp3和lrc即可</li></ol><h3 id="伪码"><a href="#伪码" class="headerlink" title="伪码"></a>伪码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">main_url &#x3D; &quot;xxx.html&quot;</span><br><span class="line">for td_tag in main_url:</span><br><span class="line">    check if td_tag is valid</span><br><span class="line">    get speech_url from td_tag</span><br><span class="line">    extract rescource_url from speech_url</span><br><span class="line">    download resource_url+&#39;.mp3&#39; and resource_url+&#39;.lrc&#39;</span><br></pre></td></tr></table></figure><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#-- codeding:utf-8 --</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> urllib</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> multiprocessing <span class="keyword">as</span> mp</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">crawl</span><span class="params">(url, dest_dir)</span>:</span></span><br><span class="line">    speech = urllib.urlopen(url).read().decode(<span class="string">"utf-8"</span>)</span><br><span class="line">    speech_soup = BeautifulSoup(speech, <span class="string">"lxml"</span>)</span><br><span class="line">    <span class="comment"># Get speech name.</span></span><br><span class="line">    speech_name = <span class="string">""</span></span><br><span class="line">    <span class="keyword">for</span> div_tag <span class="keyword">in</span> speech_soup.find_all(<span class="string">'div'</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="string">'class'</span> <span class="keyword">in</span> div_tag.attrs <span class="keyword">and</span> div_tag[<span class="string">'class'</span>] == [<span class="string">"sean_title"</span>]:</span><br><span class="line">            speech_name = div_tag.get_text()</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> speech_name == <span class="string">""</span>: <span class="keyword">return</span></span><br><span class="line">    <span class="comment"># Remove extra spaces.</span></span><br><span class="line">    speech_name = speech_name.replace(<span class="string">" "</span>, <span class="string">""</span>)</span><br><span class="line">    <span class="keyword">for</span> script_tag <span class="keyword">in</span> speech_soup.find_all(<span class="string">'script'</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="string">'type'</span> <span class="keyword">in</span> script_tag.attrs <span class="keyword">and</span> script_tag[<span class="string">'type'</span>] == <span class="string">"text/javascript"</span>:</span><br><span class="line">            p = re.compile(<span class="string">r'mp3=(.*).mp3'</span>, re.DOTALL)</span><br><span class="line">            <span class="comment">#print script_tag.get_text()</span></span><br><span class="line">            match = p.findall(script_tag.get_text())</span><br><span class="line">            <span class="keyword">if</span> match:</span><br><span class="line">                urllib.urlretrieve(match[<span class="number">0</span>]+<span class="string">'.mp3'</span>, dest_dir+speech_name+<span class="string">'.mp3'</span>)</span><br><span class="line">                urllib.urlretrieve(match[<span class="number">0</span>]+<span class="string">'.lrc'</span>, dest_dir+speech_name+<span class="string">'.lrc'</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">scrapy_map3</span><span class="params">()</span>:</span></span><br><span class="line">    origin_url = <span class="string">"http://www.en8848.com.cn/tingli/speech/mxlzyj/index.html"</span></span><br><span class="line">    prefix_url = <span class="string">"http://www.en8848.com.cn"</span></span><br><span class="line">    l = urllib.urlopen(origin_url).read().decode(<span class="string">"utf-8"</span>)</span><br><span class="line">    soup = BeautifulSoup(l, <span class="string">"lxml"</span>)</span><br><span class="line">    dest_dir = <span class="string">'./speech/'</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(dest_dir): os.mkdir(dest_dir)</span><br><span class="line">    <span class="comment"># Format: &lt;td align="center"&gt;&lt;a href=xxx&gt;&lt;/td&gt;</span></span><br><span class="line">    pool = mp.Pool(<span class="number">4</span>)</span><br><span class="line">    <span class="keyword">for</span> td_tag <span class="keyword">in</span> soup.find_all(<span class="string">'td'</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="string">'align'</span> <span class="keyword">not</span> <span class="keyword">in</span> td_tag.attrs <span class="keyword">or</span> <span class="string">'class'</span> <span class="keyword">not</span> <span class="keyword">in</span> td_tag.attrs: <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> td_tag[<span class="string">'align'</span>] == <span class="string">'center'</span> <span class="keyword">and</span> td_tag[<span class="string">'class'</span>] == [<span class="string">'titlepic'</span>]:</span><br><span class="line">            url = prefix_url + td_tag.a.get(<span class="string">"href"</span>)</span><br><span class="line">            pool.apply_async(crawl, args=(url,dest_dir))</span><br><span class="line">    pool.close()</span><br><span class="line">    pool.join()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    scrapy_map3()</span><br></pre></td></tr></table></figure><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>代码实现是在设计的伪码基础上填充了细节,诸如具体的判断,以及文件名的获取等未提到的细节</p><p>考虑到网页获取,文本解析,资源下载速度较慢,而每一个演讲都是独立的,可以使用多进程进行加速</p><p>除了多进程,还有异步IO,协程等方式可以加速</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="http://www.en8848.com.cn/tingli/speech/mxlzyj/index.html" target="_blank" rel="noopener">小e英语_英语演讲</a></li><li><a href="https://morvanzhou.github.io/tutorials/data-manipulation/scraping/" target="_blank" rel="noopener">莫烦python_爬虫基础</a></li><li><a href="https://www.crummy.com/software/BeautifulSoup/bs4/doc/index.zh.html" target="_blank" rel="noopener">BeautifulSoup4.2.0中文文档</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;记录下使用python爬取网页并下载资源的过程.&lt;/p&gt;
&lt;h2 id=&quot;动机&quot;&gt;&lt;a href=&quot;#动机&quot; class=&quot;headerlink&quot; title=&quot;动机&quot;&gt;&lt;/a&gt;动机&lt;/h2&gt;&lt;p&gt;前段时间制定计划,每天上下班路上听点英语演讲音频练练听力,用的手机App是喜
      
    
    </summary>
    
    
    
      <category term="爬虫 python" scheme="http://yoursite.com/tags/%E7%88%AC%E8%99%AB-python/"/>
    
  </entry>
  
  <entry>
    <title>vim实用技巧</title>
    <link href="http://yoursite.com/2020/03/29/vim-practical-skills/"/>
    <id>http://yoursite.com/2020/03/29/vim-practical-skills/</id>
    <published>2020-03-29T12:35:59.000Z</published>
    <updated>2020-03-29T12:41:42.372Z</updated>
    
    <content type="html"><![CDATA[<p>记录vim实用技巧,会长期更新</p><h2 id="record-回放功能"><a href="#record-回放功能" class="headerlink" title="record 回放功能"></a>record 回放功能</h2><p>使用场景:需要多次进行的有规律但较为复杂的操作<br>步骤:</p><ol><li>q+a 开始录制</li><li>命令完成,按q停止</li><li>@+a 重复执行命令  </li></ol><p>其中a是record名字</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;记录vim实用技巧,会长期更新&lt;/p&gt;
&lt;h2 id=&quot;record-回放功能&quot;&gt;&lt;a href=&quot;#record-回放功能&quot; class=&quot;headerlink&quot; title=&quot;record 回放功能&quot;&gt;&lt;/a&gt;record 回放功能&lt;/h2&gt;&lt;p&gt;使用场景:需要多次进行
      
    
    </summary>
    
    
    
      <category term="vim" scheme="http://yoursite.com/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>工作中遇到的压缩方式总结</title>
    <link href="http://yoursite.com/2020/03/22/compress-method/"/>
    <id>http://yoursite.com/2020/03/22/compress-method/</id>
    <published>2020-03-22T13:00:52.000Z</published>
    <updated>2020-03-22T14:23:49.053Z</updated>
    
    <content type="html"><![CDATA[<p>本文总结工作中使用过的数据压缩方法,主要有zlib,qatzip,igzip等<br>最后还进行了针对大规模数据多线程解压缩加速的分析</p><h2 id="zlib库"><a href="#zlib库" class="headerlink" title="zlib库"></a>zlib库</h2><p>zlib是用于数据压缩的函数库,使用deflate算法<br><strong>deflate算法</strong>是同时使用了<em>LZ77算法</em>和<em>霍夫曼编码</em>的一个无损压缩算法</p><p>主要函数有:</p><ul><li><code>int compress (Bytef *dest, uLongf *destLen, const Bytef *source, uLong sourceLen);</code><br>  压缩方法,将源缓冲中的数据压缩并放入目的缓冲区<br>  注意目的缓冲区的大小有可能比压缩前还要大,因此destLen要留够空间,至少比sourceLen加12字节之后还大0.1%<br>  返回Z_OK表示成功;Z_MEM_ERROR表示没有足够内存;Z_BUF_ERROR表示目的缓冲区不够大</li><li><code>int compress2 (Bytef *dest, uLongf *destLen,const Bytef *source, uLong sourceLen,int level);</code><br>  功能与compress函数一样,增加了level参数,范围0-9,从0-9速度变慢,但压缩率提高,设置0表示不压缩,Z_DEFAULT_COMPRESSION 表示设置一个适中的参数<br>  返回值与compress相同,多出Z_STREAM_ERROR 表示level参数无效</li><li><code>int uncompress (Bytef *dest, uLongf *destLen,const Bytef *source, uLong sourceLen);</code><br>  解压缩<br>  返回值与compress相同,多出一个Z_DATA_ERROR 表示输入数据被破坏</li><li><code>deflateInit() + deflate() + deflateEnd()</code><br>  三个函数结合完成compress功能,参考zlib仓库example.c compress.c</li><li><code>inflateInit() + inflate() + inflateEnd()</code><br>  三个函数完成uncompress功能</li><li>gz开头的函数,用来操作gz文件,类似stdio调用,如果gzopen,gzwrite等</li></ul><p>简单的压缩示例代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;zlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gzCompress</span><span class="params">(Bytef *data, uLong ndata, Bytef *zdata, uLong *nzdata, <span class="keyword">int</span> level)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// error code </span></span><br><span class="line"><span class="comment">// Z_OK if success, Z_MEM_ERROR if there was not enough memory, </span></span><br><span class="line"><span class="comment">// Z_BUF_ERROR:-5 if there was not enough room in the output buffer, </span></span><br><span class="line"><span class="comment">// Z_STREAM_ERROR if the level parameter is invalid.</span></span><br><span class="line">z_stream c_stream;</span><br><span class="line"><span class="keyword">int</span> err = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (data &amp;&amp; ndata &gt; <span class="number">0</span>) </span><br><span class="line">&#123;</span><br><span class="line">c_stream.zalloc = <span class="literal">NULL</span>;</span><br><span class="line">c_stream.zfree = <span class="literal">NULL</span>;</span><br><span class="line">c_stream.opaque = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">if</span> (deflateInit2(&amp;c_stream, level, Z_DEFLATED,</span><br><span class="line">MAX_WBITS + <span class="number">16</span>, <span class="number">8</span>, Z_DEFAULT_STRATEGY) != Z_OK) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">c_stream.next_in = data;</span><br><span class="line">c_stream.avail_in = ndata;</span><br><span class="line">c_stream.next_out = zdata;</span><br><span class="line">c_stream.avail_out = *nzdata;</span><br><span class="line"><span class="keyword">while</span> (c_stream.avail_in != <span class="number">0</span> &amp;&amp; c_stream.total_out &lt; *nzdata) </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> ((err = deflate(&amp;c_stream, Z_BLOCK)) != Z_OK)</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (...)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"deflate error: "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (c_stream.avail_in != <span class="number">0</span>) </span><br><span class="line"><span class="keyword">return</span> c_stream.avail_in;</span><br><span class="line"><span class="keyword">for</span> (;;) </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> ((err = deflate(&amp;c_stream, Z_FINISH)) == Z_STREAM_END) <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span> (err != Z_OK) <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (deflateEnd(&amp;c_stream) != Z_OK) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">*nzdata = c_stream.total_out;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于压缩等级,从0-9,速度越来越慢,随之而来的是更低的压缩率</p><p>压缩文件是二进制的,由三部分组成</p><ol><li>头信息</li><li>数据主体 </li><li>校验</li></ol><p>以下为标准格式的简要说明,详细解释可以看参考文档:<br><img src="/images/compress_method/header.png" alt=""></p><h2 id="qatzip库"><a href="#qatzip库" class="headerlink" title="qatzip库"></a>qatzip库</h2><p>通过硬件加速的方式进行压缩,即需要插入一张单独的intel的QAT卡;好处显而易见,正常压缩是消耗CPU资源,用另一张卡单独进行压缩,空闲出CPU资源可以进行其他计算,提高整体效率,缺点就是费钱,并占用一个PCIE插槽位置<br>另外只能运行于linux系统,不支持windows</p><p><a href="https://github.com/intel/QATzip.git" target="_blank" rel="noopener">qatzip_github代码仓库</a></p><p>简单的压缩代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> COMPILE_QAT</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cpa.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cpa_dc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;qatzip.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;qatzip_internal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;qz_utils.h&gt;</span></span></span><br><span class="line"><span class="keyword">extern</span> QzSessionParams_T g_params_th;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qzipCompress</span><span class="params">(Bytef *data, uLong ndata, Bytef *zdata, uLong *nzdata, <span class="keyword">int</span> level)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> COMPILE_QAT</span></span><br><span class="line">    QzSession_T session;</span><br><span class="line">    <span class="keyword">int</span> rc;</span><br><span class="line"></span><br><span class="line">    rc = qzInit(&amp;session, g_params_th.sw_backup);</span><br><span class="line">    <span class="keyword">if</span> (rc != QZ_OK &amp;&amp; rc != QZ_DUPLICATE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"qzInit failed, rc:"</span>&lt;&lt;rc&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    rc = qzSetupSession(&amp;session, &amp;g_params_th);</span><br><span class="line">    <span class="keyword">if</span> (rc != QZ_OK &amp;&amp; rc != QZ_NO_INST_ATTACH)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"qzSetupSession failed, rc:"</span>&lt;&lt;rc&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    rc = qzCompress(&amp;session, data, (<span class="keyword">uint32_t</span> *)&amp;ndata, zdata, (<span class="keyword">uint32_t</span> *)nzdata, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (rc != QZ_OK)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"qzCompress failed, rc:"</span>&lt;&lt;rc&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    qzTeardownSession(&amp;session);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="keyword">return</span> gzCompress(data, ndata, zdata, nzdata, level);</span><br><span class="line"><span class="meta">#e</span></span><br></pre></td></tr></table></figure><h2 id="igzip库"><a href="#igzip库" class="headerlink" title="igzip库"></a>igzip库</h2><p>intel工程师使用指令集优化zlib,针对genomic data比如<strong>bam sam</strong>数据,在几乎不降低压缩率的情况下,速度提升约4倍<br><a href="https://github.com/intel/isa-l.git" target="_blank" rel="noopener">igzip_github代码仓库</a><br>igzip的代码和isa-l代码仓库在一起</p><p>igzip使用代码示例:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"igzip_lib.h"</span></span></span><br><span class="line"><span class="keyword">int</span> level_size_buf[<span class="number">10</span>] = &#123;</span><br><span class="line">#ifdef ISAL_DEF_LVL0_DEFAULT</span><br><span class="line">ISAL_DEF_LVL0_DEFAULT,</span><br><span class="line">#<span class="keyword">else</span></span><br><span class="line"><span class="number">0</span>,</span><br><span class="line">#endif</span><br><span class="line">#ifdef ISAL_DEF_LVL1_DEFAULT</span><br><span class="line">ISAL_DEF_LVL1_DEFAULT,</span><br><span class="line">#<span class="keyword">else</span></span><br><span class="line"><span class="number">0</span>,</span><br><span class="line">#endif</span><br><span class="line">#ifdef ISAL_DEF_LVL2_DEFAULT</span><br><span class="line">ISAL_DEF_LVL2_DEFAULT,</span><br><span class="line">#<span class="keyword">else</span></span><br><span class="line"><span class="number">0</span>,</span><br><span class="line">#endif</span><br><span class="line">#ifdef ISAL_DEF_LVL3_DEFAULT</span><br><span class="line">ISAL_DEF_LVL3_DEFAULT,</span><br><span class="line">#<span class="keyword">else</span></span><br><span class="line"><span class="number">0</span>,</span><br><span class="line">#endif</span><br><span class="line">#ifdef ISAL_DEF_LVL4_DEFAULT</span><br><span class="line">ISAL_DEF_LVL4_DEFAULT,</span><br><span class="line">#<span class="keyword">else</span></span><br><span class="line"><span class="number">0</span>,</span><br><span class="line">#endif</span><br><span class="line">#ifdef ISAL_DEF_LVL5_DEFAULT</span><br><span class="line">ISAL_DEF_LVL5_DEFAULT,</span><br><span class="line">#<span class="keyword">else</span></span><br><span class="line"><span class="number">0</span>,</span><br><span class="line">#endif</span><br><span class="line">#ifdef ISAL_DEF_LVL6_DEFAULT</span><br><span class="line">ISAL_DEF_LVL6_DEFAULT,</span><br><span class="line">#<span class="keyword">else</span></span><br><span class="line"><span class="number">0</span>,</span><br><span class="line">#endif</span><br><span class="line">#ifdef ISAL_DEF_LVL7_DEFAULT</span><br><span class="line">ISAL_DEF_LVL7_DEFAULT,</span><br><span class="line">#<span class="keyword">else</span></span><br><span class="line"><span class="number">0</span>,</span><br><span class="line">#endif</span><br><span class="line">#ifdef ISAL_DEF_LVL8_DEFAULT</span><br><span class="line">ISAL_DEF_LVL8_DEFAULT,</span><br><span class="line">#<span class="keyword">else</span></span><br><span class="line"><span class="number">0</span>,</span><br><span class="line">#endif</span><br><span class="line">#ifdef ISAL_DEF_LVL9_DEFAULT</span><br><span class="line">ISAL_DEF_LVL9_DEFAULT,</span><br><span class="line">#<span class="keyword">else</span></span><br><span class="line"><span class="number">0</span>,</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> mylong;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> mychar;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">igzipCompress</span><span class="params">(mychar* source, mylong source_len, mychar* dest, mylong* dest_len, </span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">int</span> level)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">isal_zstream</span> <span class="title">stream</span>;</span> <span class="comment">/* Holds stream information */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">isal_gzip_header</span> <span class="title">gz_hdr</span>;</span></span><br><span class="line"></span><br><span class="line">isal_gzip_header_init(&amp;gz_hdr); <span class="comment">/* Set gzip header default values */</span></span><br><span class="line"></span><br><span class="line">isal_deflate_init(&amp;stream); <span class="comment">/* Initialize compression stream data structure */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> level_size = level_size_buf[level];</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> * level_buf = <span class="literal">NULL</span>;</span><br><span class="line">level_buf = (<span class="keyword">unsigned</span> <span class="keyword">char</span>*)<span class="built_in">malloc</span>(level_size);</span><br><span class="line"></span><br><span class="line">stream.avail_in = <span class="number">0</span>; <span class="comment">// Number of bytes available at next_in.</span></span><br><span class="line">stream.flush = NO_FLUSH;    <span class="comment">// Flush type can be NO_FLUSH,SYNC_FLUSH or FULL_FLUSH.</span></span><br><span class="line">stream.level = level;   <span class="comment">// Compression level to use.</span></span><br><span class="line">stream.level_buf = level_buf; <span class="comment">// User allocated buffer required for different compression levels.</span></span><br><span class="line">stream.level_buf_size = level_size;   <span class="comment">// Size of level_buf.</span></span><br><span class="line">stream.gzip_flag = IGZIP_GZIP_NO_HDR;   <span class="comment">// Indicate if gzip compression is to be performed.</span></span><br><span class="line">stream.next_out = dest; <span class="comment">// Next output byte.</span></span><br><span class="line">stream.avail_out = *dest_len;   <span class="comment">// Number of bytes avaliable at next_out.</span></span><br><span class="line"></span><br><span class="line">isal_write_gzip_header(&amp;stream, &amp;gz_hdr);   <span class="comment">/* Write gzip header to output stream. */</span></span><br><span class="line"></span><br><span class="line">stream.next_in = source;</span><br><span class="line">stream.avail_in = source_len;</span><br><span class="line">stream.end_of_stream = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ret = isal_deflate(&amp;stream);</span><br><span class="line"><span class="keyword">if</span> (ret != ISAL_DECOMP_OK) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"igzip: Error encountered while compressing file\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (level_buf != <span class="literal">NULL</span>)</span><br><span class="line"><span class="built_in">free</span>(level_buf);</span><br><span class="line">*dest_len = stream.next_out - dest;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="bgzip库及多线程解压缩"><a href="#bgzip库及多线程解压缩" class="headerlink" title="bgzip库及多线程解压缩"></a>bgzip库及多线程解压缩</h2><p>bgzip:Block compression/decompression utility<br>用于bam/sam文件的格式,核心是将压缩数据分块(64KB),从而通过索引可以快速查询数据  </p><p>注:bam/sam文件是高通量测序的标准格式文件,存储内容为fastq文件与参考基因组reference进行mapping之后的数据;其中sam为文本格式,bam为二进制格式,两者可以通过<em>samtools</em>工具相互转换;bam文件可以通过建立index,快速定位数据位置,从而加速访问</p><p>考虑这样一种情况,有一千个block的数据需要压缩并存放在一个文件中,这个文件可能很大,几百GB;假如我只想要分析某几个block的数据,传统的压缩方式需要将整个文件全部解压之后才能获取想要的数据,效率很低</p><p>而通过自定义压缩block的head信息,使用其中的<strong>extra filed</strong> 和 <strong>comment</strong> 字段就可以实现index功能,步骤如下:</p><ol><li><p>压缩前,首先添加字段:comment添加block的ID,extra field添加压缩前和后的bytes大小;以zlib压缩举例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">uint8_t</span> EXTRA_LEN = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">uint8_t</span> EXTRA_BUF_LEN = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">uint8_t</span> SI1 = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">uint8_t</span> SI2 = <span class="number">101</span>;</span><br><span class="line"></span><br><span class="line">gz_header header;</span><br><span class="line"><span class="comment">// 添加comment信息,如指定当前block的ID,如1,2,3等</span></span><br><span class="line"><span class="comment">// 用于后续快速获取想要的block数据</span></span><br><span class="line">header.comment = (Bytef *)&amp;comment[<span class="number">0</span>];</span><br><span class="line">header.comm_max = comment.size() + <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 按照标准格式指定extra field的长度信息</span></span><br><span class="line">header.extra_len = EXTRA_LEN;</span><br><span class="line">header.extra_max = EXTRA_BUF_LEN;</span><br><span class="line"><span class="keyword">uint8_t</span> extra_buf[EXTRA_LEN] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="comment">// SI1 SI2为自定义字段,用来标识我们自定义的头文件格式</span></span><br><span class="line">extra_buf[<span class="number">0</span>] = SI1;</span><br><span class="line">extra_buf[<span class="number">1</span>] = SI2;</span><br><span class="line">extra_buf[<span class="number">2</span>] = EXTRA_BUF_LEN;</span><br><span class="line">extra_buf[<span class="number">3</span>] = <span class="number">0</span>;</span><br><span class="line">header.extra = extra_buf;</span><br><span class="line">err = deflateSetHeader(&amp;c_stream, &amp;header);</span><br></pre></td></tr></table></figure></li><li><p>压缩后,更新extra filed中压缩前后数据长度</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">*nzdata = c_stream.total_out;</span><br><span class="line"></span><br><span class="line">mylong dest_size = *nzdata; <span class="comment">// 压缩后大小,必须压缩完之后才能获取</span></span><br><span class="line">mylong raw_size = ndata; <span class="comment">// 压缩前大小,是输入参数,我们是知道的</span></span><br><span class="line"><span class="comment">// 将两个长度按顺序写入字节流</span></span><br><span class="line"><span class="built_in">memcpy</span>(zdata + <span class="number">16</span>, &amp;dest_size, <span class="keyword">sizeof</span>(dest_size));</span><br><span class="line"><span class="built_in">memcpy</span>(zdata + <span class="number">24</span>, &amp;raw_size, <span class="keyword">sizeof</span>(raw_size));</span><br></pre></td></tr></table></figure></li><li><p>解压缩的时候,首先找到第一个block,读入头信息,获取当前block的标识ID,如果是想要的数据,则通过extra field获取数据长度,按照长度直接读取即可,然后跳到下一个block<br>因为对于无用的block数据,我们只要解析头信息,并<strong>根据长度进行偏移</strong>即可,所以遍历速度会很快<br>然后还可以通过<strong>多线程</strong>进行解压缩,主线程进行block的遍历,如果遇到目标数据,则从线程池中拿一个线程处理当前block<br>如果不需要解压缩,只是从1000个block中采样10个block进行后续的快速分析,则直接将10个block的二进制数据连续输出到磁盘文件即可,多个block可以直接cat到一起而不影响解压缩</p></li></ol><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://www.cnblogs.com/zhuyf87/archive/2013/02/21/2920522.html" target="_blank" rel="noopener">zlib压缩数据</a><br><a href="http://zlib.net/" target="_blank" rel="noopener">zlib官网</a><br><a href="https://software.intel.com/en-us/articles/igzip-a-high-performance-deflate-compressor-with-optimizations-for-genomic-data" target="_blank" rel="noopener">High Performance DEFLATE Compression with Optimizations for Genomic Data Sets</a><br><a href="http://www.zlib.org/rfc-gzip.html" target="_blank" rel="noopener">GZIP file format specification version 4.3</a><br><a href="https://zlib.net/manual.html" target="_blank" rel="noopener">GZIP文件格式简介</a><br><a href="http://www.htslib.org/doc/bgzip.html" target="_blank" rel="noopener">zlib 1.2.11 Manual</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文总结工作中使用过的数据压缩方法,主要有zlib,qatzip,igzip等&lt;br&gt;最后还进行了针对大规模数据多线程解压缩加速的分析&lt;/p&gt;
&lt;h2 id=&quot;zlib库&quot;&gt;&lt;a href=&quot;#zlib库&quot; class=&quot;headerlink&quot; title=&quot;zlib库&quot;&gt;
      
    
    </summary>
    
    
    
      <category term="压缩 zlib igzip" scheme="http://yoursite.com/tags/%E5%8E%8B%E7%BC%A9-zlib-igzip/"/>
    
  </entry>
  
  <entry>
    <title>在cuda中使用哈希表</title>
    <link href="http://yoursite.com/2020/03/15/use-hash-in-cuda/"/>
    <id>http://yoursite.com/2020/03/15/use-hash-in-cuda/</id>
    <published>2020-03-15T12:08:38.000Z</published>
    <updated>2020-03-15T13:04:19.851Z</updated>
    
    <content type="html"><![CDATA[<p>关于在cuda中使用哈希表的一些经验总结</p><h2 id="cuda中哈希方法"><a href="#cuda中哈希方法" class="headerlink" title="cuda中哈希方法"></a>cuda中哈希方法</h2><p>目前已知的在cuda中使用哈希的方法:</p><ol><li><p><strong>数组</strong><br>适用于较小的数据规模,如键的范围是int,或者能转化为整型,值类型最长为long等</p></li><li><p><strong>cudpp</strong><br>可接受的键值范围均为32bit,相比数组好处是占用内存小,不用存储无用数据<br>其内部使用布谷鸟过滤,核心思想是多个hash算法生成多个映射值,如果有一个位置是空的,就将元素放入,否则踢走其中一个,被踢走的再去踢别人,依次类推<br>缺点是无法动态插入,即必须把键值对先准备好;主要用来查询<br><a href="https://github.com/cudpp/cudpp" target="_blank" rel="noopener">cudpp_github</a></p></li><li><p><strong>huge-CTR</strong><br>这是英伟达开发的一个点击率推荐系统的库,其中实现了哈希功能<br>优点是官方文档写了支持动态插入<br><a href="https://github.com/NVIDIA/HugeCTR" target="_blank" rel="noopener">huge-CTR_github</a></p></li></ol><h2 id="cudpp-hash使用"><a href="#cudpp-hash使用" class="headerlink" title="cudpp hash使用"></a>cudpp hash使用</h2><p>使用步骤:</p><ol><li><p>获取GPU卡信息<br>这也是任何cuda程序的第一步,检查有没有卡,以及卡的计算能力等;使用<code>cudaGetDeviceCount() cudaGetDeviceProperties()</code>等API来获取信息</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> deviceCount;</span><br><span class="line">cudaGetDeviceCount(&amp;deviceCount);</span><br><span class="line"><span class="keyword">if</span> (deviceCount == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Error (main): no devices supporting CUDA.\n"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> dev = <span class="number">0</span>;</span><br><span class="line">cudaSetDevice(dev);</span><br><span class="line">cudaDeviceProp prop;</span><br><span class="line"><span class="keyword">if</span> (!quiet &amp;&amp; cudaGetDeviceProperties(&amp;prop, dev) == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Using device %d:\n"</span>, dev);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s; global mem: %uB; compute v%d.%d; clock: %d kHz\n"</span>,</span><br><span class="line">           prop.name, (<span class="keyword">unsigned</span> <span class="keyword">int</span>)prop.totalGlobalMem, (<span class="keyword">int</span>)prop.major,</span><br><span class="line">           (<span class="keyword">int</span>)prop.minor, (<span class="keyword">int</span>)prop.clockRate);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (prop.major &lt; <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"ERROR: CUDPP hash tables are only supported on "</span></span><br><span class="line">            <span class="string">"devices with compute\n  capability 2.0 or greater; "</span></span><br><span class="line">            <span class="string">"exiting.\n"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建<em>CUDPP Handle</em><br>CUDPPHandle 在每个cuda上下文都要建立一个</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CUDPPHandle theCudpp;</span><br><span class="line">CUDPPResult result = cudppCreate(&amp;theCudpp);</span><br><span class="line"><span class="keyword">if</span> (result != CUDPP_SUCCESS)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Error initializing CUDPP Library.\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>准备数据<br> 准备两个unsigned int* 数组, 分别存放keys和values<br> 也可以从一个std::unordered_map获取数据<br> 将keys和values从host拷贝到device</p></li><li><p>创建<em>CUDPPHandle</em></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">CUDPPHashTableConfig config;</span><br><span class="line">config.type = CUDPP_BASIC_HASH_TABLE;</span><br><span class="line">config.kInputSize = kInputSize;</span><br><span class="line">config.space_usage = space_usage;<span class="comment">// 测试值有 1.05f, 1.15f, 1.25f, 1.5f, 2.0f</span></span><br><span class="line">CUDPPHandle hash_table_handle;</span><br><span class="line">CUDPPResult result;</span><br><span class="line">result = cudppHashTable(theCudpp, &amp;hash_table_handle, &amp;config);</span><br><span class="line"><span class="keyword">if</span> (result != CUDPP_SUCCESS)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Error in cudppHashTable call in"</span></span><br><span class="line">            <span class="string">"testHashTable (make sure your device is at"</span></span><br><span class="line">            <span class="string">"least compute version 2.0\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>插入数据</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">result = cudppHashInsert(hash_table_handle, d_test_keys, d_test_vals, kInputSize);</span><br><span class="line">cudaThreadSynchronize();</span><br><span class="line"><span class="keyword">if</span> (result != CUDPP_SUCCESS)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Error in cudppHashInsert call in testHashTable\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用哈希表查询数据</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">result = cudppHashRetrieve(hash_table_handle, d_test_keys, d_test_vals, kInputSize);</span><br><span class="line">cudaThreadSynchronize();</span><br><span class="line"><span class="keyword">if</span> (result != CUDPP_SUCCESS)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Error in cudppHashRetrieve call in testHashTable\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>验证数据<br>将查询的结果由GPU内存拷贝回CPU内存,进行数据的验证</p></li><li><p>释放资源</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">result = cudppDestroyHashTable(theCudpp, hash_table_handle);</span><br><span class="line"><span class="keyword">if</span> (result != CUDPP_SUCCESS)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Error in cudppDestroyHashTable call in testHashTable\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">result = cudppDestroy(theCudpp);</span><br><span class="line"><span class="keyword">if</span> (result != CUDPP_SUCCESS)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Error shutting down CUDPP Library.\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="问题和改进"><a href="#问题和改进" class="headerlink" title="问题和改进"></a>问题和改进</h2><h3 id="cudpp内存泄漏问题"><a href="#cudpp内存泄漏问题" class="headerlink" title="cudpp内存泄漏问题"></a>cudpp内存泄漏问题</h3><p>cudpp在更新的cuda版本如cuda10,更新的显卡架构如TitanV下出现内存泄漏问题<br>情况就是只要使用cudpp的lib,代码经过第一个cuda API调用之后就会卡死,内存不断增长,直到内存爆掉<br>经过测试,我发现是计算能力配置问题,新的显卡架构支持更高的计算能力,只要在编译选项中增加<strong>compute_60;compute_70</strong>即可解决问题<br>详见<a href="https://github.com/cudpp/cudpp/issues/187" target="_blank" rel="noopener">cudpp_issues_187</a></p><h3 id="扩展cudpp哈希表"><a href="#扩展cudpp哈希表" class="headerlink" title="扩展cudpp哈希表"></a>扩展cudpp哈希表</h3><blockquote><p>修改CUDPP库中哈希功能支持更长的键类型.</p></blockquote><blockquote><p>原库支持32bit键值对,将其编码在64bit的long long类型中;我实际工作中需要对碱基序列进行哈希查找,每一个碱基可能有ACGTN五种类型,最开始只处理单barcode是10bp,所以有5^10(9765625)种可能序列,不到10M数据,在cuda中使用数组就可以了;后来需要处理双barcode,20bp,有5^20(95367431640625)种可能序列,需要约95T数据,数组显然不够,只能用哈希,因此将键类型从32bit扩展到48bit,可以支持5^20的键,剩下16bit存储值,依然编码到64bit的long long类型,达到最小改动满足需求的目的.</p></blockquote><p><a href="https://github.com/tigeroses/cudpp" target="_blank" rel="noopener">仓库地址</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;关于在cuda中使用哈希表的一些经验总结&lt;/p&gt;
&lt;h2 id=&quot;cuda中哈希方法&quot;&gt;&lt;a href=&quot;#cuda中哈希方法&quot; class=&quot;headerlink&quot; title=&quot;cuda中哈希方法&quot;&gt;&lt;/a&gt;cuda中哈希方法&lt;/h2&gt;&lt;p&gt;目前已知的在cuda中使用哈
      
    
    </summary>
    
    
    
      <category term="cuda hash cudpp" scheme="http://yoursite.com/tags/cuda-hash-cudpp/"/>
    
  </entry>
  
  <entry>
    <title>2020年计划</title>
    <link href="http://yoursite.com/2020/03/14/2020-plan/"/>
    <id>http://yoursite.com/2020/03/14/2020-plan/</id>
    <published>2020-03-14T08:37:15.000Z</published>
    <updated>2020-03-14T10:01:18.150Z</updated>
    
    <content type="html"><![CDATA[<p>把2020年给安排一下,虽然已经三月中旬了,做总比不做要好;会不定期更新调整</p><h2 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h2><ul><li>考虑整理自己的工具库. 整理提炼工作中遇到的比较通用的模块,积累自己的框架和库,以期提高开发效率</li><li>阅读开源仓库代码. 工作中很多时候是输出,把自己会的知识输出到产品中去;通过阅读开源代码,给自己充电,如果合适的话争取加入到某个开源库的开发当中,以实战来提高自己</li><li>写博客. 记录工作中遇到的问题,读书笔记,也是对生活的一个记录;坚持每周写1-2篇</li><li>技术书籍与视频. </li></ul><h2 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h2><ul><li>游泳. 一直以来都挺怕水的,去年普吉岛团建,在教练带领下进行浮潜,看海下的珊瑚和鱼真漂亮,算是克服了一重心里障碍;决定今年等疫情过去之后,花1-2个月时间学会游泳,毕竟深圳的夏天那么长</li><li>看书. 包括技术类与社科类,技术用来吃饭,社科用来拓展自己;一定要提醒自己记笔记,对每本书坚持看完不中断,不记笔记没多久就全忘记了,而看到一半不看了,等下次想起来还要从头看,心累</li><li>英语. 想着以后出国玩方便点;暂定方案是上下班班车上听英文广播,有没有效果待验证</li><li>运动. 平时早上起来运动半小时,内容是热身,俯卧撑和keep上的核心训练;周末去公园跑步,幸运的话今年再跑一次半马;看有没有时间把太极拳安排上,箱子底的太极服还是去年买的,崭新</li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="关于技术栈"><a href="#关于技术栈" class="headerlink" title="关于技术栈"></a>关于技术栈</h3><ul><li>java. 工作几年没写过java代码,最近需要对软件加速,原有代码库是java写的,目前在跟着廖雪峰老师的博客学习java基础知识</li><li>并行编程. 很实用的技术,想要用好不容易</li><li>数据库. 工作中基本没怎么用过数据库,之前偶尔接触也是很旧的Access,SQL Server,今年计划学习下MySQL或Redis</li></ul><h3 id="关于爱好"><a href="#关于爱好" class="headerlink" title="关于爱好"></a>关于爱好</h3><p>坚持长跑之外,培养其他爱好,一个是摄影,一个是写字;摄影的话买个低端相机,出去旅游的时候找找灵感,练写字一个原因也是自己字太丑了,以钢笔字为主</p><h3 id="关于娱乐"><a href="#关于娱乐" class="headerlink" title="关于娱乐"></a>关于娱乐</h3><p>工作之余,也要适当放松  </p><ul><li>美剧 <ul><li>&lt;风骚律师&gt; 这是&lt;绝命毒师&gt;前传,讲律师的成长史,评分挺高,现在第五季开始更新,我从第一季开始看,美滋滋</li></ul></li><li>动漫<ul><li>&lt;鬼灭之刃&gt; 2019年黑马之作,内容是炭治郎和妹妹祢豆子的亲情羁绊和打鬼历程,已于春节假期期间看完,在b站充了大会员</li><li>&lt;灵能百分百1.2&gt; 作者成名作是&lt;一拳超人&gt;,灵能讲异能的,口碑也不错,已于假期看完</li><li>&lt;进击的巨人4&gt; 剩下的就是等2020年上映的巨人第四季了,去年一口气把1-3看完,真的不要太爽</li></ul></li><li>小说<ul><li>&lt;升邪&gt; 修仙小说,正在看</li><li>&lt;三体&gt; 科幻巨著</li><li>心理学方面 打算看下公众号推送的心理学书籍</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;把2020年给安排一下,虽然已经三月中旬了,做总比不做要好;会不定期更新调整&lt;/p&gt;
&lt;h2 id=&quot;技术&quot;&gt;&lt;a href=&quot;#技术&quot; class=&quot;headerlink&quot; title=&quot;技术&quot;&gt;&lt;/a&gt;技术&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;考虑整理自己的工具库. 整理提炼工作
      
    
    </summary>
    
    
    
      <category term="plan" scheme="http://yoursite.com/tags/plan/"/>
    
  </entry>
  
  <entry>
    <title>解决hexo博客文章太长导致的显示不全问题</title>
    <link href="http://yoursite.com/2020/03/06/resolve-long-page-display-error/"/>
    <id>http://yoursite.com/2020/03/06/resolve-long-page-display-error/</id>
    <published>2020-03-06T10:10:51.000Z</published>
    <updated>2020-03-06T10:28:27.581Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>前两天准备发布上一篇介绍<em>CLI11</em>的文章,结果写好markdown之后本地测试发现问题:</p><ul><li>文章最后内容突然缺失</li><li>导航栏,底部的返回顶部按钮均异常</li><li>查看网页源代码,发现内容消失的地方之后内容全部是空格</li></ul><p>尝试解决问题,发现文章变短显示就正常,使用hexo新建blog,测试长文显示OK,换上同样的主题也没问题,说明是我的环境配置哪里出错.</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>折腾几天,重装hexo-xx相关库,更新hexo版本,库版本,拿出错的配置和正常的去比较,终于发现问题出现在<br><em>package.json</em>的<strong>“hexo-browsersync”: “^0.3.0”,</strong> 将这一行注释掉或者删除就OK<br>然后来到这个库的github的issues,发现不少人也遇到了这个问题,可惜我是找了好久才发现<br><a href="https://github.com/hexojs/hexo-browsersync/issues/15" target="_blank" rel="noopener">https://github.com/hexojs/hexo-browsersync/issues/15</a></p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>另外总结下其他遇到的问题</p><h3 id="hexo-server报错"><a href="#hexo-server报错" class="headerlink" title="hexo server报错"></a>hexo server报错</h3><blockquote><p>Cannot GET /</p></blockquote><p>解决方案:<code>npm audit fix</code> 查看缺少哪些模块,<code>npm install xxx</code> 安装</p><h3 id="hexo-generate报错"><a href="#hexo-generate报错" class="headerlink" title="hexo generate报错"></a>hexo generate报错</h3><blockquote><p>FATAL Something’s wrong. Maybe you can find the solution here:<a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">https://hexo.io/docs/troubleshooting.html</a><br>TypeError [ERR_INVALID_URL]: Invalid URL: <code>http://host:port/data/</code>这个网络资源上。</p></blockquote><p>经测试是某篇文章出现了<code>http://host:port/data/</code>字段,在某些版本hexo库下格式不对,<br>将其当作代码引起来就可以了.</p><h3 id="检查hexo-相关库"><a href="#检查hexo-相关库" class="headerlink" title="检查hexo 相关库"></a>检查hexo 相关库</h3><ul><li>npm install -g npm-check</li><li>npm-check</li><li>npm install -g npm-upgrade</li><li>npm-upgrade</li><li>npm install hexo –save</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h2&gt;&lt;p&gt;前两天准备发布上一篇介绍&lt;em&gt;CLI11&lt;/em&gt;的文章,结果写好markdown之后本地测试发现问题:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;文章最
      
    
    </summary>
    
    
    
      <category term="blog" scheme="http://yoursite.com/tags/blog/"/>
    
  </entry>
  
  <entry>
    <title>C++命令行解析库CLI11介绍</title>
    <link href="http://yoursite.com/2020/03/04/introduce-CLI11/"/>
    <id>http://yoursite.com/2020/03/04/introduce-CLI11/</id>
    <published>2020-03-04T12:11:12.000Z</published>
    <updated>2020-03-06T10:05:10.474Z</updated>
    
    <content type="html"><![CDATA[<p>本篇文章主要提炼自github上CLI11的官方文档,取出自己感兴趣的内容,记录下来方便以后使用</p><h2 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h2><p>CLI11是一个基于C++开发的命令行解析库,目前最新版本1.9</p><p>其优点:</p><ul><li>使用很方便,只需要<code>#include &lt;CLI11.hpp&gt;</code>,当然也可以使用cmake编译版本</li><li>跨平台,支持广泛(不需要C++11以上的版本支持)</li><li>支持subcommand;支持重复options</li></ul><p>关于编译</p><blockquote><p><code>g++ -std=c++11 xx.cpp -I path_with_CLI11 -o app</code></p></blockquote><p>(path_with_CLI11是一个路径,其内有CLI11.hpp, app是编译后的可执行程序名)</p><p>运行:</p><p>需要提示信息的时候运行<code>./app -h</code></p><h3 id="一个简单的例子"><a href="#一个简单的例子" class="headerlink" title="一个简单的例子"></a>一个简单的例子</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"CLI11.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    CLI::App app&#123;<span class="string">"App description"</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Define options</span></span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">    app.add_option(<span class="string">"-p"</span>, p, <span class="string">"Parameter"</span>);</span><br><span class="line"></span><br><span class="line">    CLI11_PARSE(app, argc, argv);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Parameter value: "</span> &lt;&lt; p &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只接受一个可选参数-p</p><p>CLI::App 是与库的所有交互的基础</p><p>CLI11_PARSE 宏内部执行app.parse(argc,argv)对命令行参数解析,出错时抛出ParseError,然后捕获异常,打印错误信息并退出程序</p><h2 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h2><h3 id="位置参数"><a href="#位置参数" class="headerlink" title="位置参数"></a>位置参数</h3><p>即必须参数,使用方法是<em>add_xxx</em>方法的第一个参数如”-a” <strong>把”-“ 去掉</strong>,换成有意义的名字,如”outputDir”<br>位置参数就是没有这些参数就无法运行,没有默认值;多个位置参数按定义顺序传递</p><h3 id="flags"><a href="#flags" class="headerlink" title="flags"></a>flags</h3><p>命令行输入只填flag名字就行,不接受参数;函数为<em>add_flag</em>,有以下三种类型:</p><ul><li><p>boolean flags</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> my_flag;</span><br><span class="line">app.add_flag(<span class="string">"-f"</span>, my_flag, <span class="string">"Optional description"</span>);</span><br></pre></td></tr></table></figure><p>  绑定flag -f 到布尔变量my_flag,默认是flase,如果用户输入了-f 则为true</p></li><li><p>integer flags</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> my_flag;</span><br><span class="line">app.add_flag(<span class="string">"-f"</span>, my_flag, <span class="string">"Optional description"</span>);</span><br></pre></td></tr></table></figure><p>  同样的绑定,范围变成整数</p></li><li><p>pure flags</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CLI::Option* my_flag = app.add_flag(<span class="string">"-f"</span>, <span class="string">"Optional description"</span>);</span><br></pre></td></tr></table></figure><p>  使用my_flag-&gt;count()来确定值是true/false,默认为0则false,大于等于1次则true;也可以bool(*my_flag)来使用</p><p>  所有add_* 格式的函数都返回CLI::Option类型,因此可以<strong>链式调用</strong>,使代码更简约</p></li><li><p>其他<br>  有callback flags,add_flag_function()可以打印每个参数输入了多少次</p></li></ul><p>每个add_*方法的第一个参数,即指定的命令参数,可以有多个名字,逗号分隔即可,如”-a,–alpha,-b”;另外一个比较有用的是-&gt;ignore_case() 方法,忽略大小写,方便用户输入</p><p>多个参数可以组合如”-i -a -b”等价于”-iab”</p><h3 id="options"><a href="#options" class="headerlink" title="options"></a>options</h3><p>与flags区别就是<strong>接受参数</strong>;函数为<em>add_option</em></p><p>基本形式:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> int_option = <span class="number">0</span>;</span><br><span class="line">app.add_option(<span class="string">"-i"</span>, int_option, <span class="string">"Optional description"</span>);</span><br></pre></td></tr></table></figure><p>其行为:绑定选项-i到int_option,解析其后的数据转换为整型,类型不对会失败;如果没有此选项则使用初始值</p><p>可接受类型包括:整型/浮点/字符串/vector/函数</p><h3 id="vectors-of-options"><a href="#vectors-of-options" class="headerlink" title="vectors of options"></a>vectors of options</h3><p>接受多个值,直到下一个值不合法;也可以用-&gt;expected(N)指定需要几个值</p><p>如果出现重复option,会进行组合,即”-v 1 2 -v 3 4”等同于”-v 1 2 3 4”(新版本才支持此功能)</p><h3 id="修改option属性"><a href="#修改option属性" class="headerlink" title="修改option属性"></a>修改option属性</h3><p>链式使用,当作装饰器,可以同时添加多个装饰</p><p>列举几个可能会常用到的:</p><ul><li>-&gt;required() 必须指定</li><li>-&gt;expected(N) 参数个数</li><li>-&gt;check(type)<ul><li>CLI::ExistingFile 检查文件是否存在</li><li>CLI::ExistingDirectory 目录是否存在</li><li>CLI::NonexistentPath 需要目录不存在</li><li>CLI::Range(min,max) 指定范围</li></ul></li></ul><h3 id="特殊选项"><a href="#特殊选项" class="headerlink" title="特殊选项:"></a>特殊选项:</h3><ul><li><em>sets</em><br>  使用集合来限定输入范围;如果输入不在集合范围内,会打印提示信息  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> val;</span><br><span class="line">app.add_set(<span class="string">"--even"</span>, val, &#123;<span class="number">0</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>&#125;);</span><br></pre></td></tr></table></figure></li><li><em>complex number</em> 复数,可接受1-2个参数,不给默认是0  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">complex</span>&lt;<span class="keyword">float</span>&gt; val;</span><br><span class="line">app.add_complex(<span class="string">"--cplx"</span>, val);</span><br></pre></td></tr></table></figure></li><li><em>optional</em> 可选参数</li><li><em>windows风格</em> /a /f …</li></ul><h3 id="Validators-验证器"><a href="#Validators-验证器" class="headerlink" title="Validators 验证器"></a>Validators 验证器</h3><p>验证器有两种形式</p><ul><li>transform 变异? 接受string,返回修改过的string</li><li>check 非变异? <ul><li>接受const string,返回修改过的string</li><li>struct CLI::Validator的子类<br>常用check来检查路径/文件是否存在,以及输入是否在一个range内</li></ul></li></ul><h2 id="subcommand-子命令"><a href="#subcommand-子命令" class="headerlink" title="subcommand 子命令"></a>subcommand 子命令</h2><p>子命令就是包含了一系列选项的一个关键字,如git commit/clone 这里面的commit clone后面还可以跟各种选项,他们就是git程序的子命令</p><p>子命令的类类型和App相同,因此可以任意嵌套</p><p>关于App的功能</p><ul><li>使用它来创建options</li><li>设置页脚,在-h下面展示,比如显示下个性签名 app.footer(“xx”)</li><li>设置帮助信息</li></ul><h3 id="添加子命令"><a href="#添加子命令" class="headerlink" title="添加子命令"></a>添加子命令</h3><p><code>CLI::App* sub = app.add_subcommand(&quot;sub&quot;, &quot;This is a subcommand&quot;);</code></p><p>第一个参数就是子命令的名字,第二个参数是描述</p><h3 id="检查子命令是否被使用"><a href="#检查子命令是否被使用" class="headerlink" title="检查子命令是否被使用"></a>检查子命令是否被使用</h3><ul><li>if(*sub) …</li><li>if(sub-&gt;parsed()) …</li><li>if(app.got_subcommand(sub)) …</li><li>if(app.got_subcommand(“sub”)) …</li></ul><p>设置必须的子命令个数,只传一个参数则限定了个数<br>app.require_subcommand(/* min <em>/ 0, /</em> max */ 1);</p><h3 id="特殊模式"><a href="#特殊模式" class="headerlink" title="特殊模式"></a>特殊模式</h3><ul><li>allow_extras() 允许出现多余的option而不报错,多余的值保存到.remaining()</li><li>fallthrough 将subcommand未匹配的option转给parnet command解析(默认不会fallthrough)</li><li>prefix command 遇到未知option时停止解析,即使其他未知选项可以匹配,也将被忽略</li></ul><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>编写个实例,把subcommand flag 各种option,check等常用功能都演示一遍</p><p>代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//把CLI11.hpp放到当前目录下</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"CLI11.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    CLI::App app&#123;<span class="string">"App description"</span>&#125;; <span class="comment">// 软件描述出现在第一行打印</span></span><br><span class="line">    app.footer(<span class="string">"My footer"</span>); <span class="comment">// 最后一行打印</span></span><br><span class="line">    app.get_formatter()-&gt;column_width(<span class="number">40</span>); <span class="comment">// 列的宽度</span></span><br><span class="line">    app.require_subcommand(<span class="number">1</span>); <span class="comment">// 表示运行命令需要且仅需要一个子命令</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> sub1 = app.add_subcommand(<span class="string">"sub1"</span>, <span class="string">"subcommand1"</span>);</span><br><span class="line">    <span class="keyword">auto</span> sub2 = app.add_subcommand(<span class="string">"sub2"</span>, <span class="string">"subcommand1"</span>);</span><br><span class="line">    sub1-&gt;fallthrough(); <span class="comment">// 当出现的参数子命令解析不了时,返回上一级尝试解析</span></span><br><span class="line">    sub2-&gt;fallthrough();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义需要用到的参数</span></span><br><span class="line">    <span class="built_in">string</span> filename;</span><br><span class="line">    <span class="keyword">int</span> threads = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> mode = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; barcodes;</span><br><span class="line">    <span class="keyword">bool</span> reverse = <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">string</span> outPath;</span><br><span class="line">    <span class="keyword">if</span> (sub1)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 第一个参数不加-, 表示位置参数,位置参数按出现的顺序来解析</span></span><br><span class="line">        <span class="comment">// 这里还检查了文件是否存在,已经是必须参数</span></span><br><span class="line">        sub1-&gt;add_option(<span class="string">"file"</span>, filename, <span class="string">"Position paramter"</span>)-&gt;check(CLI::ExistingFile)-&gt;required();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查参数必须大于0</span></span><br><span class="line">        sub1-&gt;add_option(<span class="string">"-n,-N"</span>, threads, <span class="string">"Set thread number"</span>)-&gt;check(CLI::PositiveNumber);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sub2)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 设置范围</span></span><br><span class="line">        sub2-&gt;add_option(<span class="string">"-e,-E"</span>, mode, <span class="string">"Set mode"</span>)-&gt;check(CLI::Range(<span class="number">0</span>,<span class="number">3</span>));</span><br><span class="line">        <span class="comment">// 将数据放到vector中,并限制可接受的长度</span></span><br><span class="line">        sub2-&gt;add_option(<span class="string">"-b"</span>, barcodes, <span class="string">"Barcodes info:start,len,mismatch"</span>)-&gt;expected(<span class="number">3</span>,<span class="number">6</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 添加flag,有就是true</span></span><br><span class="line">    app.add_flag(<span class="string">"-r,-R"</span>, reverse, <span class="string">"Apply reverse"</span>);</span><br><span class="line">    <span class="comment">// 检查目录是否存在</span></span><br><span class="line">    app.add_option(<span class="string">"-o"</span>, outPath, <span class="string">"Output path"</span>)-&gt;check(CLI::ExistingDirectory);</span><br><span class="line"></span><br><span class="line">    CLI11_PARSE(app, argc, argv);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断哪个子命令被使用</span></span><br><span class="line">    <span class="keyword">if</span> (sub1-&gt;parsed())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Got sub1"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"filename:"</span>&lt;&lt;filename&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"threads:"</span>&lt;&lt;threads&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (sub2-&gt;parsed())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Got sub2"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"mode:"</span>&lt;&lt;mode&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"barcodes:"</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; b : barcodes)</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;b&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>&lt;&lt;<span class="string">"Comman paras"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"reverse:"</span>&lt;&lt;reverse&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"outPath:"</span>&lt;&lt;outPath&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译:<br><code>g++ -std=c++11  run.cpp -o myapp</code></p><p>用的gcc4.8</p><p>运行:</p><p>-h 查看提示</p><p><img src="/images/introduce_CLI11/prompt2.png" alt=""></p><p><img src="/images/introduce_CLI11/prompt1.png" alt=""></p><p><img src="/images/introduce_CLI11/prompt3.png" alt=""></p><p>给正确的参数</p><p><img src="/images/introduce_CLI11/right1.png" alt=""></p><p><img src="/images/introduce_CLI11/right2.png" alt=""></p><p>给错误参数</p><p><img src="/images/introduce_CLI11/error3.png" alt=""></p><p><img src="/images/introduce_CLI11/error4.png" alt=""></p><p><img src="/images/introduce_CLI11/error1.png" alt=""></p><p><img src="/images/introduce_CLI11/error2.png" alt=""></p><p><img src="/images/introduce_CLI11/error5.png" alt=""></p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>允许读写配置文件</p><h3 id="格式化帮助信息"><a href="#格式化帮助信息" class="headerlink" title="格式化帮助信息"></a>格式化帮助信息</h3><p>允许定制自己的帮助打印信息<br>app.get_formatter() 获取当前格式</p><ul><li>column_width(width) 设置列的宽度</li><li>lable(key, value) 将lable设置一个不同的值</li><li>例子  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">app.get_formatter()-&gt;column_width(<span class="number">40</span>);</span><br><span class="line">app.get_formatter()-&gt;label(<span class="string">"REQUIRED"</span>, <span class="string">"(MUST HAVE)"</span>);</span><br></pre></td></tr></table></figure></li></ul><h3 id="subclassing"><a href="#subclassing" class="headerlink" title="subclassing"></a>subclassing</h3><p>部分的替换格式</p><h2 id="高级主题"><a href="#高级主题" class="headerlink" title="高级主题"></a>高级主题</h2><h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><p>作用是,如果命令行参数没有给定,则从环境变量中获取,如果存在的话</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> opt;</span><br><span class="line">app.add_option(<span class="string">"--my_option"</span>, opt)-&gt;envname(<span class="string">"MY_OPTION"</span>);</span><br></pre></td></tr></table></figure><h3 id="option之间的依赖-互斥关系"><a href="#option之间的依赖-互斥关系" class="headerlink" title="option之间的依赖/互斥关系"></a>option之间的依赖/互斥关系</h3><p>a-&gt;nees(b) a依赖b</p><p>a-&gt;excludes(c) a与c不共存</p><h3 id="自定义"><a href="#自定义" class="headerlink" title="自定义"></a>自定义</h3><p>custom option callbacks</p><p>custom converters</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本篇文章主要提炼自github上CLI11的官方文档,取出自己感兴趣的内容,记录下来方便以后使用&lt;/p&gt;
&lt;h2 id=&quot;简单介绍&quot;&gt;&lt;a href=&quot;#简单介绍&quot; class=&quot;headerlink&quot; title=&quot;简单介绍&quot;&gt;&lt;/a&gt;简单介绍&lt;/h2&gt;&lt;p&gt;CLI11是
      
    
    </summary>
    
    
    
      <category term="C++ CLI11 命令行解析" scheme="http://yoursite.com/tags/C-CLI11-%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>CUDA C/C++总结</title>
    <link href="http://yoursite.com/2020/03/01/CUDA-C-CPP/"/>
    <id>http://yoursite.com/2020/03/01/CUDA-C-CPP/</id>
    <published>2020-03-01T13:51:37.000Z</published>
    <updated>2020-03-05T13:31:41.823Z</updated>
    
    <content type="html"><![CDATA[<p>本篇为学习笔记,学习内容为2019年参加英伟达GTC会议的课程</p><p>需要提下学习CUDA的目的,就是为了加速自己的应用,相比于CPU-only的应用程序,可以用GPU实现较大加速,当然程序首先是计算密集型而非IO密集型</p><h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><p>GPU加速系统,又被称<strong>异构系统</strong>(Heterogeneous),由CPU和GPU组成</p><p>如果熟悉C编程,可以很快上手CUDA编程,两者在代码形式上有很多类似地方,一个比较重要概念是GPU的<em>launch kernel</em></p><p>C代码用gcc编译,cuda代码用<em>nvcc</em>编译,nvcc内部会调用gcc</p><p>启动核函数的配置 &lt;&lt;&lt;blocks,threads&gt;&gt;&gt; thread是最小执行单位,由threads组成block,多个block组成grid;kernel只能运行在一个grid</p><p>一般最简单的加速示例就是一个CPU的循环,执行简单的算术运算;主要是暗示我们什么类型的程序适合GPU加速</p><p>关于threads:</p><ul><li>每个block中的threads个数上限是1024</li><li>一个block中的threads个数由内置变量<em>blockDim.x<em>给出,多个block中计算thread索引公式为:</em>threadIdx.x + blockIdx.x * blockDim.x</em></li><li>grid中block的个数<em>gridDim.x</em>,因此一个grid的线程总数就是<em>gridDim.x * blockDim.x</em></li><li>一般一个thread一次处理一个数据</li><li>注意数据与threads个数很多时候都不是一一对应的,所以要特别注意索引越界问题;一般方式是将数组长度N传入kernel,算出thread索引,与N比较</li><li>block中的threads个数为32的倍数时最优化</li><li>当多个block的threads总数依然无法覆盖待处理数据长度时,在kernel中用loop来重复利用threads处理后续数据;如数据有2048个,线程总数只有1024,则每一个线程处理两个数据</li></ul><p>cuda6之后的版本可以分配出CPU/GPU都能访问的内存,API接口为:<em>cudaMallocManaged</em></p><p>关于异常处理:</p><ul><li>一些cuda函数的返回值类型为cudaError_t, 可用来检查错误<em>cudaGetErrorString(err)</em></li><li>无返回值的kernel, 使用<em>cudaGetLastError()</em> 返回cudaError_t类型</li><li>另外,如果有一组kernel出错,因为kernel执行是异步的,为了排查错误,可以调用同步函数如cudaDeviceSynchronize() 会返回kernel执行的错误</li><li>自己封装一个宏来进行错误检查是有必要的</li></ul><h1 id="统一内存管理"><a href="#统一内存管理" class="headerlink" title="统一内存管理"></a>统一内存管理</h1><p>迭代设计过程:</p><p>APOD:Assess Parallelize Optimize Deploy</p><p>评估-&gt;并行-&gt;优化-&gt;部署</p><p>使用Nsight命令行工具<strong>nsys</strong>来评估性能,确定优化机会</p><p>nsys基本用法: nsys profile –stats=true exe</p><p>它会生成qdrep报告,包含诸多信息:API统计,kernel执行统计,内存拷贝的大小和时间等</p><p>程序优化方法之一:更改kernel launch的<strong>配置参数</strong></p><p>Streaming Multiprocessor 流处理单元SM</p><ul><li>一个block中的threads被调度到SM上执行;多个block可以被调度到同一个SM上</li><li>为了尽可能并行,提高性能:将grid size设置为给定GPU上的SM个数的倍数,防止不对齐导致的资源浪费</li><li>SMs创建,管理,调度和执行的单位是一个block中的一组32个threads,叫做wraps;由有half-wrap的概念,16个线程为一组,更细粒度的并行</li></ul><p>为了获取SM的数量,调用API:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> deviceId;</span><br><span class="line">cudaGetDevice(&amp;deviceId);</span><br><span class="line">cudaDeviceProp props;</span><br><span class="line">cudaGetDeviceProperties(&amp;props, deviceId);</span><br><span class="line">SMs = props.multiProcessorCount;</span><br></pre></td></tr></table></figure><p>基础知识:CUDA’s Unified Memory</p><ul><li>关于Unified Memory,当UM分配之后,不管host还是device都无法访问,访问时会发生page fault,然后触发内存的迁移,将需要的数据按batches迁移</li><li>使用UM要注意避免不必要的时间开销,比如需要大的连续内存块,避免页错误</li></ul><p>Asynchronous Memory Prefetching<br>异步内存预取:减小页错误和按需内存迁移的间接开销的技术,提高性能</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cudaMemPrefetchAsync(pointerToSomeUMData, <span class="built_in">size</span>, deviceId);        <span class="comment">// Prefetch to GPU device.</span></span><br><span class="line">cudaMemPrefetchAsync(pointerToSomeUMData, <span class="built_in">size</span>, cudaCpuDeviceId); <span class="comment">// Prefetch to host. `cudaCpuDeviceId`</span></span><br></pre></td></tr></table></figure><h1 id="流异步和性能分析"><a href="#流异步和性能分析" class="headerlink" title="流异步和性能分析"></a>流异步和性能分析</h1><p>Nsight Systems 可视化的性能分析工具,其可以直接打开nsys生成的qdrep文件</p><p>Concurrent CUDA Streams 并发流;流是一系列顺序执行的命令,kernel的执行,和许多内存迁移都是发生在流内,不指定的情况下使用default stream</p><p>关于控制流的几个规则:</p><ul><li>流内的操作是顺序的</li><li>不同流内的操作相互之间不保证有任何顺序,即可认为不相关</li><li>默认流执行前会阻塞直到其他所有流都执行完成,反之亦然,默认流执行的时候其他流也被阻塞</li></ul><p>API:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cudaStream_t stream;       <span class="comment">// CUDA streams are of type `cudaStream_t`.</span></span><br><span class="line">cudaStreamCreate(&amp;stream); <span class="comment">// Note that a pointer must be passed to `cudaCreateStream`.</span></span><br><span class="line"></span><br><span class="line">someKernel&lt;&lt;&lt;number_of_blocks, threads_per_block, <span class="number">0</span>, stream&gt;&gt;&gt;(); <span class="comment">// `stream` is passed as 4th EC argument.</span></span><br><span class="line"></span><br><span class="line">cudaStreamDestroy(stream); <span class="comment">// Note that a value, not a pointer, is passed to `cudaDestroyStream`.</span></span><br></pre></td></tr></table></figure><p>第三个参数是每个block允许使用的shared memory的bytes,默认为0</p><p>profile driven and iterative 配置文件驱动和迭代</p><p>当确定数据只在device使用,最好只分配device的内存,减小数据迁移的开销,API:</p><ul><li>cudaMalloc()  only GPU</li><li>cudaMallocHost() only CPU 锁页内存,允许异步拷贝到GPU;过多的锁页内存会影响CPU性能,使用 cudaFreeHost()来释放</li><li>cudaMemcpy() device与host相互拷贝</li></ul><p>Using Streams to Overlap data transfers and code execution</p><p>只要CPU内存是锁页内存,就可以使用cudaMemcpyAsync()来进行异步拷贝,另一个条件就是使用非默认流</p><p>默认情况下GPU函数执行时对CPU函数是异步的,而异步拷贝,不仅对CPU,对GPU的kernel也是异步的,可以达到边计算边拷贝数据的目的,从而掩盖数据传输时间,尽量挖掘GPU计算能力</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本篇为学习笔记,学习内容为2019年参加英伟达GTC会议的课程&lt;/p&gt;
&lt;p&gt;需要提下学习CUDA的目的,就是为了加速自己的应用,相比于CPU-only的应用程序,可以用GPU实现较大加速,当然程序首先是计算密集型而非IO密集型&lt;/p&gt;
&lt;h1 id=&quot;基础&quot;&gt;&lt;a hre
      
    
    </summary>
    
    
    
      <category term="CUDA C" scheme="http://yoursite.com/tags/CUDA-C/"/>
    
  </entry>
  
  <entry>
    <title>windows远程桌面连接报错</title>
    <link href="http://yoursite.com/2020/03/01/windows%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2%E8%BF%9E%E6%8E%A5%E6%8A%A5%E9%94%99/"/>
    <id>http://yoursite.com/2020/03/01/windows%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2%E8%BF%9E%E6%8E%A5%E6%8A%A5%E9%94%99/</id>
    <published>2020-03-01T12:59:33.000Z</published>
    <updated>2020-03-05T13:31:41.830Z</updated>
    
    <content type="html"><![CDATA[<p>这周遇到windows远程桌面连接报错:</p><blockquote><p>出现内部错误</p></blockquote><p>个人PC与服务器处于一个局域网内,别人可以连接,只有我的不行</p><p>解决方案:经人指点,找到那台服务器,插上显示器,登录自己账号密码没问题,然后回来再使用个人PC远程连接就OK了,直接服务器登录一次就像账号激活一样</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这周遇到windows远程桌面连接报错:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;出现内部错误&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;个人PC与服务器处于一个局域网内,别人可以连接,只有我的不行&lt;/p&gt;
&lt;p&gt;解决方案:经人指点,找到那台服务器,插上显示器,登录自己账号
      
    
    </summary>
    
    
    
      <category term="windows" scheme="http://yoursite.com/tags/windows/"/>
    
  </entry>
  
  <entry>
    <title>begin_centos7</title>
    <link href="http://yoursite.com/2019/03/17/begin-centos7/"/>
    <id>http://yoursite.com/2019/03/17/begin-centos7/</id>
    <published>2019-03-17T13:46:35.000Z</published>
    <updated>2020-03-05T13:31:41.827Z</updated>
    
    <content type="html"><![CDATA[<p>本篇主要记录个人电脑安装centos及其软件过程， 以备下次需要重装系统之用。</p><h2 id="安装系统"><a href="#安装系统" class="headerlink" title="安装系统"></a>安装系统</h2><h3 id="1-下载系统安装包"><a href="#1-下载系统安装包" class="headerlink" title="1. 下载系统安装包"></a>1. 下载系统安装包</h3><p>在centos官网下载<a href="https://www.centos.org/download/" target="_blank" rel="noopener">安装包</a>, 目前最新版本是7.6， 我下载的everything版本， 约10G， 包括最全的内容， 虽然最后只装了个GUI版本。</p><h3 id="2-刻盘"><a href="#2-刻盘" class="headerlink" title="2. 刻盘"></a>2. 刻盘</h3><p>使用u盘安装的方式， 首先下载<a href="https://cn.ultraiso.net/xiazai.html" target="_blank" rel="noopener">ultroiso</a>, 可以选择免费试用版， 然后在windows系统电脑插入u盘， 打开ultroiso，加载步骤1下载的iso文件， 选择刻录到u盘启动，等待10多分钟， 启动u盘刻录完毕</p><h3 id="3-安装"><a href="#3-安装" class="headerlink" title="3. 安装"></a>3. 安装</h3><ul><li><p>插入u盘， 重启电脑， 开机过程中按<strong>F2</strong>进入<strong>BIOS</strong>， 设置启动顺序为u盘优先， 保存配置并退出</p></li><li><p>在<strong>Install Centos 7</strong>这一行按<strong>e</strong> 进入编辑模式， 将脚本中对应内容修改为</p><blockquote><p>initrd=initrd.img linux dd quiet</p></blockquote><p>  回车， 屏幕会打印设备信息， 从中可以找到u盘所对应的id， 如： <em>/sdc4</em>， 这一步是查找u盘的映射id， 因为脚本中默认的名称是错误的。</p><p>  重启之后， 继续进入编辑模式， 修改内容为</p><blockquote><p>initrd=initrd.img inst.stage2=hd:/dev/sdc4 nomodeset quiet</p></blockquote><p>  其中加入了一句 <em>nomodeset</em>, 原因是不加的话无法进入图形界面（安装过程）， 报错为 “<em>X startup failed, falling back to text mode</em>“</p></li><li><p>至此，可以通过图形界面一路点点点进行安装，我安装的是GUI版本，语言设置为英语，时区选上海</p></li></ul><h2 id="基本环境配置"><a href="#基本环境配置" class="headerlink" title="基本环境配置"></a>基本环境配置</h2><h3 id="1-语言"><a href="#1-语言" class="headerlink" title="1. 语言"></a>1. 语言</h3><p>通过快捷键切换中英文，虽然安装环境选的是英文，但是语言栏可以添加中文，很不错</p><h3 id="2-无线上网"><a href="#2-无线上网" class="headerlink" title="2. 无线上网"></a>2. 无线上网</h3><p>有线可以忽略；无线需要购买对应的无线网卡， 支持linux，最好买不用驱动安装的，插入即可使用，要不然就会知道<strong>.ko</strong>文件如何生成和使用（linux驱动文件）</p><h3 id="3-下载软件"><a href="#3-下载软件" class="headerlink" title="3. 下载软件"></a>3. 下载软件</h3><p>推荐<strong>qBittorrent</strong>, 优点是跨平台，且可以通过centos系统自带的应用程序安装器进行安装，虽然我下载速度慢的和乌龟一样</p><h3 id="4-视频播放软件"><a href="#4-视频播放软件" class="headerlink" title="4. 视频播放软件"></a>4. 视频播放软件</h3><p>自带的<strong>Videos</strong>没有解码器，无法播放视频；推荐<strong>Mplayer</strong>，代码编译，相当酸爽</p><ul><li>下载代码 <code>$ svn checkout svn://svn.mplayerhq.hu/mplayer/trunk mplayer</code> (貌似当时无法下载，找了官网换了链接OK)</li><li>更新代码 <code>$ svn update</code></li><li>依赖包<ul><li>下载 <code>$ wget http://www.mplayerhq.hu/MPlayer/releases/codecs/essential-amd64-20071007.tar.bz2</code></li><li>解压 <code>$ tar -xaf essential-amd64-20071007.tar.bz2</code></li><li>建目录 <code>$ sudo mkdir /usr/local/lib/codecs</code></li><li>拷贝 <code>$ sudo cp essential-amd64-20071007/* /usr/local/lib/codecs</code></li></ul></li><li>生成Mplayer编译所需配置 <code>$ ./configure --enable-gui --language=zh_CN</code><ul><li>依赖<a href="http://pkgs.org/download/yasm" target="_blank" rel="noopener">yasm-1.2.0-4.sdl7.x86_64.rpm</a></li><li><code>$ yum install gtk2*</code></li><li>报错就对应修改</li></ul></li><li>编译 <code>$ make</code></li><li>安装 <code>$ make install</code></li><li>安装皮肤，才能用GUI<ul><li>下载 <code>$ wget http://www.mplayerhq.hu/MPlayer/skins/Blue-1.10.tar.bz2</code></li><li>解压 <code>$ tar -xaf Blue-1.10.tar.bz2</code></li><li>复制 <code>$ sudo cp -R Blue /usr/local/share/mplayer/skins/</code></li><li>软链接 <code>$ cd /usr/local/share/mplayer/skins/</code> <code>$ sudo ln -s Blue/ default</code></li></ul></li><li>没有声音的解决方案:重新<strong>./configure</strong> 这次加上参数<em>–codecsdir=/usr/local/lib/codecs</em></li></ul><h3 id="5-markdown编辑器"><a href="#5-markdown编辑器" class="headerlink" title="5. markdown编辑器"></a>5. markdown编辑器</h3><p>推荐使用<strong>Atom</strong>，下载rpm包直接安装即可，功能强大，目前使用其来进行markdown文件的编辑，用于写博客；还可以进行代码编写等</p><h3 id="6-浏览器"><a href="#6-浏览器" class="headerlink" title="6. 浏览器"></a>6. 浏览器</h3><p>浏览器是上网的窗口，自带的firefox就很好用，不过我还是选择使用时间更久的<strong>Chrome</strong>；下载插件<strong>vimium</strong> 进行无鼠标的网页浏览操作</p><h3 id="7-配置终端"><a href="#7-配置终端" class="headerlink" title="7. 配置终端"></a>7. 配置终端</h3><p>怎么可以不用命令行？终端配置目前主要是<strong>bashrc vimrc</strong>， 另外还有键盘的重新映射，即改键，我主要是把<em>esc</em>和<em>caps</em>互换，毕竟<em>esc</em>使用频率太高了，而它离手指又太远了。<br>参考<a href="http://tigeroses.com/2016/10/21/%E6%8A%80%E5%B7%A7%E4%B8%8E%E5%B7%A5%E5%85%B701-Linux%E5%B7%A5%E4%BD%9C%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/" target="_blank" rel="noopener">技巧与工具01:Linux工作环境配置</a></p><h3 id="8-办公套件"><a href="#8-办公套件" class="headerlink" title="8. 办公套件"></a>8. 办公套件</h3><p>直接在系统自带的应用安装器中进行安装，名称为<strong>LibreOffice</strong>, 安装三个， 分别是</p><ul><li>Calc == excel</li><li>Impress == powerpoint</li><li>Writer == word</li></ul><h3 id="9-分辨率"><a href="#9-分辨率" class="headerlink" title="9. 分辨率"></a>9. 分辨率</h3><p>刚装完系统时分辨率很低，还无法设置；我的显卡是Nvidia GTX 750，在官网下载对应驱动安装之后分辨率恢复正常</p><h3 id="10-关闭主机usb供电"><a href="#10-关闭主机usb供电" class="headerlink" title="10. 关闭主机usb供电"></a>10. 关闭主机usb供电</h3><p>BIOS中Power Management 下的ErP设置为Enabled即可，主要是有时候主机关闭之后鼠标灯还亮着，强迫症真难受，关闭usb供电可以解决这个问题</p><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p>参考网上经验</p><ul><li><a href="https://www.cnblogs.com/pythonal/p/6825906.html" target="_blank" rel="noopener">U盘安装CentOS7的最终解决方案</a></li><li><a href="http://tieba.baidu.com/p/3199364641" target="_blank" rel="noopener">【14-07-31】 【总结】如何在CentOS 7上编译图形界面的Mplayer</a></li><li><a href="https://blog.csdn.net/sidely/article/details/44671257" target="_blank" rel="noopener">Centos7安装Mplayer播放器有图像没声音的解决办法</a></li><li><a href="https://zhidao.baidu.com/question/808793269006098012.html" target="_blank" rel="noopener">技嘉B85-HD3主板如何关闭关机usb供电</a></li><li><a href="https://www.cnblogs.com/libin-1/p/6638165.html" target="_blank" rel="noopener">使用Atom打造无懈可击的Markdown编辑器</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本篇主要记录个人电脑安装centos及其软件过程， 以备下次需要重装系统之用。&lt;/p&gt;
&lt;h2 id=&quot;安装系统&quot;&gt;&lt;a href=&quot;#安装系统&quot; class=&quot;headerlink&quot; title=&quot;安装系统&quot;&gt;&lt;/a&gt;安装系统&lt;/h2&gt;&lt;h3 id=&quot;1-下载系统安装包&quot;
      
    
    </summary>
    
    
    
      <category term="centos" scheme="http://yoursite.com/tags/centos/"/>
    
  </entry>
  
  <entry>
    <title>读《期货市场技术分析》下</title>
    <link href="http://yoursite.com/2018/03/05/%E8%AF%BB%E6%9C%9F%E8%B4%A7%E5%B8%82%E5%9C%BA%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90%E4%B8%8B/"/>
    <id>http://yoursite.com/2018/03/05/%E8%AF%BB%E6%9C%9F%E8%B4%A7%E5%B8%82%E5%9C%BA%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90%E4%B8%8B/</id>
    <published>2018-03-05T14:34:51.000Z</published>
    <updated>2020-03-05T13:31:41.831Z</updated>
    
    <content type="html"><![CDATA[<h2 id="交易量和持仓兴趣"><a href="#交易量和持仓兴趣" class="headerlink" title="交易量和持仓兴趣"></a>交易量和持仓兴趣</h2><p><strong>交易量</strong>：在我们所研究的基本时间单位内成交的合约总额</p><p><strong>持仓兴趣</strong>：到某日收市为止，所有未平仓了结的合约的总数</p><p>这两个是判断趋势的次要指标；但是也相当重要，比如价格的变化是需要交易量来支撑的</p><h2 id="移动平均线和摆动指数"><a href="#移动平均线和摆动指数" class="headerlink" title="移动平均线和摆动指数"></a>移动平均线和摆动指数</h2><p>将固定最近n天的平均价格数据画线，就是<strong>n日移动平均线</strong>；它是具有滞后特点的平滑工具</p><p>平均的计算方式除了基本的算术平均，还有线性加权和指数加权</p><p>期货分析者最常采用的是一条简单移动平均线；通常，价格处于横向延伸区间中时，短期移动平均线效果最佳，一旦趋势形成，长期移动平均线更为有力</p><p><strong>采用两条移动平均线</strong>：较长期者用来识别趋势，较短期者用来选择时机；<strong>两线相交法</strong>：当短期平均线向上穿越长期平均线，构成买入信号，向下穿越，构成卖出信号；<strong>中性区间法</strong>：当价格同时向上穿越两条平均线，才构成买入信号</p><p>最佳实践：根据市场的具体情况，通过优化过程，选出它的双简单移动平均线的最佳组合</p><p>移动平均线虽好，但它更适用于趋势良好的时期，不能过分依赖；在其他场合，采用非趋势顺应系统，如超买－超卖摆动指数，更合适</p><p><strong>摆动指数的用途</strong>：</p><ol><li>当摆动指数的值达到上边界或下边界的极限值时，最有意义；上边界为“超买状态”，这时候要卖出，下边界为“超卖状态”，可以买入</li><li>当摆动指数处于极限位置，并且摆动指数与价格变化之间出现了相互背离现象时，通常构成重要的预警信号</li><li>如果摆动指数顺着市场趋势的方向穿越零线，可能是重要的买卖信号</li></ol><p><strong>动力指数</strong>：价格变化的速度；按照一定的时间间隔，连续地采集价格变化的数值</p><h2 id="艾略特波浪理论"><a href="#艾略特波浪理论" class="headerlink" title="艾略特波浪理论"></a>艾略特波浪理论</h2><p>波浪理论有三个重要的方面：<strong>形态，比例和时间</strong>。重要性依次降低；形态是指波浪的形态或构造，比例分析是通过测算各个波浪之间的相互关系，来确定回撤点和价格目标，时间用来验证波浪形态和比例</p><p>归纳总结：</p><ol><li>完整的牛市周期由8浪构成，先五浪上涨，再三浪下跌</li><li>如果当前趋势与比他更高一层次的趋势方向一致，则划分为五浪结构</li><li>调整浪始终以三浪结构出现</li><li>有两种简单的调整形态：锯齿形（5-3-5）和平台型（3-3-5）</li><li>三角形通常出现在第4浪，并且总是发生在最后一浪之前；也可以出现在调整浪b浪中</li><li>既可以把波浪组合成更长的波浪，也可以把波浪细分成更短的波浪</li><li>有时某一主浪会延长，那么，另两个主浪则在时间和幅度两方面相当</li><li>斐波那契数列是艾略特波浪理论的数学基础</li><li>波浪的浪数序列服从斐波那契数列</li><li>斐波那契比数和回撤可以用来确定价格目标，最常用的回撤比例是68% 50% 38%</li><li>交替规则警示我们，不要指望同一类形态连续地出现</li><li>熊市不应当跌破前一轮牛市的第四浪的底部</li><li>4浪不可与1浪有重叠</li></ol><h2 id="自动交易系统"><a href="#自动交易系统" class="headerlink" title="自动交易系统"></a>自动交易系统</h2><p>如果用户已经掌握了技术分析的基础概念，那么使用计算机会使他如虎添翼</p><p><strong>长处</strong>：</p><ol><li>排除了人类主观情绪的影响</li><li>具有更严格的自律</li><li>能达到更高程度的协调一致性</li><li>顺着趋势方向交易</li><li>确保不错过每个顺着重要趋势的方向入市的机会</li><li>允许利润充分增长</li><li>把损失限制在一定范围</li></ol><p><strong>短处</strong>：</p><ol><li>绝大多数自动交易系统是顺应趋势的</li><li>从获利角度看，趋势顺应系统主要依赖于主要趋势</li><li>当市场无趋势可循时，趋势顺应系统一般是不盈利的</li><li>市场在相当长时间内没有趋势，而在这种阶段不适合采用趋势型方法</li></ol><h2 id="资金管理和交易策略"><a href="#资金管理和交易策略" class="headerlink" title="资金管理和交易策略"></a>资金管理和交易策略</h2><p>在任何成功的期货交易模式中，都必须考虑三方面的因素：价格预测，时机抉择和资金管理</p><p><strong>价格预测</strong>指我们所预期的未来市场的趋势方向（怎么做）</p><p><strong>交易策略</strong>确定具体的出入市时机（何时做）</p><p><strong>资金管理</strong>指资金的配置问题（多少钱做）</p><p>普遍性的资金管理要领：</p><ol><li>总投资额必须限制在全部资金的50%以内，剩下一半是储备</li><li>在任何单个市场上所投入的总资金必须限制在总资本的10%到15%以内，用来分散风险</li><li>任何单个市场上的最大总亏损金额必须限制在总资本的5%以内，即设置止损</li><li>在任何一个市场类群上所投入的保证金总额必须限制在总资本的20%－25%以内，因为同一类群的市场往往步调一致</li></ol><p>利用技术分析抉择时机：</p><ol><li>关于突破信号的策略</li><li>趋势线的突破</li><li>支撑和阻挡水平的利用</li><li>百分比回撤的利用</li><li>价格跳空的利用</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;交易量和持仓兴趣&quot;&gt;&lt;a href=&quot;#交易量和持仓兴趣&quot; class=&quot;headerlink&quot; title=&quot;交易量和持仓兴趣&quot;&gt;&lt;/a&gt;交易量和持仓兴趣&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;交易量&lt;/strong&gt;：在我们所研究的基本时间单位内成交的合约总额&lt;/p&gt;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>读《期货市场技术分析》</title>
    <link href="http://yoursite.com/2018/03/05/%E8%AF%BB%E6%9C%9F%E8%B4%A7%E5%B8%82%E5%9C%BA%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2018/03/05/%E8%AF%BB%E6%9C%9F%E8%B4%A7%E5%B8%82%E5%9C%BA%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/</id>
    <published>2018-03-05T14:23:24.000Z</published>
    <updated>2020-03-05T13:31:41.831Z</updated>
    
    <content type="html"><![CDATA[<h2 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h2><p>本书是期货分析的一本很好的入门书，读此书是为了了解交易及期货技术分析的一些名词概念</p><p>主要读的章节部分有图表和趋势分析，趋势分析的主要部分是价格形态，有反转型和持续型，交易量和持仓兴趣作为次要指标为趋势的佐证；常用工具有移动平均线和摆动指数，分别适用于趋势明朗和无趋势区间；艾略特波浪曲线是成熟的模型来分析趋势；最后是根据趋势的预测，资金管理和交易策略来进行实际的交易</p><h2 id="基础部分"><a href="#基础部分" class="headerlink" title="基础部分"></a>基础部分</h2><p><strong>技术分析</strong>是以预测市场价格变化的未来趋势为目的，以图表为主要手段对市场行为进行分析的研究</p><p><strong>市场行为</strong>包括价格，交易量和持仓兴趣</p><p><strong>理论基础</strong>：市场行为包容消化一切；价格以趋势方式演变；历史会重演。如果这三个假设不成立，技术分析也就失去意义</p><p><strong>基础分析</strong>或称价值分析，是集中考察导致价格涨，落或持平的供求关系；根据分析得来的商品的内在价值与当前价格，判断是买入还是卖出。而技术分析主要研究市场行为</p><p><strong>道氏理论</strong>是技术分析理论的起源，其基本原则：</p><ol><li>平均价格包容消化一切因素</li><li>市场具有三种趋势（主要趋势，次要趋势，短暂趋势；其趋势定义：只要相继的上冲价格波峰和波谷都对应的高过前一个波峰，波谷，那么市场就处于上升趋势中）</li><li>大趋势可分为三个阶段（积累阶段，上升阶段，见顶阶段）</li><li>各种平均价格必须相互验证</li><li>交易量必须验证趋势</li><li>市场会沿着既定趋势一直运行，直到发生确凿的反转信号</li></ol><h2 id="图表"><a href="#图表" class="headerlink" title="图表"></a>图表</h2><p>图表类型有点数图，单线图，日线图</p><p><strong>日线图</strong>做法：X轴时间，Y轴价格，将每日最高价和最低价用线段连接，并在右边引出一截为收市价；图表下方标出交易量和持仓兴趣</p><p><strong>交易量</strong>为当日在某商品市场发生的交易总额</p><p><strong>持仓兴趣</strong>为所有交易商到当日收市为止累计的未平仓合约的总数目</p><p>要做短线交易，可以使用日内线图，如5分钟线图，1小时线图等；做长期趋势分析，必须用周线图及月线图</p><h2 id="趋势"><a href="#趋势" class="headerlink" title="趋势"></a>趋势</h2><p><strong>趋势</strong>就是市场何去何从的方向，有三种方向：上升，下降和横向延伸；交易商有三种对应选择：做多，做空，不交易</p><p><strong>趋势类型</strong>：主要趋势（大于六个月）次要趋势（三个星期到数月）短暂趋势（短于三个星期）；一般来说，期货市场顺应的趋势焦点是次要趋势，短暂趋势用来选择入市的时间，如在上升趋势的回撤中建立多头头寸</p><p><strong>支撑</strong>：波谷，向上反弹低点；在此价格下方，买方兴趣强大，足以撑拒卖方形成的压力</p><p><strong>阻挡</strong>：波峰；卖方势大，价格转跌</p><p>上升趋势中，阻挡水平意味上升势头将再次稍息，迟早会被向上穿越；下降趋势中，支撑水平也不能长久；因此会出现反弹回撤，形成一系列的波；只要支撑或阻挡被穿越了，他们就会互换角色</p><p><strong>趋势线</strong>是图表分析师使用的最简便也是最有价值的基本技术工具之一；上升趋势线是沿着相继的向上反弹低点联结而成的一条直线，位于价格图像下侧，下降趋势线是沿着相继的上冲高点联结而成，位于价格上侧；要画出趋势线，至少有两个反弹点，要验证趋势线，要价格第三次触线反弹</p><p>使用趋势线：在上升趋势中，趋势线在市场下方提供的支撑边界，可以用作买进区域；下降趋势线可以用作阻挡区，达成卖出目的；假如趋势线被突破，则发出趋势生变信号，要平仓了结当前趋势建立的头寸</p><p><strong>扇形原理</strong>：当原有趋势线被突破后，做出新的趋势线，当第三条趋势线被突破，构成反转信号</p><p>趋势线的陡峭程度：倾斜角度45的趋势线最有意义；过于陡峭，表明价格上升太快无法持久，过于平缓表明趋势不太可靠</p><p><strong>管道线</strong>：在上升或下降趋势中，两个峰及两个谷画出的线组成管道线；可以进行短期平仓获利；当价格无力到达管道线，这是趋势即将有变的警讯</p><p><strong>百分比回撤</strong>：在每次重大的市场运动之后，价格总要回撤其中的一部分，然后再按照既有趋势方向继续发展</p><p><strong>速度阻挡线</strong>：测绘趋势上升或者下降的速率</p><p><strong>反转日</strong>：反转日发生在市场顶部或底部；顶部反转日：上升趋势中，某日价格达到了新的高位，但当天收市价格却低于前一天收市价</p><p><strong>价格跳空</strong>：指线图上没有发生交易的区域</p><h2 id="价格形态"><a href="#价格形态" class="headerlink" title="价格形态"></a>价格形态</h2><p>价格形态分为反转型和持续型</p><p><strong>反转形态要领</strong>：</p><ol><li>市场上事先确实有趋势存在</li><li>现行趋势即将反转的第一个信号，经常是重要的趋势线被突破</li><li>形态的规模越大，则随之而来的市场动作越大</li><li>顶部形态所经历的时间通常短于底部形态，但其波动性较强</li><li>底部形态的价格范围通常较小，但其酝酿时间较长</li><li>交易量在验证向上突破信号的可靠性方面，更具参考价值</li></ol><p>下面简要介绍常见的反转形态：</p><p><strong>头肩型</strong>：一个头，两个肩；两个肩高度近似，头比两肩高；两个波谷画出一条颈线，当收市价低于颈线，形态完成</p><p><strong>倒头肩型</strong>：头肩型底，与头肩型顶互为镜像</p><p><strong>三重顶，三重底</strong>：头肩型的变体，区别是头与肩高度近似</p><p><strong>双重顶，双重底</strong>：类似头肩型，只是只有两个峰</p><p>过滤器：过滤错误信号，以判断突破是否成立</p><p><strong>圆顶，圆底</strong>：趋势平缓的，逐渐地从下降转为横向，再由横向转为上升</p><p><strong>V形</strong>：又叫长钉形；剧烈的市场反转</p><p>接下来是持续形态，其通常用时较短暂:</p><p><strong>三角形</strong>：分为三类：对称，上升和下降；对称三角形具有两条逐渐聚拢的趋势线，上面的直线下倾，下面的直线上升，左侧做垂直线，称为底，两条直线的交点称为顶点；上升三角形下边线上倾，上边线水平；下降三角形上边线下降，下边线水平；三角形中至少有四个转折点</p><p>对称三角形结束之后通常延续既有趋势；上升三角形属于看涨形态；下降三角形属于看跌形态</p><p><strong>喇叭形</strong>：与三角形形态相反，两条线逐渐分离，为扩大三角形；此形态代表交易活动非常积极，属于看跌形态</p><p><strong>钻石形态</strong>：由扩大三角形和对称三角形组成</p><p><strong>旗形和三角旗形</strong>：通常发生在市场剧烈运动之后，代表趋势的短暂休整</p><p><strong>楔形</strong>：与三角形相似，但是其有明显的倾角；下降楔形看涨，上升楔形看跌</p><p><strong>矩形</strong>：价格在两条平行的水平直线之间横向伸展，属于趋势的修正状态</p><p>相互验证：指我们把所有技术信号和指标都加以比较参考，从而保证他们中的大部分相互验证，指向共同的方向</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;总览&quot;&gt;&lt;a href=&quot;#总览&quot; class=&quot;headerlink&quot; title=&quot;总览&quot;&gt;&lt;/a&gt;总览&lt;/h2&gt;&lt;p&gt;本书是期货分析的一本很好的入门书，读此书是为了了解交易及期货技术分析的一些名词概念&lt;/p&gt;
&lt;p&gt;主要读的章节部分有图表和趋势分析，趋势分析
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>读Effective C++</title>
    <link href="http://yoursite.com/2018/02/04/read-effective-cpp/"/>
    <id>http://yoursite.com/2018/02/04/read-effective-cpp/</id>
    <published>2018-02-04T12:04:46.000Z</published>
    <updated>2020-03-05T13:31:41.829Z</updated>
    
    <content type="html"><![CDATA[<h1 id="读Effective-C"><a href="#读Effective-C" class="headerlink" title="读Effective C++"></a>读Effective C++</h1><p>2018年一月份读书：《Effective C++：改善程序与设计的55个具体做法》</p><p>一月份利用晚上的时间粗读本书，算是对C++基础知识的复习与学习；按照章节顺序来读，前面部分较基础，后边涉及到泛型编程，看不太懂。</p><p>读完之后写下本篇，是对一月份学习的一个简要总结，督促后边继续学习，也是对本书内容进行索引总结，方便遇到具体问题快速查阅，以节省时间。</p><h2 id="内容索引"><a href="#内容索引" class="headerlink" title="内容索引"></a>内容索引</h2><p>本书共介绍C++程序设计的55个准则，作者已按照类型划分不同分类：</p><h3 id="1-基础介绍"><a href="#1-基础介绍" class="headerlink" title="1 基础介绍"></a>1 基础介绍</h3><p>通用的也是常用的准则：</p><ol><li><strong>了解C++组成</strong>。四部分：基础C, Object-Oriented C++, Template C++(泛型编程), STL(程序库)</li><li>用<strong>const, enum, inline</strong>替换#define</li><li><strong>尽可能使用const</strong>。</li><li><strong>对象被使用前先初始化</strong>。比如声明变量时就赋初值，构造函数使用成员初值列表，而不要在函数内进行赋值</li></ol><h3 id="2-类的基础方法"><a href="#2-类的基础方法" class="headerlink" title="2 类的基础方法"></a>2 类的基础方法</h3><p>主要是这几个编译器会默认给你生成的类方法：默认构造函数，析构函数，拷贝构造函数，拷贝赋值操作符</p><ol><li><strong>如果不要编译器生成的，要明确拒绝</strong>。如将方法声明为private，并且不实现</li><li><strong>为多态基类声明virtual析构函数</strong></li><li><strong>别让异常逃离析构函数</strong>。析构函数要捕获异常，要么吞下它们，要么结束程序</li><li><strong>不在构造和析构过程调用virtual函数</strong>。</li><li>*<em>令operate＝返回一个reference to *this *</em>。为了支持连等赋值</li><li><strong>在operate＝中处理自我赋值</strong>。因为可能出现删除自己，再取自己内容的情况</li><li><strong>复制对象时勿忘其每一部分</strong>。</li></ol><h3 id="3-资源管理"><a href="#3-资源管理" class="headerlink" title="3 资源管理"></a>3 资源管理</h3><p>资源包括动态内存分配，以及文件描述符，互斥锁，数据库连接，sockets等。当你不再使用它时，必须还给系统，否则会导致内存泄漏。</p><p>使用对象来管理内存，主要是使用类的构造函数，析构函数，拷贝函数。如在构造函数中获得资源，并在析构函数中释放资源。</p><ol><li><strong>小心拷贝行为</strong>。禁止拷贝，使用引用计数法</li><li><strong>提供对原始资源的访问</strong>。设计时要保留访问原始数据的接口</li><li><strong>new和delete要采用相同形式</strong>。如new delete/ new[] delete[]</li><li><strong>以独立对象将newed对象置入智能指针</strong>。智能指针会自动释放资源</li></ol><h3 id="4-设计与声明"><a href="#4-设计与声明" class="headerlink" title="4 设计与声明"></a>4 设计与声明</h3><p>作者说，软件设计是令软件作出你希望它做出的事情，以一般性的构想开始，最终演变成十足的细节，以允许特殊接口的开发。</p><p>接口的设计，要易用，不易误用。应该向开源库学习，提供的接口清晰无歧义，并尽可能考虑各种输入与异常安全。</p><ol><li><strong>设计class犹如设计type</strong>。作者提出一系列问题，是在设计高效classes时需要考虑的</li><li><strong>使用传引用替换传值</strong>。传值涉及对象的拷贝，这就需要时间与空间成本；不过对内置类型，传值可能更好</li><li><strong>必须返回对象时，不要返回reference</strong>。最怕引用指向local stack对象</li><li><strong>将成员变量声明为private</strong>。封装，划分访问控制更安全</li><li><strong>宁以non-member non-friend替换member函数</strong>。增加封装性</li><li><strong>若所有参数皆需要类型转换，请采用non-member函数</strong></li><li><strong>考虑写不抛出异常的swap函数</strong>。</li></ol><h3 id="5-实现"><a href="#5-实现" class="headerlink" title="5 实现"></a>5 实现</h3><p>设计部分完成之后就该实现了，实现部分要多考虑一些细节问题，避免降低效率，代码膨胀，过度耦合，资源泄漏等问题。</p><ol><li><strong>尽可能延后变量定义式的出现时间</strong>。防止程序提前结束，导致不必要的构造和析构</li><li><strong>少做转型动作</strong>。也是会影响效率；尽量使用新式转换(四种)</li><li><strong>避免返回handles指向对象内部成分</strong>。</li><li><strong>为异常安全努力是值得的</strong>。不泄漏资源，不允许数据败坏</li><li><strong>了解inline</strong>。会被编译器替换，免除函数调用开销，但是可能会导致代码膨胀</li><li><strong>将文件间的编译依存关系降至最低</strong>。</li></ol><h3 id="6-继承和面向对象设计"><a href="#6-继承和面向对象设计" class="headerlink" title="6 继承和面向对象设计"></a>6 继承和面向对象设计</h3><p>我感觉这是C++的精华部分，也挺重要。</p><ol><li><strong>public继承表示is－a关系</strong>。</li><li><strong>避免遮掩继承而来的名称</strong>。作用域的遮掩行为；可使用using声明式使用基类的名称</li><li><strong>区分接口继承和实现继承</strong>。选择派生类是继承基类的接口，还是接口加实现</li><li><strong>考虑virtual函数以外的其他选择</strong>。作者提供了几个方案来替代虚函数</li><li><strong>绝不重新定义继承而来的non-virtual函数以及缺省参数值</strong>。virtual函数是动态绑定</li><li><strong>通过复合塑模出has-a或根据某物实现出</strong>。</li><li><strong>明智而审慎地使用private继承和多重继承</strong>。</li></ol><h3 id="7-模板和泛型编程"><a href="#7-模板和泛型编程" class="headerlink" title="7 模板和泛型编程"></a>7 模板和泛型编程</h3><p>关于模板和泛型编程，看的不是很懂，也没仔细看，这里就先直接拷贝作者的条款，以后再看有新的理解再修改补充。</p><ol><li><strong>了解隐式接口和编译器多态</strong></li><li><strong>了解typename的双重意义</strong></li><li><strong>学习处理模板化基类内的名称</strong></li><li><strong>将与参数无关的代码抽离templates</strong></li><li><strong>运用成员函数模板接受所有兼容类型</strong></li><li><strong>需要类型转换时请为模板定义非成员函数</strong></li><li><strong>请使用traits classes表现类型信息</strong></li><li><strong>认识template元编程</strong></li></ol><h3 id="8-定制new和delete"><a href="#8-定制new和delete" class="headerlink" title="8 定制new和delete"></a>8 定制new和delete</h3><p>手动管理内存，才能获得最佳的效率。</p><ol><li><strong>了解new－handler的行为</strong>。指定函数处理分配内存失败的情况</li><li><strong>了解new delete的合理替换时机</strong>。有许多理由需要定制，包括改善效能，对heap运用错误进行调试，收集heap使用信息</li><li><strong>编写new delete时需固守常规</strong>。包括一些固有的程式，以及异常情况的处理</li><li><strong>写了placement new也要写placement delete</strong>。placement版本的new是一个特定位置上的new，一般接受一个void*,指向对象被构造之处，防止出现内存分配成功，但构造函数失败导致的内存泄漏问题</li></ol><h3 id="9-杂项"><a href="#9-杂项" class="headerlink" title="9 杂项"></a>9 杂项</h3><ol><li><strong>不要轻忽编译器的警告</strong>。有可能因为错过警告而导致复杂的调试情况</li><li><strong>熟悉标准程序库</strong>。熟悉标准程序库，相当于在编写代码时拥有各种工具组件可以挑选，方便快速开发出程序，当然可能对部分对速度有更高要求的程序不太适用，但是通用性还是很高</li><li><strong>熟悉Boost</strong>。因为标准程序库多数是从Boost中取来，Boost功能也更强一些</li></ol><h2 id="下一步"><a href="#下一步" class="headerlink" title="下一步"></a>下一步</h2><p>本书非常经典，只读一遍还远无法掌握其精髓，之后需要多看，可能不同的时期看收获也是不一样的。</p><p>接下来准备粗读下《C++标准程序库》，了解标准程序库有哪些组件，将常用的记熟，不常用的需要的时候可以快速找到即可。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;读Effective-C&quot;&gt;&lt;a href=&quot;#读Effective-C&quot; class=&quot;headerlink&quot; title=&quot;读Effective C++&quot;&gt;&lt;/a&gt;读Effective C++&lt;/h1&gt;&lt;p&gt;2018年一月份读书：《Effective C++：
      
    
    </summary>
    
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>指针的引用</title>
    <link href="http://yoursite.com/2017/11/23/%E6%8C%87%E9%92%88%E7%9A%84%E5%BC%95%E7%94%A8/"/>
    <id>http://yoursite.com/2017/11/23/%E6%8C%87%E9%92%88%E7%9A%84%E5%BC%95%E7%94%A8/</id>
    <published>2017-11-23T13:12:10.000Z</published>
    <updated>2020-03-05T13:31:41.831Z</updated>
    
    <content type="html"><![CDATA[<p>有这么一个场景：程序中某一模块在对数据进行处理，另一个模块想要将其处理的数据写入文件，这时候有两种方案，一个是通过接口将数据拷贝出来，好处是写数据到文件不影响处理数据，缺点是占用内存较大；一个是将数据的地址传递出来，这样写入文件的时候不能对数据进行处理，好处是节省内存，不用重复的分配和释放内存。</p><p>决定采用第二个方案，维护一个指向数据地址的指针，但是在编码时发现，函数直接传递指针进去，然后对指针进行赋值，这样在此函数内指针是没有问题，但函数调用结束指针还是没有指向需要的地址；最后通过传递指针的引用来解决。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdlib.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func_ref_of_pointer</span><span class="params">(<span class="keyword">float</span>* &amp;p, <span class="keyword">float</span>* data)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func_pointer</span><span class="params">(<span class="keyword">float</span>* p, <span class="keyword">float</span>* data)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// init</span></span><br><span class="line">    <span class="keyword">float</span> * data = (<span class="keyword">float</span>*)<span class="built_in">malloc</span>(<span class="number">2</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>));</span><br><span class="line">    <span class="built_in">memset</span>(data, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">float</span>)*<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">float</span> t = <span class="number">1.2</span>;</span><br><span class="line">    <span class="built_in">memcpy</span>(data, &amp;t, <span class="keyword">sizeof</span>(<span class="keyword">float</span>));</span><br><span class="line">    t = <span class="number">3.4</span>;</span><br><span class="line">    <span class="built_in">memcpy</span>(data+<span class="number">1</span>, &amp;t, <span class="keyword">sizeof</span>(<span class="keyword">float</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"data: %f %f\n"</span>, data[<span class="number">0</span>], data[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// test</span></span><br><span class="line">    <span class="keyword">float</span> * p = <span class="literal">NULL</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        func_ref_of_pointer(p, data);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//func_pointer(p, data);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"p data: %f %f\n"</span>, p[<span class="number">0</span>], p[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func_ref_of_pointer</span><span class="params">(<span class="keyword">float</span>* &amp;p, <span class="keyword">float</span>* data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    p = data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func_pointer</span><span class="params">(<span class="keyword">float</span>* p, <span class="keyword">float</span>* data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    p = data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;有这么一个场景：程序中某一模块在对数据进行处理，另一个模块想要将其处理的数据写入文件，这时候有两种方案，一个是通过接口将数据拷贝出来，好处是写数据到文件不影响处理数据，缺点是占用内存较大；一个是将数据的地址传递出来，这样写入文件的时候不能对数据进行处理，好处是节省内存，不用
      
    
    </summary>
    
    
    
      <category term="C 指针 引用" scheme="http://yoursite.com/tags/C-%E6%8C%87%E9%92%88-%E5%BC%95%E7%94%A8/"/>
    
  </entry>
  
</feed>
