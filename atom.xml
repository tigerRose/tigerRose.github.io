<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>tigerose&#39;s site</title>
  
  <subtitle>In me the tiger sniffs the rose</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-03-29T12:41:42.372Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>tigerose</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>vim实用技巧</title>
    <link href="http://yoursite.com/2020/03/29/vim-practical-skills/"/>
    <id>http://yoursite.com/2020/03/29/vim-practical-skills/</id>
    <published>2020-03-29T12:35:59.000Z</published>
    <updated>2020-03-29T12:41:42.372Z</updated>
    
    <content type="html"><![CDATA[<p>记录vim实用技巧,会长期更新</p><h2 id="record-回放功能"><a href="#record-回放功能" class="headerlink" title="record 回放功能"></a>record 回放功能</h2><p>使用场景:需要多次进行的有规律但较为复杂的操作<br>步骤:</p><ol><li>q+a 开始录制</li><li>命令完成,按q停止</li><li>@+a 重复执行命令  </li></ol><p>其中a是record名字</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;记录vim实用技巧,会长期更新&lt;/p&gt;
&lt;h2 id=&quot;record-回放功能&quot;&gt;&lt;a href=&quot;#record-回放功能&quot; class=&quot;headerlink&quot; title=&quot;record 回放功能&quot;&gt;&lt;/a&gt;record 回放功能&lt;/h2&gt;&lt;p&gt;使用场景:需要多次进行
      
    
    </summary>
    
    
    
      <category term="vim" scheme="http://yoursite.com/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>工作中遇到的压缩方式总结</title>
    <link href="http://yoursite.com/2020/03/22/compress-method/"/>
    <id>http://yoursite.com/2020/03/22/compress-method/</id>
    <published>2020-03-22T13:00:52.000Z</published>
    <updated>2020-03-22T14:23:49.053Z</updated>
    
    <content type="html"><![CDATA[<p>本文总结工作中使用过的数据压缩方法,主要有zlib,qatzip,igzip等<br>最后还进行了针对大规模数据多线程解压缩加速的分析</p><h2 id="zlib库"><a href="#zlib库" class="headerlink" title="zlib库"></a>zlib库</h2><p>zlib是用于数据压缩的函数库,使用deflate算法<br><strong>deflate算法</strong>是同时使用了<em>LZ77算法</em>和<em>霍夫曼编码</em>的一个无损压缩算法</p><p>主要函数有:</p><ul><li><code>int compress (Bytef *dest, uLongf *destLen, const Bytef *source, uLong sourceLen);</code><br>  压缩方法,将源缓冲中的数据压缩并放入目的缓冲区<br>  注意目的缓冲区的大小有可能比压缩前还要大,因此destLen要留够空间,至少比sourceLen加12字节之后还大0.1%<br>  返回Z_OK表示成功;Z_MEM_ERROR表示没有足够内存;Z_BUF_ERROR表示目的缓冲区不够大</li><li><code>int compress2 (Bytef *dest, uLongf *destLen,const Bytef *source, uLong sourceLen,int level);</code><br>  功能与compress函数一样,增加了level参数,范围0-9,从0-9速度变慢,但压缩率提高,设置0表示不压缩,Z_DEFAULT_COMPRESSION 表示设置一个适中的参数<br>  返回值与compress相同,多出Z_STREAM_ERROR 表示level参数无效</li><li><code>int uncompress (Bytef *dest, uLongf *destLen,const Bytef *source, uLong sourceLen);</code><br>  解压缩<br>  返回值与compress相同,多出一个Z_DATA_ERROR 表示输入数据被破坏</li><li><code>deflateInit() + deflate() + deflateEnd()</code><br>  三个函数结合完成compress功能,参考zlib仓库example.c compress.c</li><li><code>inflateInit() + inflate() + inflateEnd()</code><br>  三个函数完成uncompress功能</li><li>gz开头的函数,用来操作gz文件,类似stdio调用,如果gzopen,gzwrite等</li></ul><p>简单的压缩示例代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;zlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gzCompress</span><span class="params">(Bytef *data, uLong ndata, Bytef *zdata, uLong *nzdata, <span class="keyword">int</span> level)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// error code </span></span><br><span class="line"><span class="comment">// Z_OK if success, Z_MEM_ERROR if there was not enough memory, </span></span><br><span class="line"><span class="comment">// Z_BUF_ERROR:-5 if there was not enough room in the output buffer, </span></span><br><span class="line"><span class="comment">// Z_STREAM_ERROR if the level parameter is invalid.</span></span><br><span class="line">z_stream c_stream;</span><br><span class="line"><span class="keyword">int</span> err = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (data &amp;&amp; ndata &gt; <span class="number">0</span>) </span><br><span class="line">&#123;</span><br><span class="line">c_stream.zalloc = <span class="literal">NULL</span>;</span><br><span class="line">c_stream.zfree = <span class="literal">NULL</span>;</span><br><span class="line">c_stream.opaque = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">if</span> (deflateInit2(&amp;c_stream, level, Z_DEFLATED,</span><br><span class="line">MAX_WBITS + <span class="number">16</span>, <span class="number">8</span>, Z_DEFAULT_STRATEGY) != Z_OK) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">c_stream.next_in = data;</span><br><span class="line">c_stream.avail_in = ndata;</span><br><span class="line">c_stream.next_out = zdata;</span><br><span class="line">c_stream.avail_out = *nzdata;</span><br><span class="line"><span class="keyword">while</span> (c_stream.avail_in != <span class="number">0</span> &amp;&amp; c_stream.total_out &lt; *nzdata) </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> ((err = deflate(&amp;c_stream, Z_BLOCK)) != Z_OK)</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (...)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"deflate error: "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (c_stream.avail_in != <span class="number">0</span>) </span><br><span class="line"><span class="keyword">return</span> c_stream.avail_in;</span><br><span class="line"><span class="keyword">for</span> (;;) </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> ((err = deflate(&amp;c_stream, Z_FINISH)) == Z_STREAM_END) <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span> (err != Z_OK) <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (deflateEnd(&amp;c_stream) != Z_OK) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">*nzdata = c_stream.total_out;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于压缩等级,从0-9,速度越来越慢,随之而来的是更低的压缩率</p><p>压缩文件是二进制的,由三部分组成</p><ol><li>头信息</li><li>数据主体 </li><li>校验</li></ol><p>以下为标准格式的简要说明,详细解释可以看参考文档:<br><img src="/images/compress_method/header.png" alt=""></p><h2 id="qatzip库"><a href="#qatzip库" class="headerlink" title="qatzip库"></a>qatzip库</h2><p>通过硬件加速的方式进行压缩,即需要插入一张单独的intel的QAT卡;好处显而易见,正常压缩是消耗CPU资源,用另一张卡单独进行压缩,空闲出CPU资源可以进行其他计算,提高整体效率,缺点就是费钱,并占用一个PCIE插槽位置<br>另外只能运行于linux系统,不支持windows</p><p><a href="https://github.com/intel/QATzip.git" target="_blank" rel="noopener">qatzip_github代码仓库</a></p><p>简单的压缩代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> COMPILE_QAT</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cpa.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cpa_dc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;qatzip.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;qatzip_internal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;qz_utils.h&gt;</span></span></span><br><span class="line"><span class="keyword">extern</span> QzSessionParams_T g_params_th;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qzipCompress</span><span class="params">(Bytef *data, uLong ndata, Bytef *zdata, uLong *nzdata, <span class="keyword">int</span> level)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> COMPILE_QAT</span></span><br><span class="line">    QzSession_T session;</span><br><span class="line">    <span class="keyword">int</span> rc;</span><br><span class="line"></span><br><span class="line">    rc = qzInit(&amp;session, g_params_th.sw_backup);</span><br><span class="line">    <span class="keyword">if</span> (rc != QZ_OK &amp;&amp; rc != QZ_DUPLICATE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"qzInit failed, rc:"</span>&lt;&lt;rc&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    rc = qzSetupSession(&amp;session, &amp;g_params_th);</span><br><span class="line">    <span class="keyword">if</span> (rc != QZ_OK &amp;&amp; rc != QZ_NO_INST_ATTACH)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"qzSetupSession failed, rc:"</span>&lt;&lt;rc&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    rc = qzCompress(&amp;session, data, (<span class="keyword">uint32_t</span> *)&amp;ndata, zdata, (<span class="keyword">uint32_t</span> *)nzdata, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (rc != QZ_OK)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"qzCompress failed, rc:"</span>&lt;&lt;rc&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    qzTeardownSession(&amp;session);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="keyword">return</span> gzCompress(data, ndata, zdata, nzdata, level);</span><br><span class="line"><span class="meta">#e</span></span><br></pre></td></tr></table></figure><h2 id="igzip库"><a href="#igzip库" class="headerlink" title="igzip库"></a>igzip库</h2><p>intel工程师使用指令集优化zlib,针对genomic data比如<strong>bam sam</strong>数据,在几乎不降低压缩率的情况下,速度提升约4倍<br><a href="https://github.com/intel/isa-l.git" target="_blank" rel="noopener">igzip_github代码仓库</a><br>igzip的代码和isa-l代码仓库在一起</p><p>igzip使用代码示例:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"igzip_lib.h"</span></span></span><br><span class="line"><span class="keyword">int</span> level_size_buf[<span class="number">10</span>] = &#123;</span><br><span class="line">#ifdef ISAL_DEF_LVL0_DEFAULT</span><br><span class="line">ISAL_DEF_LVL0_DEFAULT,</span><br><span class="line">#<span class="keyword">else</span></span><br><span class="line"><span class="number">0</span>,</span><br><span class="line">#endif</span><br><span class="line">#ifdef ISAL_DEF_LVL1_DEFAULT</span><br><span class="line">ISAL_DEF_LVL1_DEFAULT,</span><br><span class="line">#<span class="keyword">else</span></span><br><span class="line"><span class="number">0</span>,</span><br><span class="line">#endif</span><br><span class="line">#ifdef ISAL_DEF_LVL2_DEFAULT</span><br><span class="line">ISAL_DEF_LVL2_DEFAULT,</span><br><span class="line">#<span class="keyword">else</span></span><br><span class="line"><span class="number">0</span>,</span><br><span class="line">#endif</span><br><span class="line">#ifdef ISAL_DEF_LVL3_DEFAULT</span><br><span class="line">ISAL_DEF_LVL3_DEFAULT,</span><br><span class="line">#<span class="keyword">else</span></span><br><span class="line"><span class="number">0</span>,</span><br><span class="line">#endif</span><br><span class="line">#ifdef ISAL_DEF_LVL4_DEFAULT</span><br><span class="line">ISAL_DEF_LVL4_DEFAULT,</span><br><span class="line">#<span class="keyword">else</span></span><br><span class="line"><span class="number">0</span>,</span><br><span class="line">#endif</span><br><span class="line">#ifdef ISAL_DEF_LVL5_DEFAULT</span><br><span class="line">ISAL_DEF_LVL5_DEFAULT,</span><br><span class="line">#<span class="keyword">else</span></span><br><span class="line"><span class="number">0</span>,</span><br><span class="line">#endif</span><br><span class="line">#ifdef ISAL_DEF_LVL6_DEFAULT</span><br><span class="line">ISAL_DEF_LVL6_DEFAULT,</span><br><span class="line">#<span class="keyword">else</span></span><br><span class="line"><span class="number">0</span>,</span><br><span class="line">#endif</span><br><span class="line">#ifdef ISAL_DEF_LVL7_DEFAULT</span><br><span class="line">ISAL_DEF_LVL7_DEFAULT,</span><br><span class="line">#<span class="keyword">else</span></span><br><span class="line"><span class="number">0</span>,</span><br><span class="line">#endif</span><br><span class="line">#ifdef ISAL_DEF_LVL8_DEFAULT</span><br><span class="line">ISAL_DEF_LVL8_DEFAULT,</span><br><span class="line">#<span class="keyword">else</span></span><br><span class="line"><span class="number">0</span>,</span><br><span class="line">#endif</span><br><span class="line">#ifdef ISAL_DEF_LVL9_DEFAULT</span><br><span class="line">ISAL_DEF_LVL9_DEFAULT,</span><br><span class="line">#<span class="keyword">else</span></span><br><span class="line"><span class="number">0</span>,</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> mylong;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> mychar;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">igzipCompress</span><span class="params">(mychar* source, mylong source_len, mychar* dest, mylong* dest_len, </span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">int</span> level)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">isal_zstream</span> <span class="title">stream</span>;</span> <span class="comment">/* Holds stream information */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">isal_gzip_header</span> <span class="title">gz_hdr</span>;</span></span><br><span class="line"></span><br><span class="line">isal_gzip_header_init(&amp;gz_hdr); <span class="comment">/* Set gzip header default values */</span></span><br><span class="line"></span><br><span class="line">isal_deflate_init(&amp;stream); <span class="comment">/* Initialize compression stream data structure */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> level_size = level_size_buf[level];</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> * level_buf = <span class="literal">NULL</span>;</span><br><span class="line">level_buf = (<span class="keyword">unsigned</span> <span class="keyword">char</span>*)<span class="built_in">malloc</span>(level_size);</span><br><span class="line"></span><br><span class="line">stream.avail_in = <span class="number">0</span>; <span class="comment">// Number of bytes available at next_in.</span></span><br><span class="line">stream.flush = NO_FLUSH;    <span class="comment">// Flush type can be NO_FLUSH,SYNC_FLUSH or FULL_FLUSH.</span></span><br><span class="line">stream.level = level;   <span class="comment">// Compression level to use.</span></span><br><span class="line">stream.level_buf = level_buf; <span class="comment">// User allocated buffer required for different compression levels.</span></span><br><span class="line">stream.level_buf_size = level_size;   <span class="comment">// Size of level_buf.</span></span><br><span class="line">stream.gzip_flag = IGZIP_GZIP_NO_HDR;   <span class="comment">// Indicate if gzip compression is to be performed.</span></span><br><span class="line">stream.next_out = dest; <span class="comment">// Next output byte.</span></span><br><span class="line">stream.avail_out = *dest_len;   <span class="comment">// Number of bytes avaliable at next_out.</span></span><br><span class="line"></span><br><span class="line">isal_write_gzip_header(&amp;stream, &amp;gz_hdr);   <span class="comment">/* Write gzip header to output stream. */</span></span><br><span class="line"></span><br><span class="line">stream.next_in = source;</span><br><span class="line">stream.avail_in = source_len;</span><br><span class="line">stream.end_of_stream = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ret = isal_deflate(&amp;stream);</span><br><span class="line"><span class="keyword">if</span> (ret != ISAL_DECOMP_OK) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"igzip: Error encountered while compressing file\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (level_buf != <span class="literal">NULL</span>)</span><br><span class="line"><span class="built_in">free</span>(level_buf);</span><br><span class="line">*dest_len = stream.next_out - dest;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="bgzip库及多线程解压缩"><a href="#bgzip库及多线程解压缩" class="headerlink" title="bgzip库及多线程解压缩"></a>bgzip库及多线程解压缩</h2><p>bgzip:Block compression/decompression utility<br>用于bam/sam文件的格式,核心是将压缩数据分块(64KB),从而通过索引可以快速查询数据  </p><p>注:bam/sam文件是高通量测序的标准格式文件,存储内容为fastq文件与参考基因组reference进行mapping之后的数据;其中sam为文本格式,bam为二进制格式,两者可以通过<em>samtools</em>工具相互转换;bam文件可以通过建立index,快速定位数据位置,从而加速访问</p><p>考虑这样一种情况,有一千个block的数据需要压缩并存放在一个文件中,这个文件可能很大,几百GB;假如我只想要分析某几个block的数据,传统的压缩方式需要将整个文件全部解压之后才能获取想要的数据,效率很低</p><p>而通过自定义压缩block的head信息,使用其中的<strong>extra filed</strong> 和 <strong>comment</strong> 字段就可以实现index功能,步骤如下:</p><ol><li><p>压缩前,首先添加字段:comment添加block的ID,extra field添加压缩前和后的bytes大小;以zlib压缩举例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">uint8_t</span> EXTRA_LEN = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">uint8_t</span> EXTRA_BUF_LEN = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">uint8_t</span> SI1 = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">uint8_t</span> SI2 = <span class="number">101</span>;</span><br><span class="line"></span><br><span class="line">gz_header header;</span><br><span class="line"><span class="comment">// 添加comment信息,如指定当前block的ID,如1,2,3等</span></span><br><span class="line"><span class="comment">// 用于后续快速获取想要的block数据</span></span><br><span class="line">header.comment = (Bytef *)&amp;comment[<span class="number">0</span>];</span><br><span class="line">header.comm_max = comment.size() + <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 按照标准格式指定extra field的长度信息</span></span><br><span class="line">header.extra_len = EXTRA_LEN;</span><br><span class="line">header.extra_max = EXTRA_BUF_LEN;</span><br><span class="line"><span class="keyword">uint8_t</span> extra_buf[EXTRA_LEN] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="comment">// SI1 SI2为自定义字段,用来标识我们自定义的头文件格式</span></span><br><span class="line">extra_buf[<span class="number">0</span>] = SI1;</span><br><span class="line">extra_buf[<span class="number">1</span>] = SI2;</span><br><span class="line">extra_buf[<span class="number">2</span>] = EXTRA_BUF_LEN;</span><br><span class="line">extra_buf[<span class="number">3</span>] = <span class="number">0</span>;</span><br><span class="line">header.extra = extra_buf;</span><br><span class="line">err = deflateSetHeader(&amp;c_stream, &amp;header);</span><br></pre></td></tr></table></figure></li><li><p>压缩后,更新extra filed中压缩前后数据长度</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">*nzdata = c_stream.total_out;</span><br><span class="line"></span><br><span class="line">mylong dest_size = *nzdata; <span class="comment">// 压缩后大小,必须压缩完之后才能获取</span></span><br><span class="line">mylong raw_size = ndata; <span class="comment">// 压缩前大小,是输入参数,我们是知道的</span></span><br><span class="line"><span class="comment">// 将两个长度按顺序写入字节流</span></span><br><span class="line"><span class="built_in">memcpy</span>(zdata + <span class="number">16</span>, &amp;dest_size, <span class="keyword">sizeof</span>(dest_size));</span><br><span class="line"><span class="built_in">memcpy</span>(zdata + <span class="number">24</span>, &amp;raw_size, <span class="keyword">sizeof</span>(raw_size));</span><br></pre></td></tr></table></figure></li><li><p>解压缩的时候,首先找到第一个block,读入头信息,获取当前block的标识ID,如果是想要的数据,则通过extra field获取数据长度,按照长度直接读取即可,然后跳到下一个block<br>因为对于无用的block数据,我们只要解析头信息,并<strong>根据长度进行偏移</strong>即可,所以遍历速度会很快<br>然后还可以通过<strong>多线程</strong>进行解压缩,主线程进行block的遍历,如果遇到目标数据,则从线程池中拿一个线程处理当前block<br>如果不需要解压缩,只是从1000个block中采样10个block进行后续的快速分析,则直接将10个block的二进制数据连续输出到磁盘文件即可,多个block可以直接cat到一起而不影响解压缩</p></li></ol><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://www.cnblogs.com/zhuyf87/archive/2013/02/21/2920522.html" target="_blank" rel="noopener">zlib压缩数据</a><br><a href="http://zlib.net/" target="_blank" rel="noopener">zlib官网</a><br><a href="https://software.intel.com/en-us/articles/igzip-a-high-performance-deflate-compressor-with-optimizations-for-genomic-data" target="_blank" rel="noopener">High Performance DEFLATE Compression with Optimizations for Genomic Data Sets</a><br><a href="http://www.zlib.org/rfc-gzip.html" target="_blank" rel="noopener">GZIP file format specification version 4.3</a><br><a href="https://zlib.net/manual.html" target="_blank" rel="noopener">GZIP文件格式简介</a><br><a href="http://www.htslib.org/doc/bgzip.html" target="_blank" rel="noopener">zlib 1.2.11 Manual</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文总结工作中使用过的数据压缩方法,主要有zlib,qatzip,igzip等&lt;br&gt;最后还进行了针对大规模数据多线程解压缩加速的分析&lt;/p&gt;
&lt;h2 id=&quot;zlib库&quot;&gt;&lt;a href=&quot;#zlib库&quot; class=&quot;headerlink&quot; title=&quot;zlib库&quot;&gt;
      
    
    </summary>
    
    
    
      <category term="压缩 zlib igzip" scheme="http://yoursite.com/tags/%E5%8E%8B%E7%BC%A9-zlib-igzip/"/>
    
  </entry>
  
  <entry>
    <title>在cuda中使用哈希表</title>
    <link href="http://yoursite.com/2020/03/15/use-hash-in-cuda/"/>
    <id>http://yoursite.com/2020/03/15/use-hash-in-cuda/</id>
    <published>2020-03-15T12:08:38.000Z</published>
    <updated>2020-03-15T13:04:19.851Z</updated>
    
    <content type="html"><![CDATA[<p>关于在cuda中使用哈希表的一些经验总结</p><h2 id="cuda中哈希方法"><a href="#cuda中哈希方法" class="headerlink" title="cuda中哈希方法"></a>cuda中哈希方法</h2><p>目前已知的在cuda中使用哈希的方法:</p><ol><li><p><strong>数组</strong><br>适用于较小的数据规模,如键的范围是int,或者能转化为整型,值类型最长为long等</p></li><li><p><strong>cudpp</strong><br>可接受的键值范围均为32bit,相比数组好处是占用内存小,不用存储无用数据<br>其内部使用布谷鸟过滤,核心思想是多个hash算法生成多个映射值,如果有一个位置是空的,就将元素放入,否则踢走其中一个,被踢走的再去踢别人,依次类推<br>缺点是无法动态插入,即必须把键值对先准备好;主要用来查询<br><a href="https://github.com/cudpp/cudpp" target="_blank" rel="noopener">cudpp_github</a></p></li><li><p><strong>huge-CTR</strong><br>这是英伟达开发的一个点击率推荐系统的库,其中实现了哈希功能<br>优点是官方文档写了支持动态插入<br><a href="https://github.com/NVIDIA/HugeCTR" target="_blank" rel="noopener">huge-CTR_github</a></p></li></ol><h2 id="cudpp-hash使用"><a href="#cudpp-hash使用" class="headerlink" title="cudpp hash使用"></a>cudpp hash使用</h2><p>使用步骤:</p><ol><li><p>获取GPU卡信息<br>这也是任何cuda程序的第一步,检查有没有卡,以及卡的计算能力等;使用<code>cudaGetDeviceCount() cudaGetDeviceProperties()</code>等API来获取信息</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> deviceCount;</span><br><span class="line">cudaGetDeviceCount(&amp;deviceCount);</span><br><span class="line"><span class="keyword">if</span> (deviceCount == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Error (main): no devices supporting CUDA.\n"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> dev = <span class="number">0</span>;</span><br><span class="line">cudaSetDevice(dev);</span><br><span class="line">cudaDeviceProp prop;</span><br><span class="line"><span class="keyword">if</span> (!quiet &amp;&amp; cudaGetDeviceProperties(&amp;prop, dev) == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Using device %d:\n"</span>, dev);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s; global mem: %uB; compute v%d.%d; clock: %d kHz\n"</span>,</span><br><span class="line">           prop.name, (<span class="keyword">unsigned</span> <span class="keyword">int</span>)prop.totalGlobalMem, (<span class="keyword">int</span>)prop.major,</span><br><span class="line">           (<span class="keyword">int</span>)prop.minor, (<span class="keyword">int</span>)prop.clockRate);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (prop.major &lt; <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"ERROR: CUDPP hash tables are only supported on "</span></span><br><span class="line">            <span class="string">"devices with compute\n  capability 2.0 or greater; "</span></span><br><span class="line">            <span class="string">"exiting.\n"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建<em>CUDPP Handle</em><br>CUDPPHandle 在每个cuda上下文都要建立一个</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CUDPPHandle theCudpp;</span><br><span class="line">CUDPPResult result = cudppCreate(&amp;theCudpp);</span><br><span class="line"><span class="keyword">if</span> (result != CUDPP_SUCCESS)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Error initializing CUDPP Library.\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>准备数据<br> 准备两个unsigned int* 数组, 分别存放keys和values<br> 也可以从一个std::unordered_map获取数据<br> 将keys和values从host拷贝到device</p></li><li><p>创建<em>CUDPPHandle</em></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">CUDPPHashTableConfig config;</span><br><span class="line">config.type = CUDPP_BASIC_HASH_TABLE;</span><br><span class="line">config.kInputSize = kInputSize;</span><br><span class="line">config.space_usage = space_usage;<span class="comment">// 测试值有 1.05f, 1.15f, 1.25f, 1.5f, 2.0f</span></span><br><span class="line">CUDPPHandle hash_table_handle;</span><br><span class="line">CUDPPResult result;</span><br><span class="line">result = cudppHashTable(theCudpp, &amp;hash_table_handle, &amp;config);</span><br><span class="line"><span class="keyword">if</span> (result != CUDPP_SUCCESS)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Error in cudppHashTable call in"</span></span><br><span class="line">            <span class="string">"testHashTable (make sure your device is at"</span></span><br><span class="line">            <span class="string">"least compute version 2.0\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>插入数据</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">result = cudppHashInsert(hash_table_handle, d_test_keys, d_test_vals, kInputSize);</span><br><span class="line">cudaThreadSynchronize();</span><br><span class="line"><span class="keyword">if</span> (result != CUDPP_SUCCESS)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Error in cudppHashInsert call in testHashTable\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用哈希表查询数据</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">result = cudppHashRetrieve(hash_table_handle, d_test_keys, d_test_vals, kInputSize);</span><br><span class="line">cudaThreadSynchronize();</span><br><span class="line"><span class="keyword">if</span> (result != CUDPP_SUCCESS)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Error in cudppHashRetrieve call in testHashTable\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>验证数据<br>将查询的结果由GPU内存拷贝回CPU内存,进行数据的验证</p></li><li><p>释放资源</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">result = cudppDestroyHashTable(theCudpp, hash_table_handle);</span><br><span class="line"><span class="keyword">if</span> (result != CUDPP_SUCCESS)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Error in cudppDestroyHashTable call in testHashTable\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">result = cudppDestroy(theCudpp);</span><br><span class="line"><span class="keyword">if</span> (result != CUDPP_SUCCESS)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Error shutting down CUDPP Library.\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="问题和改进"><a href="#问题和改进" class="headerlink" title="问题和改进"></a>问题和改进</h2><h3 id="cudpp内存泄漏问题"><a href="#cudpp内存泄漏问题" class="headerlink" title="cudpp内存泄漏问题"></a>cudpp内存泄漏问题</h3><p>cudpp在更新的cuda版本如cuda10,更新的显卡架构如TitanV下出现内存泄漏问题<br>情况就是只要使用cudpp的lib,代码经过第一个cuda API调用之后就会卡死,内存不断增长,直到内存爆掉<br>经过测试,我发现是计算能力配置问题,新的显卡架构支持更高的计算能力,只要在编译选项中增加<strong>compute_60;compute_70</strong>即可解决问题<br>详见<a href="https://github.com/cudpp/cudpp/issues/187" target="_blank" rel="noopener">cudpp_issues_187</a></p><h3 id="扩展cudpp哈希表"><a href="#扩展cudpp哈希表" class="headerlink" title="扩展cudpp哈希表"></a>扩展cudpp哈希表</h3><blockquote><p>修改CUDPP库中哈希功能支持更长的键类型.</p></blockquote><blockquote><p>原库支持32bit键值对,将其编码在64bit的long long类型中;我实际工作中需要对碱基序列进行哈希查找,每一个碱基可能有ACGTN五种类型,最开始只处理单barcode是10bp,所以有5^10(9765625)种可能序列,不到10M数据,在cuda中使用数组就可以了;后来需要处理双barcode,20bp,有5^20(95367431640625)种可能序列,需要约95T数据,数组显然不够,只能用哈希,因此将键类型从32bit扩展到48bit,可以支持5^20的键,剩下16bit存储值,依然编码到64bit的long long类型,达到最小改动满足需求的目的.</p></blockquote><p><a href="https://github.com/tigeroses/cudpp" target="_blank" rel="noopener">仓库地址</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;关于在cuda中使用哈希表的一些经验总结&lt;/p&gt;
&lt;h2 id=&quot;cuda中哈希方法&quot;&gt;&lt;a href=&quot;#cuda中哈希方法&quot; class=&quot;headerlink&quot; title=&quot;cuda中哈希方法&quot;&gt;&lt;/a&gt;cuda中哈希方法&lt;/h2&gt;&lt;p&gt;目前已知的在cuda中使用哈
      
    
    </summary>
    
    
    
      <category term="cuda hash cudpp" scheme="http://yoursite.com/tags/cuda-hash-cudpp/"/>
    
  </entry>
  
  <entry>
    <title>2020年计划</title>
    <link href="http://yoursite.com/2020/03/14/2020-plan/"/>
    <id>http://yoursite.com/2020/03/14/2020-plan/</id>
    <published>2020-03-14T08:37:15.000Z</published>
    <updated>2020-03-14T10:01:18.150Z</updated>
    
    <content type="html"><![CDATA[<p>把2020年给安排一下,虽然已经三月中旬了,做总比不做要好;会不定期更新调整</p><h2 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h2><ul><li>考虑整理自己的工具库. 整理提炼工作中遇到的比较通用的模块,积累自己的框架和库,以期提高开发效率</li><li>阅读开源仓库代码. 工作中很多时候是输出,把自己会的知识输出到产品中去;通过阅读开源代码,给自己充电,如果合适的话争取加入到某个开源库的开发当中,以实战来提高自己</li><li>写博客. 记录工作中遇到的问题,读书笔记,也是对生活的一个记录;坚持每周写1-2篇</li><li>技术书籍与视频. </li></ul><h2 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h2><ul><li>游泳. 一直以来都挺怕水的,去年普吉岛团建,在教练带领下进行浮潜,看海下的珊瑚和鱼真漂亮,算是克服了一重心里障碍;决定今年等疫情过去之后,花1-2个月时间学会游泳,毕竟深圳的夏天那么长</li><li>看书. 包括技术类与社科类,技术用来吃饭,社科用来拓展自己;一定要提醒自己记笔记,对每本书坚持看完不中断,不记笔记没多久就全忘记了,而看到一半不看了,等下次想起来还要从头看,心累</li><li>英语. 想着以后出国玩方便点;暂定方案是上下班班车上听英文广播,有没有效果待验证</li><li>运动. 平时早上起来运动半小时,内容是热身,俯卧撑和keep上的核心训练;周末去公园跑步,幸运的话今年再跑一次半马;看有没有时间把太极拳安排上,箱子底的太极服还是去年买的,崭新</li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="关于技术栈"><a href="#关于技术栈" class="headerlink" title="关于技术栈"></a>关于技术栈</h3><ul><li>java. 工作几年没写过java代码,最近需要对软件加速,原有代码库是java写的,目前在跟着廖雪峰老师的博客学习java基础知识</li><li>并行编程. 很实用的技术,想要用好不容易</li><li>数据库. 工作中基本没怎么用过数据库,之前偶尔接触也是很旧的Access,SQL Server,今年计划学习下MySQL或Redis</li></ul><h3 id="关于爱好"><a href="#关于爱好" class="headerlink" title="关于爱好"></a>关于爱好</h3><p>坚持长跑之外,培养其他爱好,一个是摄影,一个是写字;摄影的话买个低端相机,出去旅游的时候找找灵感,练写字一个原因也是自己字太丑了,以钢笔字为主</p><h3 id="关于娱乐"><a href="#关于娱乐" class="headerlink" title="关于娱乐"></a>关于娱乐</h3><p>工作之余,也要适当放松  </p><ul><li>美剧 <ul><li>&lt;风骚律师&gt; 这是&lt;绝命毒师&gt;前传,讲律师的成长史,评分挺高,现在第五季开始更新,我从第一季开始看,美滋滋</li></ul></li><li>动漫<ul><li>&lt;鬼灭之刃&gt; 2019年黑马之作,内容是炭治郎和妹妹祢豆子的亲情羁绊和打鬼历程,已于春节假期期间看完,在b站充了大会员</li><li>&lt;灵能百分百1.2&gt; 作者成名作是&lt;一拳超人&gt;,灵能讲异能的,口碑也不错,已于假期看完</li><li>&lt;进击的巨人4&gt; 剩下的就是等2020年上映的巨人第四季了,去年一口气把1-3看完,真的不要太爽</li></ul></li><li>小说<ul><li>&lt;升邪&gt; 修仙小说,正在看</li><li>&lt;三体&gt; 科幻巨著</li><li>心理学方面 打算看下公众号推送的心理学书籍</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;把2020年给安排一下,虽然已经三月中旬了,做总比不做要好;会不定期更新调整&lt;/p&gt;
&lt;h2 id=&quot;技术&quot;&gt;&lt;a href=&quot;#技术&quot; class=&quot;headerlink&quot; title=&quot;技术&quot;&gt;&lt;/a&gt;技术&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;考虑整理自己的工具库. 整理提炼工作
      
    
    </summary>
    
    
    
      <category term="plan" scheme="http://yoursite.com/tags/plan/"/>
    
  </entry>
  
  <entry>
    <title>解决hexo博客文章太长导致的显示不全问题</title>
    <link href="http://yoursite.com/2020/03/06/resolve-long-page-display-error/"/>
    <id>http://yoursite.com/2020/03/06/resolve-long-page-display-error/</id>
    <published>2020-03-06T10:10:51.000Z</published>
    <updated>2020-03-06T10:28:27.581Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>前两天准备发布上一篇介绍<em>CLI11</em>的文章,结果写好markdown之后本地测试发现问题:</p><ul><li>文章最后内容突然缺失</li><li>导航栏,底部的返回顶部按钮均异常</li><li>查看网页源代码,发现内容消失的地方之后内容全部是空格</li></ul><p>尝试解决问题,发现文章变短显示就正常,使用hexo新建blog,测试长文显示OK,换上同样的主题也没问题,说明是我的环境配置哪里出错.</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>折腾几天,重装hexo-xx相关库,更新hexo版本,库版本,拿出错的配置和正常的去比较,终于发现问题出现在<br><em>package.json</em>的<strong>“hexo-browsersync”: “^0.3.0”,</strong> 将这一行注释掉或者删除就OK<br>然后来到这个库的github的issues,发现不少人也遇到了这个问题,可惜我是找了好久才发现<br><a href="https://github.com/hexojs/hexo-browsersync/issues/15" target="_blank" rel="noopener">https://github.com/hexojs/hexo-browsersync/issues/15</a></p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>另外总结下其他遇到的问题</p><h3 id="hexo-server报错"><a href="#hexo-server报错" class="headerlink" title="hexo server报错"></a>hexo server报错</h3><blockquote><p>Cannot GET /</p></blockquote><p>解决方案:<code>npm audit fix</code> 查看缺少哪些模块,<code>npm install xxx</code> 安装</p><h3 id="hexo-generate报错"><a href="#hexo-generate报错" class="headerlink" title="hexo generate报错"></a>hexo generate报错</h3><blockquote><p>FATAL Something’s wrong. Maybe you can find the solution here:<a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">https://hexo.io/docs/troubleshooting.html</a><br>TypeError [ERR_INVALID_URL]: Invalid URL: <code>http://host:port/data/</code>这个网络资源上。</p></blockquote><p>经测试是某篇文章出现了<code>http://host:port/data/</code>字段,在某些版本hexo库下格式不对,<br>将其当作代码引起来就可以了.</p><h3 id="检查hexo-相关库"><a href="#检查hexo-相关库" class="headerlink" title="检查hexo 相关库"></a>检查hexo 相关库</h3><ul><li>npm install -g npm-check</li><li>npm-check</li><li>npm install -g npm-upgrade</li><li>npm-upgrade</li><li>npm install hexo –save</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h2&gt;&lt;p&gt;前两天准备发布上一篇介绍&lt;em&gt;CLI11&lt;/em&gt;的文章,结果写好markdown之后本地测试发现问题:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;文章最
      
    
    </summary>
    
    
    
      <category term="blog" scheme="http://yoursite.com/tags/blog/"/>
    
  </entry>
  
  <entry>
    <title>C++命令行解析库CLI11介绍</title>
    <link href="http://yoursite.com/2020/03/04/introduce-CLI11/"/>
    <id>http://yoursite.com/2020/03/04/introduce-CLI11/</id>
    <published>2020-03-04T12:11:12.000Z</published>
    <updated>2020-03-06T10:05:10.474Z</updated>
    
    <content type="html"><![CDATA[<p>本篇文章主要提炼自github上CLI11的官方文档,取出自己感兴趣的内容,记录下来方便以后使用</p><h2 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h2><p>CLI11是一个基于C++开发的命令行解析库,目前最新版本1.9</p><p>其优点:</p><ul><li>使用很方便,只需要<code>#include &lt;CLI11.hpp&gt;</code>,当然也可以使用cmake编译版本</li><li>跨平台,支持广泛(不需要C++11以上的版本支持)</li><li>支持subcommand;支持重复options</li></ul><p>关于编译</p><blockquote><p><code>g++ -std=c++11 xx.cpp -I path_with_CLI11 -o app</code></p></blockquote><p>(path_with_CLI11是一个路径,其内有CLI11.hpp, app是编译后的可执行程序名)</p><p>运行:</p><p>需要提示信息的时候运行<code>./app -h</code></p><h3 id="一个简单的例子"><a href="#一个简单的例子" class="headerlink" title="一个简单的例子"></a>一个简单的例子</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"CLI11.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    CLI::App app&#123;<span class="string">"App description"</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Define options</span></span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">    app.add_option(<span class="string">"-p"</span>, p, <span class="string">"Parameter"</span>);</span><br><span class="line"></span><br><span class="line">    CLI11_PARSE(app, argc, argv);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Parameter value: "</span> &lt;&lt; p &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只接受一个可选参数-p</p><p>CLI::App 是与库的所有交互的基础</p><p>CLI11_PARSE 宏内部执行app.parse(argc,argv)对命令行参数解析,出错时抛出ParseError,然后捕获异常,打印错误信息并退出程序</p><h2 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h2><h3 id="位置参数"><a href="#位置参数" class="headerlink" title="位置参数"></a>位置参数</h3><p>即必须参数,使用方法是<em>add_xxx</em>方法的第一个参数如”-a” <strong>把”-“ 去掉</strong>,换成有意义的名字,如”outputDir”<br>位置参数就是没有这些参数就无法运行,没有默认值;多个位置参数按定义顺序传递</p><h3 id="flags"><a href="#flags" class="headerlink" title="flags"></a>flags</h3><p>命令行输入只填flag名字就行,不接受参数;函数为<em>add_flag</em>,有以下三种类型:</p><ul><li><p>boolean flags</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> my_flag;</span><br><span class="line">app.add_flag(<span class="string">"-f"</span>, my_flag, <span class="string">"Optional description"</span>);</span><br></pre></td></tr></table></figure><p>  绑定flag -f 到布尔变量my_flag,默认是flase,如果用户输入了-f 则为true</p></li><li><p>integer flags</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> my_flag;</span><br><span class="line">app.add_flag(<span class="string">"-f"</span>, my_flag, <span class="string">"Optional description"</span>);</span><br></pre></td></tr></table></figure><p>  同样的绑定,范围变成整数</p></li><li><p>pure flags</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CLI::Option* my_flag = app.add_flag(<span class="string">"-f"</span>, <span class="string">"Optional description"</span>);</span><br></pre></td></tr></table></figure><p>  使用my_flag-&gt;count()来确定值是true/false,默认为0则false,大于等于1次则true;也可以bool(*my_flag)来使用</p><p>  所有add_* 格式的函数都返回CLI::Option类型,因此可以<strong>链式调用</strong>,使代码更简约</p></li><li><p>其他<br>  有callback flags,add_flag_function()可以打印每个参数输入了多少次</p></li></ul><p>每个add_*方法的第一个参数,即指定的命令参数,可以有多个名字,逗号分隔即可,如”-a,–alpha,-b”;另外一个比较有用的是-&gt;ignore_case() 方法,忽略大小写,方便用户输入</p><p>多个参数可以组合如”-i -a -b”等价于”-iab”</p><h3 id="options"><a href="#options" class="headerlink" title="options"></a>options</h3><p>与flags区别就是<strong>接受参数</strong>;函数为<em>add_option</em></p><p>基本形式:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> int_option = <span class="number">0</span>;</span><br><span class="line">app.add_option(<span class="string">"-i"</span>, int_option, <span class="string">"Optional description"</span>);</span><br></pre></td></tr></table></figure><p>其行为:绑定选项-i到int_option,解析其后的数据转换为整型,类型不对会失败;如果没有此选项则使用初始值</p><p>可接受类型包括:整型/浮点/字符串/vector/函数</p><h3 id="vectors-of-options"><a href="#vectors-of-options" class="headerlink" title="vectors of options"></a>vectors of options</h3><p>接受多个值,直到下一个值不合法;也可以用-&gt;expected(N)指定需要几个值</p><p>如果出现重复option,会进行组合,即”-v 1 2 -v 3 4”等同于”-v 1 2 3 4”(新版本才支持此功能)</p><h3 id="修改option属性"><a href="#修改option属性" class="headerlink" title="修改option属性"></a>修改option属性</h3><p>链式使用,当作装饰器,可以同时添加多个装饰</p><p>列举几个可能会常用到的:</p><ul><li>-&gt;required() 必须指定</li><li>-&gt;expected(N) 参数个数</li><li>-&gt;check(type)<ul><li>CLI::ExistingFile 检查文件是否存在</li><li>CLI::ExistingDirectory 目录是否存在</li><li>CLI::NonexistentPath 需要目录不存在</li><li>CLI::Range(min,max) 指定范围</li></ul></li></ul><h3 id="特殊选项"><a href="#特殊选项" class="headerlink" title="特殊选项:"></a>特殊选项:</h3><ul><li><em>sets</em><br>  使用集合来限定输入范围;如果输入不在集合范围内,会打印提示信息  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> val;</span><br><span class="line">app.add_set(<span class="string">"--even"</span>, val, &#123;<span class="number">0</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>&#125;);</span><br></pre></td></tr></table></figure></li><li><em>complex number</em> 复数,可接受1-2个参数,不给默认是0  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">complex</span>&lt;<span class="keyword">float</span>&gt; val;</span><br><span class="line">app.add_complex(<span class="string">"--cplx"</span>, val);</span><br></pre></td></tr></table></figure></li><li><em>optional</em> 可选参数</li><li><em>windows风格</em> /a /f …</li></ul><h3 id="Validators-验证器"><a href="#Validators-验证器" class="headerlink" title="Validators 验证器"></a>Validators 验证器</h3><p>验证器有两种形式</p><ul><li>transform 变异? 接受string,返回修改过的string</li><li>check 非变异? <ul><li>接受const string,返回修改过的string</li><li>struct CLI::Validator的子类<br>常用check来检查路径/文件是否存在,以及输入是否在一个range内</li></ul></li></ul><h2 id="subcommand-子命令"><a href="#subcommand-子命令" class="headerlink" title="subcommand 子命令"></a>subcommand 子命令</h2><p>子命令就是包含了一系列选项的一个关键字,如git commit/clone 这里面的commit clone后面还可以跟各种选项,他们就是git程序的子命令</p><p>子命令的类类型和App相同,因此可以任意嵌套</p><p>关于App的功能</p><ul><li>使用它来创建options</li><li>设置页脚,在-h下面展示,比如显示下个性签名 app.footer(“xx”)</li><li>设置帮助信息</li></ul><h3 id="添加子命令"><a href="#添加子命令" class="headerlink" title="添加子命令"></a>添加子命令</h3><p><code>CLI::App* sub = app.add_subcommand(&quot;sub&quot;, &quot;This is a subcommand&quot;);</code></p><p>第一个参数就是子命令的名字,第二个参数是描述</p><h3 id="检查子命令是否被使用"><a href="#检查子命令是否被使用" class="headerlink" title="检查子命令是否被使用"></a>检查子命令是否被使用</h3><ul><li>if(*sub) …</li><li>if(sub-&gt;parsed()) …</li><li>if(app.got_subcommand(sub)) …</li><li>if(app.got_subcommand(“sub”)) …</li></ul><p>设置必须的子命令个数,只传一个参数则限定了个数<br>app.require_subcommand(/* min <em>/ 0, /</em> max */ 1);</p><h3 id="特殊模式"><a href="#特殊模式" class="headerlink" title="特殊模式"></a>特殊模式</h3><ul><li>allow_extras() 允许出现多余的option而不报错,多余的值保存到.remaining()</li><li>fallthrough 将subcommand未匹配的option转给parnet command解析(默认不会fallthrough)</li><li>prefix command 遇到未知option时停止解析,即使其他未知选项可以匹配,也将被忽略</li></ul><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>编写个实例,把subcommand flag 各种option,check等常用功能都演示一遍</p><p>代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//把CLI11.hpp放到当前目录下</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"CLI11.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    CLI::App app&#123;<span class="string">"App description"</span>&#125;; <span class="comment">// 软件描述出现在第一行打印</span></span><br><span class="line">    app.footer(<span class="string">"My footer"</span>); <span class="comment">// 最后一行打印</span></span><br><span class="line">    app.get_formatter()-&gt;column_width(<span class="number">40</span>); <span class="comment">// 列的宽度</span></span><br><span class="line">    app.require_subcommand(<span class="number">1</span>); <span class="comment">// 表示运行命令需要且仅需要一个子命令</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> sub1 = app.add_subcommand(<span class="string">"sub1"</span>, <span class="string">"subcommand1"</span>);</span><br><span class="line">    <span class="keyword">auto</span> sub2 = app.add_subcommand(<span class="string">"sub2"</span>, <span class="string">"subcommand1"</span>);</span><br><span class="line">    sub1-&gt;fallthrough(); <span class="comment">// 当出现的参数子命令解析不了时,返回上一级尝试解析</span></span><br><span class="line">    sub2-&gt;fallthrough();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义需要用到的参数</span></span><br><span class="line">    <span class="built_in">string</span> filename;</span><br><span class="line">    <span class="keyword">int</span> threads = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> mode = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; barcodes;</span><br><span class="line">    <span class="keyword">bool</span> reverse = <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">string</span> outPath;</span><br><span class="line">    <span class="keyword">if</span> (sub1)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 第一个参数不加-, 表示位置参数,位置参数按出现的顺序来解析</span></span><br><span class="line">        <span class="comment">// 这里还检查了文件是否存在,已经是必须参数</span></span><br><span class="line">        sub1-&gt;add_option(<span class="string">"file"</span>, filename, <span class="string">"Position paramter"</span>)-&gt;check(CLI::ExistingFile)-&gt;required();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查参数必须大于0</span></span><br><span class="line">        sub1-&gt;add_option(<span class="string">"-n,-N"</span>, threads, <span class="string">"Set thread number"</span>)-&gt;check(CLI::PositiveNumber);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sub2)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 设置范围</span></span><br><span class="line">        sub2-&gt;add_option(<span class="string">"-e,-E"</span>, mode, <span class="string">"Set mode"</span>)-&gt;check(CLI::Range(<span class="number">0</span>,<span class="number">3</span>));</span><br><span class="line">        <span class="comment">// 将数据放到vector中,并限制可接受的长度</span></span><br><span class="line">        sub2-&gt;add_option(<span class="string">"-b"</span>, barcodes, <span class="string">"Barcodes info:start,len,mismatch"</span>)-&gt;expected(<span class="number">3</span>,<span class="number">6</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 添加flag,有就是true</span></span><br><span class="line">    app.add_flag(<span class="string">"-r,-R"</span>, reverse, <span class="string">"Apply reverse"</span>);</span><br><span class="line">    <span class="comment">// 检查目录是否存在</span></span><br><span class="line">    app.add_option(<span class="string">"-o"</span>, outPath, <span class="string">"Output path"</span>)-&gt;check(CLI::ExistingDirectory);</span><br><span class="line"></span><br><span class="line">    CLI11_PARSE(app, argc, argv);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断哪个子命令被使用</span></span><br><span class="line">    <span class="keyword">if</span> (sub1-&gt;parsed())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Got sub1"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"filename:"</span>&lt;&lt;filename&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"threads:"</span>&lt;&lt;threads&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (sub2-&gt;parsed())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Got sub2"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"mode:"</span>&lt;&lt;mode&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"barcodes:"</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; b : barcodes)</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;b&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>&lt;&lt;<span class="string">"Comman paras"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"reverse:"</span>&lt;&lt;reverse&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"outPath:"</span>&lt;&lt;outPath&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译:<br><code>g++ -std=c++11  run.cpp -o myapp</code></p><p>用的gcc4.8</p><p>运行:</p><p>-h 查看提示</p><p><img src="/images/introduce_CLI11/prompt2.png" alt=""></p><p><img src="/images/introduce_CLI11/prompt1.png" alt=""></p><p><img src="/images/introduce_CLI11/prompt3.png" alt=""></p><p>给正确的参数</p><p><img src="/images/introduce_CLI11/right1.png" alt=""></p><p><img src="/images/introduce_CLI11/right2.png" alt=""></p><p>给错误参数</p><p><img src="/images/introduce_CLI11/error3.png" alt=""></p><p><img src="/images/introduce_CLI11/error4.png" alt=""></p><p><img src="/images/introduce_CLI11/error1.png" alt=""></p><p><img src="/images/introduce_CLI11/error2.png" alt=""></p><p><img src="/images/introduce_CLI11/error5.png" alt=""></p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>允许读写配置文件</p><h3 id="格式化帮助信息"><a href="#格式化帮助信息" class="headerlink" title="格式化帮助信息"></a>格式化帮助信息</h3><p>允许定制自己的帮助打印信息<br>app.get_formatter() 获取当前格式</p><ul><li>column_width(width) 设置列的宽度</li><li>lable(key, value) 将lable设置一个不同的值</li><li>例子  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">app.get_formatter()-&gt;column_width(<span class="number">40</span>);</span><br><span class="line">app.get_formatter()-&gt;label(<span class="string">"REQUIRED"</span>, <span class="string">"(MUST HAVE)"</span>);</span><br></pre></td></tr></table></figure></li></ul><h3 id="subclassing"><a href="#subclassing" class="headerlink" title="subclassing"></a>subclassing</h3><p>部分的替换格式</p><h2 id="高级主题"><a href="#高级主题" class="headerlink" title="高级主题"></a>高级主题</h2><h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><p>作用是,如果命令行参数没有给定,则从环境变量中获取,如果存在的话</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> opt;</span><br><span class="line">app.add_option(<span class="string">"--my_option"</span>, opt)-&gt;envname(<span class="string">"MY_OPTION"</span>);</span><br></pre></td></tr></table></figure><h3 id="option之间的依赖-互斥关系"><a href="#option之间的依赖-互斥关系" class="headerlink" title="option之间的依赖/互斥关系"></a>option之间的依赖/互斥关系</h3><p>a-&gt;nees(b) a依赖b</p><p>a-&gt;excludes(c) a与c不共存</p><h3 id="自定义"><a href="#自定义" class="headerlink" title="自定义"></a>自定义</h3><p>custom option callbacks</p><p>custom converters</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本篇文章主要提炼自github上CLI11的官方文档,取出自己感兴趣的内容,记录下来方便以后使用&lt;/p&gt;
&lt;h2 id=&quot;简单介绍&quot;&gt;&lt;a href=&quot;#简单介绍&quot; class=&quot;headerlink&quot; title=&quot;简单介绍&quot;&gt;&lt;/a&gt;简单介绍&lt;/h2&gt;&lt;p&gt;CLI11是
      
    
    </summary>
    
    
    
      <category term="C++ CLI11 命令行解析" scheme="http://yoursite.com/tags/C-CLI11-%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>CUDA C/C++总结</title>
    <link href="http://yoursite.com/2020/03/01/CUDA-C-CPP/"/>
    <id>http://yoursite.com/2020/03/01/CUDA-C-CPP/</id>
    <published>2020-03-01T13:51:37.000Z</published>
    <updated>2020-03-05T13:31:41.823Z</updated>
    
    <content type="html"><![CDATA[<p>本篇为学习笔记,学习内容为2019年参加英伟达GTC会议的课程</p><p>需要提下学习CUDA的目的,就是为了加速自己的应用,相比于CPU-only的应用程序,可以用GPU实现较大加速,当然程序首先是计算密集型而非IO密集型</p><h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><p>GPU加速系统,又被称<strong>异构系统</strong>(Heterogeneous),由CPU和GPU组成</p><p>如果熟悉C编程,可以很快上手CUDA编程,两者在代码形式上有很多类似地方,一个比较重要概念是GPU的<em>launch kernel</em></p><p>C代码用gcc编译,cuda代码用<em>nvcc</em>编译,nvcc内部会调用gcc</p><p>启动核函数的配置 &lt;&lt;&lt;blocks,threads&gt;&gt;&gt; thread是最小执行单位,由threads组成block,多个block组成grid;kernel只能运行在一个grid</p><p>一般最简单的加速示例就是一个CPU的循环,执行简单的算术运算;主要是暗示我们什么类型的程序适合GPU加速</p><p>关于threads:</p><ul><li>每个block中的threads个数上限是1024</li><li>一个block中的threads个数由内置变量<em>blockDim.x<em>给出,多个block中计算thread索引公式为:</em>threadIdx.x + blockIdx.x * blockDim.x</em></li><li>grid中block的个数<em>gridDim.x</em>,因此一个grid的线程总数就是<em>gridDim.x * blockDim.x</em></li><li>一般一个thread一次处理一个数据</li><li>注意数据与threads个数很多时候都不是一一对应的,所以要特别注意索引越界问题;一般方式是将数组长度N传入kernel,算出thread索引,与N比较</li><li>block中的threads个数为32的倍数时最优化</li><li>当多个block的threads总数依然无法覆盖待处理数据长度时,在kernel中用loop来重复利用threads处理后续数据;如数据有2048个,线程总数只有1024,则每一个线程处理两个数据</li></ul><p>cuda6之后的版本可以分配出CPU/GPU都能访问的内存,API接口为:<em>cudaMallocManaged</em></p><p>关于异常处理:</p><ul><li>一些cuda函数的返回值类型为cudaError_t, 可用来检查错误<em>cudaGetErrorString(err)</em></li><li>无返回值的kernel, 使用<em>cudaGetLastError()</em> 返回cudaError_t类型</li><li>另外,如果有一组kernel出错,因为kernel执行是异步的,为了排查错误,可以调用同步函数如cudaDeviceSynchronize() 会返回kernel执行的错误</li><li>自己封装一个宏来进行错误检查是有必要的</li></ul><h1 id="统一内存管理"><a href="#统一内存管理" class="headerlink" title="统一内存管理"></a>统一内存管理</h1><p>迭代设计过程:</p><p>APOD:Assess Parallelize Optimize Deploy</p><p>评估-&gt;并行-&gt;优化-&gt;部署</p><p>使用Nsight命令行工具<strong>nsys</strong>来评估性能,确定优化机会</p><p>nsys基本用法: nsys profile –stats=true exe</p><p>它会生成qdrep报告,包含诸多信息:API统计,kernel执行统计,内存拷贝的大小和时间等</p><p>程序优化方法之一:更改kernel launch的<strong>配置参数</strong></p><p>Streaming Multiprocessor 流处理单元SM</p><ul><li>一个block中的threads被调度到SM上执行;多个block可以被调度到同一个SM上</li><li>为了尽可能并行,提高性能:将grid size设置为给定GPU上的SM个数的倍数,防止不对齐导致的资源浪费</li><li>SMs创建,管理,调度和执行的单位是一个block中的一组32个threads,叫做wraps;由有half-wrap的概念,16个线程为一组,更细粒度的并行</li></ul><p>为了获取SM的数量,调用API:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> deviceId;</span><br><span class="line">cudaGetDevice(&amp;deviceId);</span><br><span class="line">cudaDeviceProp props;</span><br><span class="line">cudaGetDeviceProperties(&amp;props, deviceId);</span><br><span class="line">SMs = props.multiProcessorCount;</span><br></pre></td></tr></table></figure><p>基础知识:CUDA’s Unified Memory</p><ul><li>关于Unified Memory,当UM分配之后,不管host还是device都无法访问,访问时会发生page fault,然后触发内存的迁移,将需要的数据按batches迁移</li><li>使用UM要注意避免不必要的时间开销,比如需要大的连续内存块,避免页错误</li></ul><p>Asynchronous Memory Prefetching<br>异步内存预取:减小页错误和按需内存迁移的间接开销的技术,提高性能</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cudaMemPrefetchAsync(pointerToSomeUMData, <span class="built_in">size</span>, deviceId);        <span class="comment">// Prefetch to GPU device.</span></span><br><span class="line">cudaMemPrefetchAsync(pointerToSomeUMData, <span class="built_in">size</span>, cudaCpuDeviceId); <span class="comment">// Prefetch to host. `cudaCpuDeviceId`</span></span><br></pre></td></tr></table></figure><h1 id="流异步和性能分析"><a href="#流异步和性能分析" class="headerlink" title="流异步和性能分析"></a>流异步和性能分析</h1><p>Nsight Systems 可视化的性能分析工具,其可以直接打开nsys生成的qdrep文件</p><p>Concurrent CUDA Streams 并发流;流是一系列顺序执行的命令,kernel的执行,和许多内存迁移都是发生在流内,不指定的情况下使用default stream</p><p>关于控制流的几个规则:</p><ul><li>流内的操作是顺序的</li><li>不同流内的操作相互之间不保证有任何顺序,即可认为不相关</li><li>默认流执行前会阻塞直到其他所有流都执行完成,反之亦然,默认流执行的时候其他流也被阻塞</li></ul><p>API:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cudaStream_t stream;       <span class="comment">// CUDA streams are of type `cudaStream_t`.</span></span><br><span class="line">cudaStreamCreate(&amp;stream); <span class="comment">// Note that a pointer must be passed to `cudaCreateStream`.</span></span><br><span class="line"></span><br><span class="line">someKernel&lt;&lt;&lt;number_of_blocks, threads_per_block, <span class="number">0</span>, stream&gt;&gt;&gt;(); <span class="comment">// `stream` is passed as 4th EC argument.</span></span><br><span class="line"></span><br><span class="line">cudaStreamDestroy(stream); <span class="comment">// Note that a value, not a pointer, is passed to `cudaDestroyStream`.</span></span><br></pre></td></tr></table></figure><p>第三个参数是每个block允许使用的shared memory的bytes,默认为0</p><p>profile driven and iterative 配置文件驱动和迭代</p><p>当确定数据只在device使用,最好只分配device的内存,减小数据迁移的开销,API:</p><ul><li>cudaMalloc()  only GPU</li><li>cudaMallocHost() only CPU 锁页内存,允许异步拷贝到GPU;过多的锁页内存会影响CPU性能,使用 cudaFreeHost()来释放</li><li>cudaMemcpy() device与host相互拷贝</li></ul><p>Using Streams to Overlap data transfers and code execution</p><p>只要CPU内存是锁页内存,就可以使用cudaMemcpyAsync()来进行异步拷贝,另一个条件就是使用非默认流</p><p>默认情况下GPU函数执行时对CPU函数是异步的,而异步拷贝,不仅对CPU,对GPU的kernel也是异步的,可以达到边计算边拷贝数据的目的,从而掩盖数据传输时间,尽量挖掘GPU计算能力</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本篇为学习笔记,学习内容为2019年参加英伟达GTC会议的课程&lt;/p&gt;
&lt;p&gt;需要提下学习CUDA的目的,就是为了加速自己的应用,相比于CPU-only的应用程序,可以用GPU实现较大加速,当然程序首先是计算密集型而非IO密集型&lt;/p&gt;
&lt;h1 id=&quot;基础&quot;&gt;&lt;a hre
      
    
    </summary>
    
    
    
      <category term="CUDA C" scheme="http://yoursite.com/tags/CUDA-C/"/>
    
  </entry>
  
  <entry>
    <title>windows远程桌面连接报错</title>
    <link href="http://yoursite.com/2020/03/01/windows%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2%E8%BF%9E%E6%8E%A5%E6%8A%A5%E9%94%99/"/>
    <id>http://yoursite.com/2020/03/01/windows%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2%E8%BF%9E%E6%8E%A5%E6%8A%A5%E9%94%99/</id>
    <published>2020-03-01T12:59:33.000Z</published>
    <updated>2020-03-05T13:31:41.830Z</updated>
    
    <content type="html"><![CDATA[<p>这周遇到windows远程桌面连接报错:</p><blockquote><p>出现内部错误</p></blockquote><p>个人PC与服务器处于一个局域网内,别人可以连接,只有我的不行</p><p>解决方案:经人指点,找到那台服务器,插上显示器,登录自己账号密码没问题,然后回来再使用个人PC远程连接就OK了,直接服务器登录一次就像账号激活一样</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这周遇到windows远程桌面连接报错:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;出现内部错误&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;个人PC与服务器处于一个局域网内,别人可以连接,只有我的不行&lt;/p&gt;
&lt;p&gt;解决方案:经人指点,找到那台服务器,插上显示器,登录自己账号
      
    
    </summary>
    
    
    
      <category term="windows" scheme="http://yoursite.com/tags/windows/"/>
    
  </entry>
  
  <entry>
    <title>begin_centos7</title>
    <link href="http://yoursite.com/2019/03/17/begin-centos7/"/>
    <id>http://yoursite.com/2019/03/17/begin-centos7/</id>
    <published>2019-03-17T13:46:35.000Z</published>
    <updated>2020-03-05T13:31:41.827Z</updated>
    
    <content type="html"><![CDATA[<p>本篇主要记录个人电脑安装centos及其软件过程， 以备下次需要重装系统之用。</p><h2 id="安装系统"><a href="#安装系统" class="headerlink" title="安装系统"></a>安装系统</h2><h3 id="1-下载系统安装包"><a href="#1-下载系统安装包" class="headerlink" title="1. 下载系统安装包"></a>1. 下载系统安装包</h3><p>在centos官网下载<a href="https://www.centos.org/download/" target="_blank" rel="noopener">安装包</a>, 目前最新版本是7.6， 我下载的everything版本， 约10G， 包括最全的内容， 虽然最后只装了个GUI版本。</p><h3 id="2-刻盘"><a href="#2-刻盘" class="headerlink" title="2. 刻盘"></a>2. 刻盘</h3><p>使用u盘安装的方式， 首先下载<a href="https://cn.ultraiso.net/xiazai.html" target="_blank" rel="noopener">ultroiso</a>, 可以选择免费试用版， 然后在windows系统电脑插入u盘， 打开ultroiso，加载步骤1下载的iso文件， 选择刻录到u盘启动，等待10多分钟， 启动u盘刻录完毕</p><h3 id="3-安装"><a href="#3-安装" class="headerlink" title="3. 安装"></a>3. 安装</h3><ul><li><p>插入u盘， 重启电脑， 开机过程中按<strong>F2</strong>进入<strong>BIOS</strong>， 设置启动顺序为u盘优先， 保存配置并退出</p></li><li><p>在<strong>Install Centos 7</strong>这一行按<strong>e</strong> 进入编辑模式， 将脚本中对应内容修改为</p><blockquote><p>initrd=initrd.img linux dd quiet</p></blockquote><p>  回车， 屏幕会打印设备信息， 从中可以找到u盘所对应的id， 如： <em>/sdc4</em>， 这一步是查找u盘的映射id， 因为脚本中默认的名称是错误的。</p><p>  重启之后， 继续进入编辑模式， 修改内容为</p><blockquote><p>initrd=initrd.img inst.stage2=hd:/dev/sdc4 nomodeset quiet</p></blockquote><p>  其中加入了一句 <em>nomodeset</em>, 原因是不加的话无法进入图形界面（安装过程）， 报错为 “<em>X startup failed, falling back to text mode</em>“</p></li><li><p>至此，可以通过图形界面一路点点点进行安装，我安装的是GUI版本，语言设置为英语，时区选上海</p></li></ul><h2 id="基本环境配置"><a href="#基本环境配置" class="headerlink" title="基本环境配置"></a>基本环境配置</h2><h3 id="1-语言"><a href="#1-语言" class="headerlink" title="1. 语言"></a>1. 语言</h3><p>通过快捷键切换中英文，虽然安装环境选的是英文，但是语言栏可以添加中文，很不错</p><h3 id="2-无线上网"><a href="#2-无线上网" class="headerlink" title="2. 无线上网"></a>2. 无线上网</h3><p>有线可以忽略；无线需要购买对应的无线网卡， 支持linux，最好买不用驱动安装的，插入即可使用，要不然就会知道<strong>.ko</strong>文件如何生成和使用（linux驱动文件）</p><h3 id="3-下载软件"><a href="#3-下载软件" class="headerlink" title="3. 下载软件"></a>3. 下载软件</h3><p>推荐<strong>qBittorrent</strong>, 优点是跨平台，且可以通过centos系统自带的应用程序安装器进行安装，虽然我下载速度慢的和乌龟一样</p><h3 id="4-视频播放软件"><a href="#4-视频播放软件" class="headerlink" title="4. 视频播放软件"></a>4. 视频播放软件</h3><p>自带的<strong>Videos</strong>没有解码器，无法播放视频；推荐<strong>Mplayer</strong>，代码编译，相当酸爽</p><ul><li>下载代码 <code>$ svn checkout svn://svn.mplayerhq.hu/mplayer/trunk mplayer</code> (貌似当时无法下载，找了官网换了链接OK)</li><li>更新代码 <code>$ svn update</code></li><li>依赖包<ul><li>下载 <code>$ wget http://www.mplayerhq.hu/MPlayer/releases/codecs/essential-amd64-20071007.tar.bz2</code></li><li>解压 <code>$ tar -xaf essential-amd64-20071007.tar.bz2</code></li><li>建目录 <code>$ sudo mkdir /usr/local/lib/codecs</code></li><li>拷贝 <code>$ sudo cp essential-amd64-20071007/* /usr/local/lib/codecs</code></li></ul></li><li>生成Mplayer编译所需配置 <code>$ ./configure --enable-gui --language=zh_CN</code><ul><li>依赖<a href="http://pkgs.org/download/yasm" target="_blank" rel="noopener">yasm-1.2.0-4.sdl7.x86_64.rpm</a></li><li><code>$ yum install gtk2*</code></li><li>报错就对应修改</li></ul></li><li>编译 <code>$ make</code></li><li>安装 <code>$ make install</code></li><li>安装皮肤，才能用GUI<ul><li>下载 <code>$ wget http://www.mplayerhq.hu/MPlayer/skins/Blue-1.10.tar.bz2</code></li><li>解压 <code>$ tar -xaf Blue-1.10.tar.bz2</code></li><li>复制 <code>$ sudo cp -R Blue /usr/local/share/mplayer/skins/</code></li><li>软链接 <code>$ cd /usr/local/share/mplayer/skins/</code> <code>$ sudo ln -s Blue/ default</code></li></ul></li><li>没有声音的解决方案:重新<strong>./configure</strong> 这次加上参数<em>–codecsdir=/usr/local/lib/codecs</em></li></ul><h3 id="5-markdown编辑器"><a href="#5-markdown编辑器" class="headerlink" title="5. markdown编辑器"></a>5. markdown编辑器</h3><p>推荐使用<strong>Atom</strong>，下载rpm包直接安装即可，功能强大，目前使用其来进行markdown文件的编辑，用于写博客；还可以进行代码编写等</p><h3 id="6-浏览器"><a href="#6-浏览器" class="headerlink" title="6. 浏览器"></a>6. 浏览器</h3><p>浏览器是上网的窗口，自带的firefox就很好用，不过我还是选择使用时间更久的<strong>Chrome</strong>；下载插件<strong>vimium</strong> 进行无鼠标的网页浏览操作</p><h3 id="7-配置终端"><a href="#7-配置终端" class="headerlink" title="7. 配置终端"></a>7. 配置终端</h3><p>怎么可以不用命令行？终端配置目前主要是<strong>bashrc vimrc</strong>， 另外还有键盘的重新映射，即改键，我主要是把<em>esc</em>和<em>caps</em>互换，毕竟<em>esc</em>使用频率太高了，而它离手指又太远了。<br>参考<a href="http://tigeroses.com/2016/10/21/%E6%8A%80%E5%B7%A7%E4%B8%8E%E5%B7%A5%E5%85%B701-Linux%E5%B7%A5%E4%BD%9C%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/" target="_blank" rel="noopener">技巧与工具01:Linux工作环境配置</a></p><h3 id="8-办公套件"><a href="#8-办公套件" class="headerlink" title="8. 办公套件"></a>8. 办公套件</h3><p>直接在系统自带的应用安装器中进行安装，名称为<strong>LibreOffice</strong>, 安装三个， 分别是</p><ul><li>Calc == excel</li><li>Impress == powerpoint</li><li>Writer == word</li></ul><h3 id="9-分辨率"><a href="#9-分辨率" class="headerlink" title="9. 分辨率"></a>9. 分辨率</h3><p>刚装完系统时分辨率很低，还无法设置；我的显卡是Nvidia GTX 750，在官网下载对应驱动安装之后分辨率恢复正常</p><h3 id="10-关闭主机usb供电"><a href="#10-关闭主机usb供电" class="headerlink" title="10. 关闭主机usb供电"></a>10. 关闭主机usb供电</h3><p>BIOS中Power Management 下的ErP设置为Enabled即可，主要是有时候主机关闭之后鼠标灯还亮着，强迫症真难受，关闭usb供电可以解决这个问题</p><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p>参考网上经验</p><ul><li><a href="https://www.cnblogs.com/pythonal/p/6825906.html" target="_blank" rel="noopener">U盘安装CentOS7的最终解决方案</a></li><li><a href="http://tieba.baidu.com/p/3199364641" target="_blank" rel="noopener">【14-07-31】 【总结】如何在CentOS 7上编译图形界面的Mplayer</a></li><li><a href="https://blog.csdn.net/sidely/article/details/44671257" target="_blank" rel="noopener">Centos7安装Mplayer播放器有图像没声音的解决办法</a></li><li><a href="https://zhidao.baidu.com/question/808793269006098012.html" target="_blank" rel="noopener">技嘉B85-HD3主板如何关闭关机usb供电</a></li><li><a href="https://www.cnblogs.com/libin-1/p/6638165.html" target="_blank" rel="noopener">使用Atom打造无懈可击的Markdown编辑器</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本篇主要记录个人电脑安装centos及其软件过程， 以备下次需要重装系统之用。&lt;/p&gt;
&lt;h2 id=&quot;安装系统&quot;&gt;&lt;a href=&quot;#安装系统&quot; class=&quot;headerlink&quot; title=&quot;安装系统&quot;&gt;&lt;/a&gt;安装系统&lt;/h2&gt;&lt;h3 id=&quot;1-下载系统安装包&quot;
      
    
    </summary>
    
    
    
      <category term="centos" scheme="http://yoursite.com/tags/centos/"/>
    
  </entry>
  
  <entry>
    <title>读《期货市场技术分析》下</title>
    <link href="http://yoursite.com/2018/03/05/%E8%AF%BB%E6%9C%9F%E8%B4%A7%E5%B8%82%E5%9C%BA%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90%E4%B8%8B/"/>
    <id>http://yoursite.com/2018/03/05/%E8%AF%BB%E6%9C%9F%E8%B4%A7%E5%B8%82%E5%9C%BA%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90%E4%B8%8B/</id>
    <published>2018-03-05T14:34:51.000Z</published>
    <updated>2020-03-05T13:31:41.831Z</updated>
    
    <content type="html"><![CDATA[<h2 id="交易量和持仓兴趣"><a href="#交易量和持仓兴趣" class="headerlink" title="交易量和持仓兴趣"></a>交易量和持仓兴趣</h2><p><strong>交易量</strong>：在我们所研究的基本时间单位内成交的合约总额</p><p><strong>持仓兴趣</strong>：到某日收市为止，所有未平仓了结的合约的总数</p><p>这两个是判断趋势的次要指标；但是也相当重要，比如价格的变化是需要交易量来支撑的</p><h2 id="移动平均线和摆动指数"><a href="#移动平均线和摆动指数" class="headerlink" title="移动平均线和摆动指数"></a>移动平均线和摆动指数</h2><p>将固定最近n天的平均价格数据画线，就是<strong>n日移动平均线</strong>；它是具有滞后特点的平滑工具</p><p>平均的计算方式除了基本的算术平均，还有线性加权和指数加权</p><p>期货分析者最常采用的是一条简单移动平均线；通常，价格处于横向延伸区间中时，短期移动平均线效果最佳，一旦趋势形成，长期移动平均线更为有力</p><p><strong>采用两条移动平均线</strong>：较长期者用来识别趋势，较短期者用来选择时机；<strong>两线相交法</strong>：当短期平均线向上穿越长期平均线，构成买入信号，向下穿越，构成卖出信号；<strong>中性区间法</strong>：当价格同时向上穿越两条平均线，才构成买入信号</p><p>最佳实践：根据市场的具体情况，通过优化过程，选出它的双简单移动平均线的最佳组合</p><p>移动平均线虽好，但它更适用于趋势良好的时期，不能过分依赖；在其他场合，采用非趋势顺应系统，如超买－超卖摆动指数，更合适</p><p><strong>摆动指数的用途</strong>：</p><ol><li>当摆动指数的值达到上边界或下边界的极限值时，最有意义；上边界为“超买状态”，这时候要卖出，下边界为“超卖状态”，可以买入</li><li>当摆动指数处于极限位置，并且摆动指数与价格变化之间出现了相互背离现象时，通常构成重要的预警信号</li><li>如果摆动指数顺着市场趋势的方向穿越零线，可能是重要的买卖信号</li></ol><p><strong>动力指数</strong>：价格变化的速度；按照一定的时间间隔，连续地采集价格变化的数值</p><h2 id="艾略特波浪理论"><a href="#艾略特波浪理论" class="headerlink" title="艾略特波浪理论"></a>艾略特波浪理论</h2><p>波浪理论有三个重要的方面：<strong>形态，比例和时间</strong>。重要性依次降低；形态是指波浪的形态或构造，比例分析是通过测算各个波浪之间的相互关系，来确定回撤点和价格目标，时间用来验证波浪形态和比例</p><p>归纳总结：</p><ol><li>完整的牛市周期由8浪构成，先五浪上涨，再三浪下跌</li><li>如果当前趋势与比他更高一层次的趋势方向一致，则划分为五浪结构</li><li>调整浪始终以三浪结构出现</li><li>有两种简单的调整形态：锯齿形（5-3-5）和平台型（3-3-5）</li><li>三角形通常出现在第4浪，并且总是发生在最后一浪之前；也可以出现在调整浪b浪中</li><li>既可以把波浪组合成更长的波浪，也可以把波浪细分成更短的波浪</li><li>有时某一主浪会延长，那么，另两个主浪则在时间和幅度两方面相当</li><li>斐波那契数列是艾略特波浪理论的数学基础</li><li>波浪的浪数序列服从斐波那契数列</li><li>斐波那契比数和回撤可以用来确定价格目标，最常用的回撤比例是68% 50% 38%</li><li>交替规则警示我们，不要指望同一类形态连续地出现</li><li>熊市不应当跌破前一轮牛市的第四浪的底部</li><li>4浪不可与1浪有重叠</li></ol><h2 id="自动交易系统"><a href="#自动交易系统" class="headerlink" title="自动交易系统"></a>自动交易系统</h2><p>如果用户已经掌握了技术分析的基础概念，那么使用计算机会使他如虎添翼</p><p><strong>长处</strong>：</p><ol><li>排除了人类主观情绪的影响</li><li>具有更严格的自律</li><li>能达到更高程度的协调一致性</li><li>顺着趋势方向交易</li><li>确保不错过每个顺着重要趋势的方向入市的机会</li><li>允许利润充分增长</li><li>把损失限制在一定范围</li></ol><p><strong>短处</strong>：</p><ol><li>绝大多数自动交易系统是顺应趋势的</li><li>从获利角度看，趋势顺应系统主要依赖于主要趋势</li><li>当市场无趋势可循时，趋势顺应系统一般是不盈利的</li><li>市场在相当长时间内没有趋势，而在这种阶段不适合采用趋势型方法</li></ol><h2 id="资金管理和交易策略"><a href="#资金管理和交易策略" class="headerlink" title="资金管理和交易策略"></a>资金管理和交易策略</h2><p>在任何成功的期货交易模式中，都必须考虑三方面的因素：价格预测，时机抉择和资金管理</p><p><strong>价格预测</strong>指我们所预期的未来市场的趋势方向（怎么做）</p><p><strong>交易策略</strong>确定具体的出入市时机（何时做）</p><p><strong>资金管理</strong>指资金的配置问题（多少钱做）</p><p>普遍性的资金管理要领：</p><ol><li>总投资额必须限制在全部资金的50%以内，剩下一半是储备</li><li>在任何单个市场上所投入的总资金必须限制在总资本的10%到15%以内，用来分散风险</li><li>任何单个市场上的最大总亏损金额必须限制在总资本的5%以内，即设置止损</li><li>在任何一个市场类群上所投入的保证金总额必须限制在总资本的20%－25%以内，因为同一类群的市场往往步调一致</li></ol><p>利用技术分析抉择时机：</p><ol><li>关于突破信号的策略</li><li>趋势线的突破</li><li>支撑和阻挡水平的利用</li><li>百分比回撤的利用</li><li>价格跳空的利用</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;交易量和持仓兴趣&quot;&gt;&lt;a href=&quot;#交易量和持仓兴趣&quot; class=&quot;headerlink&quot; title=&quot;交易量和持仓兴趣&quot;&gt;&lt;/a&gt;交易量和持仓兴趣&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;交易量&lt;/strong&gt;：在我们所研究的基本时间单位内成交的合约总额&lt;/p&gt;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>读《期货市场技术分析》</title>
    <link href="http://yoursite.com/2018/03/05/%E8%AF%BB%E6%9C%9F%E8%B4%A7%E5%B8%82%E5%9C%BA%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2018/03/05/%E8%AF%BB%E6%9C%9F%E8%B4%A7%E5%B8%82%E5%9C%BA%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/</id>
    <published>2018-03-05T14:23:24.000Z</published>
    <updated>2020-03-05T13:31:41.831Z</updated>
    
    <content type="html"><![CDATA[<h2 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h2><p>本书是期货分析的一本很好的入门书，读此书是为了了解交易及期货技术分析的一些名词概念</p><p>主要读的章节部分有图表和趋势分析，趋势分析的主要部分是价格形态，有反转型和持续型，交易量和持仓兴趣作为次要指标为趋势的佐证；常用工具有移动平均线和摆动指数，分别适用于趋势明朗和无趋势区间；艾略特波浪曲线是成熟的模型来分析趋势；最后是根据趋势的预测，资金管理和交易策略来进行实际的交易</p><h2 id="基础部分"><a href="#基础部分" class="headerlink" title="基础部分"></a>基础部分</h2><p><strong>技术分析</strong>是以预测市场价格变化的未来趋势为目的，以图表为主要手段对市场行为进行分析的研究</p><p><strong>市场行为</strong>包括价格，交易量和持仓兴趣</p><p><strong>理论基础</strong>：市场行为包容消化一切；价格以趋势方式演变；历史会重演。如果这三个假设不成立，技术分析也就失去意义</p><p><strong>基础分析</strong>或称价值分析，是集中考察导致价格涨，落或持平的供求关系；根据分析得来的商品的内在价值与当前价格，判断是买入还是卖出。而技术分析主要研究市场行为</p><p><strong>道氏理论</strong>是技术分析理论的起源，其基本原则：</p><ol><li>平均价格包容消化一切因素</li><li>市场具有三种趋势（主要趋势，次要趋势，短暂趋势；其趋势定义：只要相继的上冲价格波峰和波谷都对应的高过前一个波峰，波谷，那么市场就处于上升趋势中）</li><li>大趋势可分为三个阶段（积累阶段，上升阶段，见顶阶段）</li><li>各种平均价格必须相互验证</li><li>交易量必须验证趋势</li><li>市场会沿着既定趋势一直运行，直到发生确凿的反转信号</li></ol><h2 id="图表"><a href="#图表" class="headerlink" title="图表"></a>图表</h2><p>图表类型有点数图，单线图，日线图</p><p><strong>日线图</strong>做法：X轴时间，Y轴价格，将每日最高价和最低价用线段连接，并在右边引出一截为收市价；图表下方标出交易量和持仓兴趣</p><p><strong>交易量</strong>为当日在某商品市场发生的交易总额</p><p><strong>持仓兴趣</strong>为所有交易商到当日收市为止累计的未平仓合约的总数目</p><p>要做短线交易，可以使用日内线图，如5分钟线图，1小时线图等；做长期趋势分析，必须用周线图及月线图</p><h2 id="趋势"><a href="#趋势" class="headerlink" title="趋势"></a>趋势</h2><p><strong>趋势</strong>就是市场何去何从的方向，有三种方向：上升，下降和横向延伸；交易商有三种对应选择：做多，做空，不交易</p><p><strong>趋势类型</strong>：主要趋势（大于六个月）次要趋势（三个星期到数月）短暂趋势（短于三个星期）；一般来说，期货市场顺应的趋势焦点是次要趋势，短暂趋势用来选择入市的时间，如在上升趋势的回撤中建立多头头寸</p><p><strong>支撑</strong>：波谷，向上反弹低点；在此价格下方，买方兴趣强大，足以撑拒卖方形成的压力</p><p><strong>阻挡</strong>：波峰；卖方势大，价格转跌</p><p>上升趋势中，阻挡水平意味上升势头将再次稍息，迟早会被向上穿越；下降趋势中，支撑水平也不能长久；因此会出现反弹回撤，形成一系列的波；只要支撑或阻挡被穿越了，他们就会互换角色</p><p><strong>趋势线</strong>是图表分析师使用的最简便也是最有价值的基本技术工具之一；上升趋势线是沿着相继的向上反弹低点联结而成的一条直线，位于价格图像下侧，下降趋势线是沿着相继的上冲高点联结而成，位于价格上侧；要画出趋势线，至少有两个反弹点，要验证趋势线，要价格第三次触线反弹</p><p>使用趋势线：在上升趋势中，趋势线在市场下方提供的支撑边界，可以用作买进区域；下降趋势线可以用作阻挡区，达成卖出目的；假如趋势线被突破，则发出趋势生变信号，要平仓了结当前趋势建立的头寸</p><p><strong>扇形原理</strong>：当原有趋势线被突破后，做出新的趋势线，当第三条趋势线被突破，构成反转信号</p><p>趋势线的陡峭程度：倾斜角度45的趋势线最有意义；过于陡峭，表明价格上升太快无法持久，过于平缓表明趋势不太可靠</p><p><strong>管道线</strong>：在上升或下降趋势中，两个峰及两个谷画出的线组成管道线；可以进行短期平仓获利；当价格无力到达管道线，这是趋势即将有变的警讯</p><p><strong>百分比回撤</strong>：在每次重大的市场运动之后，价格总要回撤其中的一部分，然后再按照既有趋势方向继续发展</p><p><strong>速度阻挡线</strong>：测绘趋势上升或者下降的速率</p><p><strong>反转日</strong>：反转日发生在市场顶部或底部；顶部反转日：上升趋势中，某日价格达到了新的高位，但当天收市价格却低于前一天收市价</p><p><strong>价格跳空</strong>：指线图上没有发生交易的区域</p><h2 id="价格形态"><a href="#价格形态" class="headerlink" title="价格形态"></a>价格形态</h2><p>价格形态分为反转型和持续型</p><p><strong>反转形态要领</strong>：</p><ol><li>市场上事先确实有趋势存在</li><li>现行趋势即将反转的第一个信号，经常是重要的趋势线被突破</li><li>形态的规模越大，则随之而来的市场动作越大</li><li>顶部形态所经历的时间通常短于底部形态，但其波动性较强</li><li>底部形态的价格范围通常较小，但其酝酿时间较长</li><li>交易量在验证向上突破信号的可靠性方面，更具参考价值</li></ol><p>下面简要介绍常见的反转形态：</p><p><strong>头肩型</strong>：一个头，两个肩；两个肩高度近似，头比两肩高；两个波谷画出一条颈线，当收市价低于颈线，形态完成</p><p><strong>倒头肩型</strong>：头肩型底，与头肩型顶互为镜像</p><p><strong>三重顶，三重底</strong>：头肩型的变体，区别是头与肩高度近似</p><p><strong>双重顶，双重底</strong>：类似头肩型，只是只有两个峰</p><p>过滤器：过滤错误信号，以判断突破是否成立</p><p><strong>圆顶，圆底</strong>：趋势平缓的，逐渐地从下降转为横向，再由横向转为上升</p><p><strong>V形</strong>：又叫长钉形；剧烈的市场反转</p><p>接下来是持续形态，其通常用时较短暂:</p><p><strong>三角形</strong>：分为三类：对称，上升和下降；对称三角形具有两条逐渐聚拢的趋势线，上面的直线下倾，下面的直线上升，左侧做垂直线，称为底，两条直线的交点称为顶点；上升三角形下边线上倾，上边线水平；下降三角形上边线下降，下边线水平；三角形中至少有四个转折点</p><p>对称三角形结束之后通常延续既有趋势；上升三角形属于看涨形态；下降三角形属于看跌形态</p><p><strong>喇叭形</strong>：与三角形形态相反，两条线逐渐分离，为扩大三角形；此形态代表交易活动非常积极，属于看跌形态</p><p><strong>钻石形态</strong>：由扩大三角形和对称三角形组成</p><p><strong>旗形和三角旗形</strong>：通常发生在市场剧烈运动之后，代表趋势的短暂休整</p><p><strong>楔形</strong>：与三角形相似，但是其有明显的倾角；下降楔形看涨，上升楔形看跌</p><p><strong>矩形</strong>：价格在两条平行的水平直线之间横向伸展，属于趋势的修正状态</p><p>相互验证：指我们把所有技术信号和指标都加以比较参考，从而保证他们中的大部分相互验证，指向共同的方向</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;总览&quot;&gt;&lt;a href=&quot;#总览&quot; class=&quot;headerlink&quot; title=&quot;总览&quot;&gt;&lt;/a&gt;总览&lt;/h2&gt;&lt;p&gt;本书是期货分析的一本很好的入门书，读此书是为了了解交易及期货技术分析的一些名词概念&lt;/p&gt;
&lt;p&gt;主要读的章节部分有图表和趋势分析，趋势分析
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>读Effective C++</title>
    <link href="http://yoursite.com/2018/02/04/read-effective-cpp/"/>
    <id>http://yoursite.com/2018/02/04/read-effective-cpp/</id>
    <published>2018-02-04T12:04:46.000Z</published>
    <updated>2020-03-05T13:31:41.829Z</updated>
    
    <content type="html"><![CDATA[<h1 id="读Effective-C"><a href="#读Effective-C" class="headerlink" title="读Effective C++"></a>读Effective C++</h1><p>2018年一月份读书：《Effective C++：改善程序与设计的55个具体做法》</p><p>一月份利用晚上的时间粗读本书，算是对C++基础知识的复习与学习；按照章节顺序来读，前面部分较基础，后边涉及到泛型编程，看不太懂。</p><p>读完之后写下本篇，是对一月份学习的一个简要总结，督促后边继续学习，也是对本书内容进行索引总结，方便遇到具体问题快速查阅，以节省时间。</p><h2 id="内容索引"><a href="#内容索引" class="headerlink" title="内容索引"></a>内容索引</h2><p>本书共介绍C++程序设计的55个准则，作者已按照类型划分不同分类：</p><h3 id="1-基础介绍"><a href="#1-基础介绍" class="headerlink" title="1 基础介绍"></a>1 基础介绍</h3><p>通用的也是常用的准则：</p><ol><li><strong>了解C++组成</strong>。四部分：基础C, Object-Oriented C++, Template C++(泛型编程), STL(程序库)</li><li>用<strong>const, enum, inline</strong>替换#define</li><li><strong>尽可能使用const</strong>。</li><li><strong>对象被使用前先初始化</strong>。比如声明变量时就赋初值，构造函数使用成员初值列表，而不要在函数内进行赋值</li></ol><h3 id="2-类的基础方法"><a href="#2-类的基础方法" class="headerlink" title="2 类的基础方法"></a>2 类的基础方法</h3><p>主要是这几个编译器会默认给你生成的类方法：默认构造函数，析构函数，拷贝构造函数，拷贝赋值操作符</p><ol><li><strong>如果不要编译器生成的，要明确拒绝</strong>。如将方法声明为private，并且不实现</li><li><strong>为多态基类声明virtual析构函数</strong></li><li><strong>别让异常逃离析构函数</strong>。析构函数要捕获异常，要么吞下它们，要么结束程序</li><li><strong>不在构造和析构过程调用virtual函数</strong>。</li><li>*<em>令operate＝返回一个reference to *this *</em>。为了支持连等赋值</li><li><strong>在operate＝中处理自我赋值</strong>。因为可能出现删除自己，再取自己内容的情况</li><li><strong>复制对象时勿忘其每一部分</strong>。</li></ol><h3 id="3-资源管理"><a href="#3-资源管理" class="headerlink" title="3 资源管理"></a>3 资源管理</h3><p>资源包括动态内存分配，以及文件描述符，互斥锁，数据库连接，sockets等。当你不再使用它时，必须还给系统，否则会导致内存泄漏。</p><p>使用对象来管理内存，主要是使用类的构造函数，析构函数，拷贝函数。如在构造函数中获得资源，并在析构函数中释放资源。</p><ol><li><strong>小心拷贝行为</strong>。禁止拷贝，使用引用计数法</li><li><strong>提供对原始资源的访问</strong>。设计时要保留访问原始数据的接口</li><li><strong>new和delete要采用相同形式</strong>。如new delete/ new[] delete[]</li><li><strong>以独立对象将newed对象置入智能指针</strong>。智能指针会自动释放资源</li></ol><h3 id="4-设计与声明"><a href="#4-设计与声明" class="headerlink" title="4 设计与声明"></a>4 设计与声明</h3><p>作者说，软件设计是令软件作出你希望它做出的事情，以一般性的构想开始，最终演变成十足的细节，以允许特殊接口的开发。</p><p>接口的设计，要易用，不易误用。应该向开源库学习，提供的接口清晰无歧义，并尽可能考虑各种输入与异常安全。</p><ol><li><strong>设计class犹如设计type</strong>。作者提出一系列问题，是在设计高效classes时需要考虑的</li><li><strong>使用传引用替换传值</strong>。传值涉及对象的拷贝，这就需要时间与空间成本；不过对内置类型，传值可能更好</li><li><strong>必须返回对象时，不要返回reference</strong>。最怕引用指向local stack对象</li><li><strong>将成员变量声明为private</strong>。封装，划分访问控制更安全</li><li><strong>宁以non-member non-friend替换member函数</strong>。增加封装性</li><li><strong>若所有参数皆需要类型转换，请采用non-member函数</strong></li><li><strong>考虑写不抛出异常的swap函数</strong>。</li></ol><h3 id="5-实现"><a href="#5-实现" class="headerlink" title="5 实现"></a>5 实现</h3><p>设计部分完成之后就该实现了，实现部分要多考虑一些细节问题，避免降低效率，代码膨胀，过度耦合，资源泄漏等问题。</p><ol><li><strong>尽可能延后变量定义式的出现时间</strong>。防止程序提前结束，导致不必要的构造和析构</li><li><strong>少做转型动作</strong>。也是会影响效率；尽量使用新式转换(四种)</li><li><strong>避免返回handles指向对象内部成分</strong>。</li><li><strong>为异常安全努力是值得的</strong>。不泄漏资源，不允许数据败坏</li><li><strong>了解inline</strong>。会被编译器替换，免除函数调用开销，但是可能会导致代码膨胀</li><li><strong>将文件间的编译依存关系降至最低</strong>。</li></ol><h3 id="6-继承和面向对象设计"><a href="#6-继承和面向对象设计" class="headerlink" title="6 继承和面向对象设计"></a>6 继承和面向对象设计</h3><p>我感觉这是C++的精华部分，也挺重要。</p><ol><li><strong>public继承表示is－a关系</strong>。</li><li><strong>避免遮掩继承而来的名称</strong>。作用域的遮掩行为；可使用using声明式使用基类的名称</li><li><strong>区分接口继承和实现继承</strong>。选择派生类是继承基类的接口，还是接口加实现</li><li><strong>考虑virtual函数以外的其他选择</strong>。作者提供了几个方案来替代虚函数</li><li><strong>绝不重新定义继承而来的non-virtual函数以及缺省参数值</strong>。virtual函数是动态绑定</li><li><strong>通过复合塑模出has-a或根据某物实现出</strong>。</li><li><strong>明智而审慎地使用private继承和多重继承</strong>。</li></ol><h3 id="7-模板和泛型编程"><a href="#7-模板和泛型编程" class="headerlink" title="7 模板和泛型编程"></a>7 模板和泛型编程</h3><p>关于模板和泛型编程，看的不是很懂，也没仔细看，这里就先直接拷贝作者的条款，以后再看有新的理解再修改补充。</p><ol><li><strong>了解隐式接口和编译器多态</strong></li><li><strong>了解typename的双重意义</strong></li><li><strong>学习处理模板化基类内的名称</strong></li><li><strong>将与参数无关的代码抽离templates</strong></li><li><strong>运用成员函数模板接受所有兼容类型</strong></li><li><strong>需要类型转换时请为模板定义非成员函数</strong></li><li><strong>请使用traits classes表现类型信息</strong></li><li><strong>认识template元编程</strong></li></ol><h3 id="8-定制new和delete"><a href="#8-定制new和delete" class="headerlink" title="8 定制new和delete"></a>8 定制new和delete</h3><p>手动管理内存，才能获得最佳的效率。</p><ol><li><strong>了解new－handler的行为</strong>。指定函数处理分配内存失败的情况</li><li><strong>了解new delete的合理替换时机</strong>。有许多理由需要定制，包括改善效能，对heap运用错误进行调试，收集heap使用信息</li><li><strong>编写new delete时需固守常规</strong>。包括一些固有的程式，以及异常情况的处理</li><li><strong>写了placement new也要写placement delete</strong>。placement版本的new是一个特定位置上的new，一般接受一个void*,指向对象被构造之处，防止出现内存分配成功，但构造函数失败导致的内存泄漏问题</li></ol><h3 id="9-杂项"><a href="#9-杂项" class="headerlink" title="9 杂项"></a>9 杂项</h3><ol><li><strong>不要轻忽编译器的警告</strong>。有可能因为错过警告而导致复杂的调试情况</li><li><strong>熟悉标准程序库</strong>。熟悉标准程序库，相当于在编写代码时拥有各种工具组件可以挑选，方便快速开发出程序，当然可能对部分对速度有更高要求的程序不太适用，但是通用性还是很高</li><li><strong>熟悉Boost</strong>。因为标准程序库多数是从Boost中取来，Boost功能也更强一些</li></ol><h2 id="下一步"><a href="#下一步" class="headerlink" title="下一步"></a>下一步</h2><p>本书非常经典，只读一遍还远无法掌握其精髓，之后需要多看，可能不同的时期看收获也是不一样的。</p><p>接下来准备粗读下《C++标准程序库》，了解标准程序库有哪些组件，将常用的记熟，不常用的需要的时候可以快速找到即可。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;读Effective-C&quot;&gt;&lt;a href=&quot;#读Effective-C&quot; class=&quot;headerlink&quot; title=&quot;读Effective C++&quot;&gt;&lt;/a&gt;读Effective C++&lt;/h1&gt;&lt;p&gt;2018年一月份读书：《Effective C++：
      
    
    </summary>
    
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>指针的引用</title>
    <link href="http://yoursite.com/2017/11/23/%E6%8C%87%E9%92%88%E7%9A%84%E5%BC%95%E7%94%A8/"/>
    <id>http://yoursite.com/2017/11/23/%E6%8C%87%E9%92%88%E7%9A%84%E5%BC%95%E7%94%A8/</id>
    <published>2017-11-23T13:12:10.000Z</published>
    <updated>2020-03-05T13:31:41.831Z</updated>
    
    <content type="html"><![CDATA[<p>有这么一个场景：程序中某一模块在对数据进行处理，另一个模块想要将其处理的数据写入文件，这时候有两种方案，一个是通过接口将数据拷贝出来，好处是写数据到文件不影响处理数据，缺点是占用内存较大；一个是将数据的地址传递出来，这样写入文件的时候不能对数据进行处理，好处是节省内存，不用重复的分配和释放内存。</p><p>决定采用第二个方案，维护一个指向数据地址的指针，但是在编码时发现，函数直接传递指针进去，然后对指针进行赋值，这样在此函数内指针是没有问题，但函数调用结束指针还是没有指向需要的地址；最后通过传递指针的引用来解决。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdlib.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func_ref_of_pointer</span><span class="params">(<span class="keyword">float</span>* &amp;p, <span class="keyword">float</span>* data)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func_pointer</span><span class="params">(<span class="keyword">float</span>* p, <span class="keyword">float</span>* data)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// init</span></span><br><span class="line">    <span class="keyword">float</span> * data = (<span class="keyword">float</span>*)<span class="built_in">malloc</span>(<span class="number">2</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>));</span><br><span class="line">    <span class="built_in">memset</span>(data, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">float</span>)*<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">float</span> t = <span class="number">1.2</span>;</span><br><span class="line">    <span class="built_in">memcpy</span>(data, &amp;t, <span class="keyword">sizeof</span>(<span class="keyword">float</span>));</span><br><span class="line">    t = <span class="number">3.4</span>;</span><br><span class="line">    <span class="built_in">memcpy</span>(data+<span class="number">1</span>, &amp;t, <span class="keyword">sizeof</span>(<span class="keyword">float</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"data: %f %f\n"</span>, data[<span class="number">0</span>], data[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// test</span></span><br><span class="line">    <span class="keyword">float</span> * p = <span class="literal">NULL</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        func_ref_of_pointer(p, data);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//func_pointer(p, data);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"p data: %f %f\n"</span>, p[<span class="number">0</span>], p[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func_ref_of_pointer</span><span class="params">(<span class="keyword">float</span>* &amp;p, <span class="keyword">float</span>* data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    p = data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func_pointer</span><span class="params">(<span class="keyword">float</span>* p, <span class="keyword">float</span>* data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    p = data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;有这么一个场景：程序中某一模块在对数据进行处理，另一个模块想要将其处理的数据写入文件，这时候有两种方案，一个是通过接口将数据拷贝出来，好处是写数据到文件不影响处理数据，缺点是占用内存较大；一个是将数据的地址传递出来，这样写入文件的时候不能对数据进行处理，好处是节省内存，不用
      
    
    </summary>
    
    
    
      <category term="C 指针 引用" scheme="http://yoursite.com/tags/C-%E6%8C%87%E9%92%88-%E5%BC%95%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>markdown工具Mou小抄</title>
    <link href="http://yoursite.com/2017/07/03/markdown%E5%B7%A5%E5%85%B7Mou%E5%B0%8F%E6%8A%84/"/>
    <id>http://yoursite.com/2017/07/03/markdown%E5%B7%A5%E5%85%B7Mou%E5%B0%8F%E6%8A%84/</id>
    <published>2017-07-03T14:45:04.000Z</published>
    <updated>2020-03-05T13:31:41.827Z</updated>
    
    <content type="html"><![CDATA[<p>1 各级字体大小，使用＃</p><h1 id="This-is-H1"><a href="#This-is-H1" class="headerlink" title="This is H1"></a>This is H1</h1><h2 id="This-is-H2"><a href="#This-is-H2" class="headerlink" title="This is H2"></a>This is H2</h2><h3 id="This-is-H3"><a href="#This-is-H3" class="headerlink" title="This is H3"></a>This is H3</h3><h4 id="This-is-H4"><a href="#This-is-H4" class="headerlink" title="This is H4"></a>This is H4</h4><h5 id="This-is-H5"><a href="#This-is-H5" class="headerlink" title="This is H5"></a>This is H5</h5><h6 id="This-is-H6"><a href="#This-is-H6" class="headerlink" title="This is H6"></a>This is H6</h6><p>2 插入图片或链接 <strong>［］（）</strong></p><p><a href="http://www.tigeroses.com" target="_blank" rel="noopener">tigerose’s site</a></p><p>or</p><p><a href="http://www.tigeroses.com" target="_blank" rel="noopener">http://www.tigeroses.com</a></p><p>图片需要在最前面加!</p><p><img src="http://25.io/mou/Mou_128.png" alt="Mou icon"></p><p>3 字体加强及倾斜，使用＊</p><p><strong>strong</strong> not equal strong</p><p><em>emphasize</em> not equal emphasis</p><p>4 引用 &gt;</p><blockquote><p>Live or die, make your choice </p></blockquote><p>5 代码</p><p>行内代码使用 ｀｀,比如<code>$ sh run.sh</code><br>多行代码使用缩进</p><pre><code>import syssys.setdefaultencoding(&apos;utf-8&apos;)</code></pre><p>或者｀｀｀</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line">sys.setdefaultencoding(&#39;utf-8&#39;)</span><br></pre></td></tr></table></figure><p>6 列表</p><p>无序列表使用＊或者 －</p><ul><li>num1</li><li>num2</li><li>num3</li></ul><p>有序列表使用 1.</p><ol><li>num1</li><li>num2</li><li>num3</li></ol><p>7 快捷键</p><p>加强：选中文本 cmd＋B</p><p>倾斜：选中文本 cmd＋I</p><p>行内代码：选中文本 cmd＋K</p><p>选中行：shift＋cmd＋L</p><p>选中全文：cmd＋A</p><p>自动补齐：esc</p><p>导出html：option＋cmd＋e</p><p>导出pdf：option＋cmd＋p</p><p>8 后记</p><p>此篇小抄主要来自于安装Mou之后的使用说明文档，为快速上手就将<br>最简单最常用的部分摘抄过来，加深印象，Mou官网在这里<a href="http://25.io/mou/" target="_blank" rel="noopener">http://25.io/mou/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1 各级字体大小，使用＃&lt;/p&gt;
&lt;h1 id=&quot;This-is-H1&quot;&gt;&lt;a href=&quot;#This-is-H1&quot; class=&quot;headerlink&quot; title=&quot;This is H1&quot;&gt;&lt;/a&gt;This is H1&lt;/h1&gt;&lt;h2 id=&quot;This-is-H2&quot;&gt;&lt;
      
    
    </summary>
    
    
      <category term="tools" scheme="http://yoursite.com/categories/tools/"/>
    
    
      <category term="markdown" scheme="http://yoursite.com/tags/markdown/"/>
    
      <category term="macbook" scheme="http://yoursite.com/tags/macbook/"/>
    
      <category term="Mou" scheme="http://yoursite.com/tags/Mou/"/>
    
  </entry>
  
  <entry>
    <title>技巧与工具04-python控制鼠标自动化点击脚本</title>
    <link href="http://yoursite.com/2017/06/24/%E6%8A%80%E5%B7%A7%E4%B8%8E%E5%B7%A5%E5%85%B704-python%E6%8E%A7%E5%88%B6%E9%BC%A0%E6%A0%87%E8%87%AA%E5%8A%A8%E5%8C%96%E7%82%B9%E5%87%BB%E8%84%9A%E6%9C%AC/"/>
    <id>http://yoursite.com/2017/06/24/%E6%8A%80%E5%B7%A7%E4%B8%8E%E5%B7%A5%E5%85%B704-python%E6%8E%A7%E5%88%B6%E9%BC%A0%E6%A0%87%E8%87%AA%E5%8A%A8%E5%8C%96%E7%82%B9%E5%87%BB%E8%84%9A%E6%9C%AC/</id>
    <published>2017-06-24T09:04:28.000Z</published>
    <updated>2020-03-05T13:31:41.830Z</updated>
    
    <content type="html"><![CDATA[<h2 id="python控制鼠标自动化点击脚本"><a href="#python控制鼠标自动化点击脚本" class="headerlink" title="python控制鼠标自动化点击脚本"></a>python控制鼠标自动化点击脚本</h2><h3 id="事情起因"><a href="#事情起因" class="headerlink" title="事情起因"></a>事情起因</h3><p>今天是DNF九周年活动，出了新职业圣职者，为了快速升级需要获取疲劳药，可以用活动送的<br>黑钻来抽奖，每抽一次需要分别点击三次，而我能抽奖500多次，所以不想手动来点击，刚好<br>前几天在微信公众号看了一个简短的文章，是关于python的pyautogui库可以自动化键盘和鼠标<br>的操作，因此就开始动手做；台式机以前新装的系统，因此需要下载python。</p><h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><ul><li>下载 <strong>python2.7</strong> 并安装</li><li>配置python环境变量，包括python目录和scripts目录(为了pip)</li><li><strong>pip install pyautogui</strong> 安装这个控制鼠标和键盘的库</li></ul><h3 id="熟悉pyautogui库"><a href="#熟悉pyautogui库" class="headerlink" title="熟悉pyautogui库"></a>熟悉pyautogui库</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pyautogui <span class="keyword">as</span> pg <span class="comment">#导入库 </span></span><br><span class="line">pg.size() <span class="comment">#返回窗口大小，比如(1920,1080)</span></span><br><span class="line">pg.position() <span class="comment">#返回鼠标当前位置</span></span><br><span class="line">pg.moveTo(<span class="number">100</span>, <span class="number">100</span>) <span class="comment">#移动鼠标</span></span><br><span class="line">pg.click(<span class="number">100</span>, <span class="number">100</span>) <span class="comment">#移动鼠标并单击</span></span><br><span class="line">pg.press(<span class="string">'enter'</span>) <span class="comment">#按下回车键</span></span><br><span class="line">pg.keyDown(<span class="string">'esc'</span>) <span class="comment">#按下退出键</span></span><br><span class="line">pg.keyUp(<span class="string">'esc'</span>) <span class="comment">#松开退出键</span></span><br><span class="line">pg.typewrite(<span class="string">'hello'</span>) <span class="comment">#文本输入</span></span><br><span class="line">pg.dragTo(<span class="number">100</span>, <span class="number">100</span>) <span class="comment">#鼠标拖拽</span></span><br></pre></td></tr></table></figure><h3 id="脚本编写"><a href="#脚本编写" class="headerlink" title="脚本编写"></a>脚本编写</h3><p>脚本的逻辑很简单，首先10秒的时间用来让我放置鼠标到起始的位置，也就是黑钻售货机,<br>进行第一次点击;之后会进入循环，即每次点击三次，分别是按钮“启动”，“停止”，“确定”，<br>其中三次的位置均不同，但是dnf会自动将鼠标移动到下一个需要点击的位置，为了给dnf<br>这个移动的时间，中间有sleep操作。</p><p>最终抽奖完成，但是程序会一直运行下去，这时需要将鼠标移动到左上角，这样程序会抛出<br>异常，从而捕获异常，终止程序；至于为什么不用click()函数，而是用dragTo()这个鼠标<br>拖拽函数，下面会提到。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#/usr/bin/env python</span></span><br><span class="line"><span class="comment"># coding: utf-8</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pyautogui <span class="keyword">as</span> pg</span><br><span class="line"><span class="keyword">import</span> pytweening</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_click</span><span class="params">()</span>:</span></span><br><span class="line">    l_pos, r_pos =  pg.position()</span><br><span class="line">    pg.dragTo(l_pos+<span class="number">1</span>, r_pos+<span class="number">1</span>, duration = <span class="number">0.5</span>, button=<span class="string">'left'</span>)</span><br><span class="line">    sleep(<span class="number">0.1</span>)</span><br><span class="line">            </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># get current position</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"Place your mouse in the starting position within then seconds."</span></span><br><span class="line">    sleep(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        my_click()</span><br><span class="line">        times = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">            my_click()</span><br><span class="line">            my_click()</span><br><span class="line">            sleep(<span class="number">0.5</span>)</span><br><span class="line">            my_click()</span><br><span class="line">            <span class="keyword">print</span> <span class="string">"click %03d"</span> % times</span><br><span class="line">            times += <span class="number">1</span></span><br><span class="line">    <span class="keyword">except</span> pg.FailSafeException <span class="keyword">as</span> e:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"Error: %s"</span> % e</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"Over"</span></span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"Error: %s"</span> % e</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"Over"</span></span><br><span class="line">                </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h3 id="问题总结"><a href="#问题总结" class="headerlink" title="问题总结"></a>问题总结</h3><ul><li>经过测试，使用pyautogui可进行按键和文本输入，但是无法进行鼠标的单击,即click()在dnf的窗口无效</li><li>怀疑是游戏方有监控鼠标的滑行轨迹，如果是直线的就进行过滤，这应该算是防止作弊的一种手段</li><li>还好试了dragTo()，先按下鼠标再松开是可以，否则要考虑使用非直线来进行鼠标的移动，这可能要用到<br>  其他的库，pyautogui中没有找到对应的方法</li></ul><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><ul><li><a href="http://www.tuicool.com/articles/U73A7zz" target="_blank" rel="noopener">PyAutoGUI——让所有GUI都自动化</a></li><li>微信公众号 <strong>Python程序员</strong></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;python控制鼠标自动化点击脚本&quot;&gt;&lt;a href=&quot;#python控制鼠标自动化点击脚本&quot; class=&quot;headerlink&quot; title=&quot;python控制鼠标自动化点击脚本&quot;&gt;&lt;/a&gt;python控制鼠标自动化点击脚本&lt;/h2&gt;&lt;h3 id=&quot;事情起因&quot;
      
    
    </summary>
    
    
      <category term="tools" scheme="http://yoursite.com/categories/tools/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="pyautogui" scheme="http://yoursite.com/tags/pyautogui/"/>
    
  </entry>
  
  <entry>
    <title>技巧与工具03-调用百度翻译API进行中英文翻译</title>
    <link href="http://yoursite.com/2016/10/26/%E6%8A%80%E5%B7%A7%E4%B8%8E%E5%B7%A5%E5%85%B703-%E8%B0%83%E7%94%A8%E7%99%BE%E5%BA%A6%E7%BF%BB%E8%AF%91API%E8%BF%9B%E8%A1%8C%E4%B8%AD%E8%8B%B1%E6%96%87%E7%BF%BB%E8%AF%91/"/>
    <id>http://yoursite.com/2016/10/26/%E6%8A%80%E5%B7%A7%E4%B8%8E%E5%B7%A5%E5%85%B703-%E8%B0%83%E7%94%A8%E7%99%BE%E5%BA%A6%E7%BF%BB%E8%AF%91API%E8%BF%9B%E8%A1%8C%E4%B8%AD%E8%8B%B1%E6%96%87%E7%BF%BB%E8%AF%91/</id>
    <published>2016-10-26T13:30:38.000Z</published>
    <updated>2020-03-05T13:31:41.830Z</updated>
    
    <content type="html"><![CDATA[<p>工作中有时会遇到需要中英文互相翻译的情况，词数少的话可以手动使用翻译软件进行<br>翻译，如果量很大，编写程序自动翻译会是个更好的选择．</p><a id="more"></a><p>本篇使用python编写脚本调用百度翻译API进行自动化翻译，依次读取文本文件的每一行，<br>翻译之后输出到结果文件中．</p><h2 id="百度翻译API"><a href="#百度翻译API" class="headerlink" title="百度翻译API"></a>百度翻译API</h2><p>当需要进行自动化翻译的时候，首先想到谷歌翻译，毕竟是公认的翻译最准确的平台，<br>在网上找到脚本实验，使用的是http请求来调用<a href="http://translate.google.cn/" target="_blank" rel="noopener">谷歌翻译</a>的主页，程序填入字段从而<br>获取到翻译后的结果，测试发现不可行，无法抓取翻译后的内容，查看网页源代码发现<br>应该是谷歌将结果放到其他位置而不是当前页面;谷歌到也提供翻译API，不过收费的，<br>暂时不考虑．</p><p>然后自然找到了百度翻译,其翻译平台在这里:<a href="http://api.fanyi.baidu.com/api/trans/product/index" target="_blank" rel="noopener">百度翻译开放平台</a>.<br>它的好处就是每个月翻译字数低于200万是免费的，超过了再收费，对我这种偶尔翻译<br>下的人来说，基本是可以免费使用了．</p><p>使用前需要在主页点击<em>申请接入</em>，进行注册，它会给APPID和密钥，这些东西是之后<br>调用API翻译必须要得．官方文档有详细的使用说明和示例，不多说，直接上我的脚本的代码．</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># translate_en2zh.py</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#/usr/bin/env python</span></span><br><span class="line"><span class="comment">#coding=utf8</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> httplib</span><br><span class="line"><span class="keyword">import</span> md5</span><br><span class="line"><span class="keyword">import</span> urllib</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">reload(sys)</span><br><span class="line">sys.setdefaultencoding(<span class="string">'utf-8'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">trans_line</span><span class="params">(line, fromLang, toLang)</span>:</span></span><br><span class="line">    result = []</span><br><span class="line"></span><br><span class="line">    <span class="comment"># replace with your id and key</span></span><br><span class="line">    appid = <span class="string">''</span></span><br><span class="line">    secretKey = <span class="string">''</span></span><br><span class="line"></span><br><span class="line">    httpClient = <span class="literal">None</span></span><br><span class="line">    myurl = <span class="string">'/api/trans/vip/translate'</span></span><br><span class="line">    q = line</span><br><span class="line">    salt = random.randint(<span class="number">32768</span>, <span class="number">65536</span>)</span><br><span class="line"></span><br><span class="line">    sign = appid+q+str(salt)+secretKey</span><br><span class="line">    m1 = md5.new()</span><br><span class="line">    m1.update(sign)</span><br><span class="line">    sign = m1.hexdigest()</span><br><span class="line">    myurl = myurl+<span class="string">'?appid='</span>+appid+<span class="string">'&amp;q='</span>+urllib.quote(q)+<span class="string">'&amp;from='</span>+fromLang+<span class="string">'&amp;to='</span>+toLang+<span class="string">'&amp;salt='</span>+str(salt)+<span class="string">'&amp;sign='</span>+sign</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        httpClient = httplib.HTTPConnection(<span class="string">'api.fanyi.baidu.com'</span>)</span><br><span class="line">        httpClient.request(<span class="string">'GET'</span>, myurl)</span><br><span class="line">     </span><br><span class="line">        <span class="comment">#response是HTTPResponse对象</span></span><br><span class="line">        response = httpClient.getresponse()</span><br><span class="line">        jsonData = json.loads(response.read())</span><br><span class="line">        <span class="comment"># print jsonData</span></span><br><span class="line">        result.append(jsonData[<span class="string">'trans_result'</span>][<span class="number">0</span>][<span class="string">'src'</span>])</span><br><span class="line">        result.append(jsonData[<span class="string">'trans_result'</span>][<span class="number">0</span>][<span class="string">'dst'</span>])</span><br><span class="line">    <span class="keyword">except</span> Exception, e:</span><br><span class="line">        <span class="keyword">print</span> e</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        <span class="keyword">if</span> httpClient:</span><br><span class="line">            httpClient.close()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    fromLang = <span class="string">'en'</span></span><br><span class="line">    toLang = <span class="string">'zh'</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> len(sys.argv) != <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"Enter a file name: "</span></span><br><span class="line">        exit()</span><br><span class="line"></span><br><span class="line">    filename = sys.argv[<span class="number">1</span>]</span><br><span class="line">    tmp = filename.split(<span class="string">"."</span>)</span><br><span class="line">    <span class="keyword">if</span> len(tmp) != <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"Error filename"</span></span><br><span class="line">        exit()</span><br><span class="line">    out_name = tmp[<span class="number">0</span>] + <span class="string">'_en2zh.'</span> + tmp[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    translated_list = []</span><br><span class="line">    <span class="keyword">with</span> open(filename, <span class="string">'r'</span>) <span class="keyword">as</span> fh_in:</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> fh_in:</span><br><span class="line">            line = line.strip()</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> line: <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            translated_list.append(trans_line(line, fromLang, toLang))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> open(out_name, <span class="string">'w'</span>) <span class="keyword">as</span> fh_out:</span><br><span class="line">        <span class="keyword">for</span> line_result <span class="keyword">in</span> translated_list:</span><br><span class="line">            <span class="comment">#fh_out.write(line_result[1].encode("GBK") + "\n")</span></span><br><span class="line">            fh_out.write(line_result[<span class="number">1</span>] + <span class="string">"\n"</span>)</span><br></pre></td></tr></table></figure><p>测试文本<em>en.txt</em>如下，功率相关的英文．</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Active power P</span><br><span class="line">Reactive power Q</span><br><span class="line">Apparent power S</span><br><span class="line">Power factoer</span><br></pre></td></tr></table></figure><p>命令行输入:<code>python translate_en2zh.py en.txt</code>,没有任何输出则运行成功．</p><p>打开新生成的<em>en_en2zh.txt</em>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">有功功率P</span><br><span class="line">无功功率Q</span><br><span class="line">视在功率S</span><br><span class="line">功率因素</span><br></pre></td></tr></table></figure><p>翻译完全正确．</p><p>可以在<a href="http://api.fanyi.baidu.com/api/trans/product/desktop" target="_blank" rel="noopener">管理控制台</a>查看使用字符的详细情况</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;工作中有时会遇到需要中英文互相翻译的情况，词数少的话可以手动使用翻译软件进行&lt;br&gt;翻译，如果量很大，编写程序自动翻译会是个更好的选择．&lt;/p&gt;
    
    </summary>
    
    
      <category term="tools" scheme="http://yoursite.com/categories/tools/"/>
    
    
      <category term="自动化翻译" scheme="http://yoursite.com/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>技巧与工具02-MFC字符串相关</title>
    <link href="http://yoursite.com/2016/10/24/%E6%8A%80%E5%B7%A7%E4%B8%8E%E5%B7%A5%E5%85%B702-MFC%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%85%B3/"/>
    <id>http://yoursite.com/2016/10/24/%E6%8A%80%E5%B7%A7%E4%B8%8E%E5%B7%A5%E5%85%B702-MFC%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%85%B3/</id>
    <published>2016-10-24T12:22:47.000Z</published>
    <updated>2020-03-05T13:31:41.830Z</updated>
    
    <content type="html"><![CDATA[<p>此篇主要总结了Windows下MFC编程字符串相关的一些知识，如CString, CStringList等的使用．</p><a id="more"></a><p>纯粹为了自己平时查找方便;相关内容均来自网络,链接附在文末．侵删．</p><h2 id="CString"><a href="#CString" class="headerlink" title="CString"></a>CString</h2><p>MFC下最好用的字符串类应该就是CString了．CString是MFC中的一个类，包含了许多好用的操作如<br>格式化，查找，计算长度等．</p><p>要使用CString,需要在工程引用头文件：<code>#include &lt;afx.h&gt;</code>,一般放到<code>stdafx.h</code>预编译头中．<br>另外需要在项目属性中选择＂在共享DLL中使用MFC＂.</p><p>以前有项目在VC6.0,后来迁移到VS2013,刚开始关于CString大量报错，发现是不同平台字符<br>编码的问题，从网上下载<code>Multibyte MFC Library for Visual Studio 2013</code>,安装之后，选择<br>多字节编码而非Unicode,即没有编码问题，CString也可以自由使用．</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// use_CString.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line">CString s;</span><br><span class="line"><span class="function">CString <span class="title">s</span><span class="params">(<span class="string">"hello"</span>)</span></span>;</span><br><span class="line">CString s = <span class="string">"hello"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> c[] = <span class="string">"hello"</span>;</span><br><span class="line">CString s = <span class="string">""</span>;</span><br><span class="line">s.Format(<span class="string">"%s"</span>, c);</span><br><span class="line"></span><br><span class="line">CString s = <span class="string">"hello"</span>;</span><br><span class="line"><span class="comment">// 长度</span></span><br><span class="line"><span class="comment">// 注意：英文每个字符占一个长度，中文每个占两个长度</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>, s.GetLength());    <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 反转</span></span><br><span class="line">s.MakeReverse();    <span class="comment">// "olleh"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 转换大小写</span></span><br><span class="line">s.MakeUpper();      <span class="comment">// "HELLO"</span></span><br><span class="line">s.MakeLower();      <span class="comment">// "hello"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入　删除</span></span><br><span class="line">s.Insert(<span class="number">2</span>, <span class="string">"a"</span>);   <span class="comment">// "heallo"</span></span><br><span class="line">s.Delete(<span class="number">3</span>, <span class="number">2</span>);     <span class="comment">// "hel"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 替换与移除指定字符</span></span><br><span class="line">s.Replace(<span class="string">"ll"</span>, <span class="string">"yy"</span>);  <span class="comment">// "heyyo"</span></span><br><span class="line">s.Remove(<span class="string">'l'</span>);          <span class="comment">// "heo"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 去除左右两边空格</span></span><br><span class="line"><span class="comment">// 一般从文件读取字符串，都会先去除两端空格，防止读取无意义数据</span></span><br><span class="line">s.TrimLeft();   <span class="comment">// 默认去除左端空格</span></span><br><span class="line">s.TrimRight(<span class="string">"a"</span>);  <span class="comment">// 去除右端的任意多个"a"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 清空字符串以及判断字符串是否为空</span></span><br><span class="line"><span class="comment">// 判断是否为空也常用于读取文件</span></span><br><span class="line">s.Empty();</span><br><span class="line">s.IsEmpty();    <span class="comment">// 为空时返回0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找</span></span><br><span class="line">s.Find(<span class="string">'e'</span>);    <span class="comment">// 1</span></span><br><span class="line">s.Find('ll');   // 2</span><br><span class="line">s.Find(<span class="string">'e'</span>, <span class="number">1</span>); <span class="comment">// 0</span></span><br><span class="line">s.Find(<span class="string">'a'</span>);    <span class="comment">// 找不到返回-1</span></span><br><span class="line">s.ReverseFind(<span class="string">'e'</span>); <span class="comment">// 反向查找，即先反向再查找，3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 格式化</span></span><br><span class="line">s.Format(<span class="string">"%d"</span>, <span class="number">2</span>);  <span class="comment">// "2"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 取值与赋值</span></span><br><span class="line">s.GetAt(<span class="number">2</span>); <span class="comment">// "l"如果索引越界，会出异常</span></span><br><span class="line">s.SetAt(<span class="number">2</span>, <span class="string">'h'</span>);    <span class="comment">// "hehlo"</span></span><br><span class="line"></span><br><span class="line">s.Left(<span class="number">2</span>);  <span class="comment">// "he"</span></span><br><span class="line">s.Right(<span class="number">2</span>);  <span class="comment">// "lo"</span></span><br><span class="line">s.Mid(<span class="number">2</span>, <span class="number">2</span>);    <span class="comment">// "ll"</span></span><br><span class="line">s.Mid(<span class="number">2</span>);   <span class="comment">// "llo"</span></span><br></pre></td></tr></table></figure><h2 id="CString与其他类型互转"><a href="#CString与其他类型互转" class="headerlink" title="CString与其他类型互转"></a>CString与其他类型互转</h2><p>CString常用于MFC,安全性高，但可移植性差<br>string常用于STL<br>char * 常用于API的输入参数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// convert_CString.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1 CString 与　char *</span></span><br><span class="line">CString s = <span class="string">"hello"</span>;</span><br><span class="line"><span class="keyword">char</span> *p = (LPSTR)(LPCTSTR)s;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> p[] = <span class="string">"world"</span>;</span><br><span class="line">s.Format(<span class="string">"%s"</span>, p);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2 CString 与　string</span></span><br><span class="line">CString s;</span><br><span class="line"><span class="built_in">string</span> str = <span class="string">"hello"</span>;</span><br><span class="line">s.Format(<span class="string">"%s"</span>, str.c_str());</span><br><span class="line"></span><br><span class="line">CString s = <span class="string">"hello"</span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">str</span><span class="params">(s.GetBuffer())</span></span>; <span class="comment">// string 类型无法用printf打印</span></span><br><span class="line">CString.ReleaseBuffer();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3 char 与　string</span></span><br><span class="line"><span class="keyword">char</span> p[] = <span class="string">"hello"</span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">str</span><span class="params">(p)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *c = str.c_str();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4 CString 与　int</span></span><br><span class="line"><span class="keyword">int</span> i = atoi(s); <span class="comment">// 转换浮点用atof</span></span><br><span class="line"><span class="keyword">int</span> i = _ttoi(s);</span><br><span class="line"></span><br><span class="line">CString.Format(<span class="string">"%d"</span>, i);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5 CString 与　char[100]</span></span><br><span class="line"><span class="keyword">char</span> a[<span class="number">100</span>];</span><br><span class="line"><span class="function">CString <span class="title">s</span><span class="params">(<span class="string">"abc"</span>)</span></span>;</span><br><span class="line"><span class="built_in">strncpy</span>(a, (LPCTSTR)s, <span class="keyword">sizeof</span>(a)); <span class="comment">// vs2013报错，需要用strncpy_s</span></span><br></pre></td></tr></table></figure><h2 id="CStringList"><a href="#CStringList" class="headerlink" title="CStringList"></a>CStringList</h2><p>CStringList是MFC中定义的用于存储CString字符串的链表</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// use_CStringList.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造</span></span><br><span class="line">CStringList str_list;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加删除元素</span></span><br><span class="line">str_list.AddHead(<span class="string">"123"</span>);    <span class="comment">//在列表头部添加元素</span></span><br><span class="line">str_list.AddTail(<span class="string">"123"</span>);    <span class="comment">//在列表尾部添加元素</span></span><br><span class="line"></span><br><span class="line">str_list.InsertBefor(POSITION pos, <span class="string">"123"</span>);     <span class="comment">// 在给定位置前插入新元素</span></span><br><span class="line">str_list.InsertAfter(POSITION pos, <span class="string">"123"</span>);     <span class="comment">// 在给定位置后插入新元素</span></span><br><span class="line"></span><br><span class="line">str_list.RemoveHead();      <span class="comment">// 分别时删除头，尾，所有元素</span></span><br><span class="line">str_list.RemoveTail();</span><br><span class="line">str_list.RemoveAll();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问</span></span><br><span class="line">str_list.GetHead();         <span class="comment">// 获取头，尾部元素</span></span><br><span class="line">str_list.GetTail();</span><br><span class="line"></span><br><span class="line">str_list.GetAt(POSITION pos);           <span class="comment">// 获取指定位置的元素</span></span><br><span class="line">str_list.SetAt(POSITION pos);           <span class="comment">// 设置指定位置的元素</span></span><br><span class="line">str_list.RemoveAt(POSITION pos);        <span class="comment">// 删除指定位置的元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历所用</span></span><br><span class="line">str_list.GetHeadPosition(); <span class="comment">// 获取头部，尾部元素所在位置</span></span><br><span class="line">str_list.GetTailPosition();</span><br><span class="line"></span><br><span class="line">str_list.GetNext(POSITION pos);         <span class="comment">// 获取下一个元素</span></span><br><span class="line">str_list.GetPrev(POSITION pos);         <span class="comment">// 获取前一个元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找</span></span><br><span class="line">POSITION pos = str_list.Find(<span class="string">"123"</span>);            <span class="comment">// 获取由字符串指定的元素的位置</span></span><br><span class="line">POSITION pos = str_list.FindIndex(<span class="keyword">int</span> i);       <span class="comment">// 获取由索引指定的元素的位置</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 状态</span></span><br><span class="line">str_list.GetCount();        <span class="comment">// 返回元素个数</span></span><br><span class="line">str_list.IsEmpty();          <span class="comment">// 测试列表是否为空</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历</span></span><br><span class="line">POSITION pos;</span><br><span class="line">pos = str_list.GetHeadPosition();</span><br><span class="line"><span class="keyword">while</span> (pos != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">    CString s = str_list.GetNext(pos);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s"</span>, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p>1 <a href="http://jingyan.baidu.com/article/9989c7461eac5ef648ecfef9.html" target="_blank" rel="noopener">如何解决VC6迁移到VS2013时出现的error MSB8031</a><br>2 <a href="http://blog.csdn.net/shuixin536/article/details/5899016" target="_blank" rel="noopener">VS2008下非MFC工程使用CString类库</a><br>3 <a href="http://www.cnblogs.com/Caiqinghua/archive/2009/02/16/1391190.html" target="_blank" rel="noopener">CString 成员函数用法大全</a><br>4 <a href="http://blog.csdn.net/netist/article/details/4091421" target="_blank" rel="noopener">CString转换为LPCSTR方法补充</a><br>5 <a href="http://blog.csdn.net/tahelin/article/details/32344615" target="_blank" rel="noopener">CString Format函数 VS2013</a><br>6 <a href="http://blog.csdn.net/huihui0121/article/details/5804446" target="_blank" rel="noopener">CString转char *,strings</a><br>7 <a href="http://blog.csdn.net/sunnylgz/article/details/6677103" target="_blank" rel="noopener">C语言中string函数详解</a><br>8 <a href="http://www.cppblog.com/Mumoo/archive/2013/04/15/199460.aspx" target="_blank" rel="noopener">CSTRINGLIST用法</a><br>9 <a href="http://www.cnblogs.com/bluestorm/p/3168720.html" target="_blank" rel="noopener">CString,string,char *之间的转换</a><br>10 <a href="http://blog.sina.com.cn/s/blog_5fa918660101axuf.html" target="_blank" rel="noopener">MFC CString 和int相互转化</a></p><p>感谢网上的朋友！</p><h2 id="一个小问题"><a href="#一个小问题" class="headerlink" title="一个小问题"></a>一个小问题</h2><p>写这篇总结的时候，最后附录有十个链接，我在本地localhost测试，这十个链接只能显示六个,<br>而且每次刷新出来的页面还都不一样，看网页代码最后部分是乱码，改改markdown中的[]与()<br>之间加了空格，偶尔会正常出来十个链接，再刷新又没有了，最后deploy到github又显示正常．<br>暂时没有找到原因，先记下来问题，之后再处理．</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;此篇主要总结了Windows下MFC编程字符串相关的一些知识，如CString, CStringList等的使用．&lt;/p&gt;
    
    </summary>
    
    
      <category term="tools" scheme="http://yoursite.com/categories/tools/"/>
    
    
      <category term="MFC" scheme="http://yoursite.com/tags/MFC/"/>
    
      <category term="CString" scheme="http://yoursite.com/tags/CString/"/>
    
  </entry>
  
  <entry>
    <title>技巧与工具01:Linux工作环境配置</title>
    <link href="http://yoursite.com/2016/10/21/%E6%8A%80%E5%B7%A7%E4%B8%8E%E5%B7%A5%E5%85%B701-Linux%E5%B7%A5%E4%BD%9C%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2016/10/21/%E6%8A%80%E5%B7%A7%E4%B8%8E%E5%B7%A5%E5%85%B701-Linux%E5%B7%A5%E4%BD%9C%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</id>
    <published>2016-10-21T03:19:55.000Z</published>
    <updated>2020-03-05T13:31:41.830Z</updated>
    
    <content type="html"><![CDATA[<p>个人电脑系统是Ubuntu,也因为Linux环境工作效率更高，比较偏爱Linux系统，<br>平时写代码主要使用Vim,故总结出工作环境的简单配置．</p><a id="more"></a><p>本篇所有的配置文件都已上传至github: <a href="https://github.com/tigerRose/experience.git" target="_blank" rel="noopener">https://github.com/tigerRose/experience.git</a> 可以直接拷贝到个人目录使用.</p><h2 id="bashrc"><a href="#bashrc" class="headerlink" title="~/.bashrc"></a>~/.bashrc</h2><p>这个是Linux最主要的配置文件之一了．</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ~/.bashrc</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$TERM</span>=<span class="string">"xterm-256color"</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    PS1=<span class="string">'\[\033[01;38;5;61m\]\u@\h\[\033[01;38;5;107m\] \w\n\$\[\033[01;38;5;248m\]'</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">LS_OPTIONS=<span class="string">'--color'</span></span><br><span class="line"><span class="built_in">export</span> LS_OPTIONS</span><br><span class="line"></span><br><span class="line"><span class="built_in">alias</span> ls=<span class="string">"ls <span class="variable">$LS_OPTIONS</span>"</span></span><br><span class="line"><span class="built_in">alias</span> l=<span class="string">"ls -lh"</span></span><br><span class="line"><span class="built_in">alias</span> ll=<span class="string">"ls -l"</span></span><br><span class="line"><span class="built_in">alias</span> la=<span class="string">'ls -alh'</span></span><br><span class="line"><span class="built_in">alias</span> c7=<span class="string">'chmod 777'</span></span><br><span class="line"><span class="built_in">alias</span> c5=<span class="string">'chmod 755'</span></span><br><span class="line"><span class="built_in">alias</span> c4=<span class="string">'chmod 644'</span></span><br><span class="line"><span class="built_in">alias</span> c0=<span class="string">'chmod 700'</span></span><br><span class="line"><span class="built_in">alias</span> c0f=<span class="string">'chmod 600'</span></span><br><span class="line"><span class="built_in">alias</span> dh=<span class="string">'du -h'</span></span><br><span class="line"><span class="built_in">alias</span> eb=<span class="string">'vi ~/.bashrc'</span></span><br><span class="line"><span class="built_in">alias</span> ep=<span class="string">'vi ~/.bash_profile'</span></span><br><span class="line"><span class="built_in">alias</span> sb=<span class="string">'source ~/.bashrc '</span></span><br><span class="line"><span class="built_in">alias</span> h=<span class="string">'head'</span></span><br><span class="line"><span class="built_in">alias</span> k9=<span class="string">'kill -9'</span></span><br><span class="line"><span class="built_in">alias</span> les=<span class="string">"less -RS"</span></span><br><span class="line"><span class="built_in">alias</span> le=<span class="string">'les'</span></span><br><span class="line"><span class="built_in">alias</span> ln=<span class="string">'ln -s'</span></span><br><span class="line"><span class="built_in">alias</span> wl=<span class="string">"wc -l"</span></span><br><span class="line"><span class="built_in">alias</span> a=<span class="string">"cd .. &amp;&amp; l"</span></span><br><span class="line"><span class="built_in">alias</span> b=<span class="string">'cd - &amp;&amp; l'</span></span><br><span class="line"><span class="built_in">alias</span> pp=<span class="string">"pu <span class="variable">$USER</span>"</span></span><br><span class="line"><span class="built_in">alias</span> i=<span class="string">'dirs -c &amp;&amp; pushd .'</span></span><br><span class="line"><span class="built_in">alias</span> o=<span class="string">'dirs -c'</span></span><br><span class="line"><span class="built_in">alias</span> p=<span class="string">'pushd'</span></span><br><span class="line"><span class="built_in">alias</span> rd=<span class="string">"rm -rf"</span></span><br><span class="line"><span class="built_in">alias</span> t=<span class="string">"tail"</span></span><br><span class="line"><span class="built_in">alias</span> vi=<span class="string">"/usr/bin/vim"</span></span><br><span class="line"><span class="built_in">alias</span> py=<span class="string">"python"</span></span><br></pre></td></tr></table></figure><p>~/.bashrc主要是配置终端显示以及设置一些常用命令的重命名，减少频繁使用<br>的命令的按键次数，也可以指定所使用的程序，如<code>alias python=&quot;C:\python27\python.exe&quot;</code><br>这个就是我在windows系统下使用cygwin环境，调用windows安装的python的方法．<br>另外可以在这里加一些环境变量，如<code>export PYTHONPATH=&quot;xxx&quot;$PYTHONPATH</code></p><h2 id="git-completion-bash"><a href="#git-completion-bash" class="headerlink" title="~/.git-completion.bash"></a>~/.git-completion.bash</h2><p>这个文件在网上可以下载，主要功能如名称所示，git的命令行补全，如输入:<br><code>git ch&lt;tab&gt;</code> 会出现<code>checkout　cherry　cherry-pick</code>供参考．使用前需要将如下<br>几行代码添加到~/.bashrc</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ~/.git-completion.bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># set git auto completion</span></span><br><span class="line"><span class="keyword">if</span> [ -f ~/.git-completion.bash ]; <span class="keyword">then</span></span><br><span class="line">    . ~/.git-completion.bash</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>然后输入命令source ~/.bashrc即可生效</p><h2 id="gitconfig"><a href="#gitconfig" class="headerlink" title="~/.gitconfig"></a>~/.gitconfig</h2><p>此文件是git的简单配置，如用户名和邮箱</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ~/.gitconfig</span></span><br><span class="line"></span><br><span class="line">[user]</span><br><span class="line">email = fuxiang_zhao@163.com</span><br><span class="line">name = tigerRose</span><br><span class="line">[push]</span><br><span class="line">default = matching</span><br></pre></td></tr></table></figure><h2 id="keymaprc"><a href="#keymaprc" class="headerlink" title="~/.keymaprc"></a>~/.keymaprc</h2><p>这个是我自己定义的，用于交换键盘的按键，比如你某个键坏掉了，可以用一个平时不<br>常用的键来交换，土豪可以无视，直接买新的．我使用按键交换主要是因为习惯用Vim,<br>而又常用Esc,不常用Caps Lock,因此交换按键，减少手指运动量.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ~/.keymaprc</span></span><br><span class="line"></span><br><span class="line">remove Lock = Caps_Lock</span><br><span class="line">keysym Caps_Lock = Escape</span><br><span class="line">keysym Escape = Caps_Lock NoSymbol Caps_Lock</span><br></pre></td></tr></table></figure><p><a href="http://tigerrose.me/2016/03/27/linux%E6%9B%B4%E6%94%B9%E9%94%AE%E7%9B%98%E6%98%A0%E5%B0%84/" target="_blank" rel="noopener">linux更改键盘映射</a>这个专门讲Linux环境改按键</p><h2 id="vimrc"><a href="#vimrc" class="headerlink" title="~/.vimrc"></a>~/.vimrc</h2><p>此文件是Vim的配置，个人比较喜欢的风格</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"~/.vimrc</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">set nocompatible    "</span>Use Vim settings, rather <span class="keyword">then</span> Vi settings (much better!).</span><br><span class="line">syntax on           <span class="string">"show syntax</span></span><br><span class="line"><span class="string">set nu              "</span>show line number</span><br><span class="line"><span class="built_in">set</span> tabstop=4       <span class="string">"&lt;tab&gt; width</span></span><br><span class="line"><span class="string">filetype plugin indent on</span></span><br><span class="line"><span class="string">set autoindent      "</span><span class="built_in">set</span> automatic indent</span><br><span class="line"><span class="built_in">set</span> smartindent cinwords=<span class="keyword">if</span>,<span class="keyword">elif</span>,<span class="keyword">else</span>,<span class="keyword">for</span>,<span class="keyword">while</span>,try,except,finally,def,class</span><br><span class="line"><span class="built_in">set</span> softtabstop=4   </span><br><span class="line"><span class="built_in">set</span> expandtab       </span><br><span class="line"><span class="built_in">set</span> ruler</span><br><span class="line"><span class="built_in">set</span> shiftwidth=4    <span class="string">"autoindent width</span></span><br><span class="line"><span class="string">set cindent         "</span>C style indent</span><br><span class="line"><span class="built_in">set</span> sm              <span class="string">"show matched bracket</span></span><br><span class="line"><span class="string">set smarttab</span></span><br><span class="line"><span class="string">set fileformats=unix</span></span><br><span class="line"><span class="string">set backspace=indent,eol,start</span></span><br><span class="line"><span class="string">set incsearch</span></span><br><span class="line"><span class="string">set fencs=utf-8,ucs-bom,euc-jp,gb18030,gbk,gb2312,cp936 "</span><span class="built_in">set</span> coding</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> t_Co=256 <span class="string">"Use 256 color</span></span><br><span class="line"><span class="string">colorscheme lucius "</span><span class="built_in">set</span> ColorScheme</span><br><span class="line"><span class="built_in">set</span> viminfo=<span class="string">'1000,&lt;800</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">"return the position last edit</span></span><br><span class="line"><span class="string">au BufReadPost * if line("'</span>\"<span class="string">") &gt; 0|if line("</span><span class="string">'\"") &lt;= line("$")|exe("norm '</span>\"<span class="string">")|else|exe "</span>norm $<span class="string">"|endif|endif</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">set hlsearch</span></span><br></pre></td></tr></table></figure><p>配色方案放在~/.vim/colors 目录</p><h2 id="windows环境cygwin环境安装"><a href="#windows环境cygwin环境安装" class="headerlink" title="windows环境cygwin环境安装"></a>windows环境cygwin环境安装</h2><p>cygwin是windows下使用linux环境的不二之选，安装也很简单，如果联网环境，可以勾选<br>自己想要的库和软件包;使用时候如果发现有软件没有安装，需要重新安装一遍，不过<br>已安装的不会再次下载．<br>不联网的环境，可以先找个联网的机器下载需要的安装目录，然后选择从本地来源安装即可．<br>cygwin.rar是我自己使用的一个安装包，包含了vim编辑器，gcc编译器以及python大多数库.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;个人电脑系统是Ubuntu,也因为Linux环境工作效率更高，比较偏爱Linux系统，&lt;br&gt;平时写代码主要使用Vim,故总结出工作环境的简单配置．&lt;/p&gt;
    
    </summary>
    
    
      <category term="tools" scheme="http://yoursite.com/categories/tools/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
      <category term="配置" scheme="http://yoursite.com/tags/%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>Unix-Linux编程实践教程-chapter15-IPC</title>
    <link href="http://yoursite.com/2016/09/07/Unix-Linux%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5%E6%95%99%E7%A8%8B-chapter15-IPC/"/>
    <id>http://yoursite.com/2016/09/07/Unix-Linux%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5%E6%95%99%E7%A8%8B-chapter15-IPC/</id>
    <published>2016-09-07T15:26:58.000Z</published>
    <updated>2020-03-05T13:31:41.827Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第15章-进程间通信-IPC"><a href="#第15章-进程间通信-IPC" class="headerlink" title="第15章　进程间通信(IPC)"></a>第15章　进程间通信(IPC)</h2><p>许多程序都包含一个或多个进程．进程间通过共享数据或传递数据进行通信．举例来说，<br>两个人通过使用Unix的talk命令进行对话，他们就运行了两个进程，将数据从键盘和socket<br>传输到屏幕和socket</p><p>某些进程需要从多个源端接受数据，并将数据送到多个目的地．select和poll调用允许进程<br>等待多个文件描述符的输入</p><p>Unix提供了许多方法来进行数据在进程间传输，命名管道和共享内存是同一机器上的进程间<br>通信使用的两种技术．通信方法的区别在于他们的速度，所传输的消息类型，需要的范围，<br>限制访问权限的能力以及防止数据冲突的能力</p><p>文件锁是进程间使用的避免对文件访问冲突的技术</p><p>信号量是进程合作时所使用的系统级的变量．进程挂起等待另一进程改变信号量的值</p><p>纵观IPC:<br>fork-execv-argv, exit-wait<br>用于使用一组参数来调用某个程序，被调用函数将一个整形值返回给其调用者<br>面向消息，只能用在相关的进程中，且只能单机上使用</p><p>environ<br>系统调用exec通过environ这个全局变量自动将一组字符串复制给新程序，子进程无法改变<br>父进程的运行环境<br>面向对象，单向，只能用在相关进程，且只能在单机上使用</p><p>pipe<br>管道是由进程创建的单向数据流<br>面向流，单向，相关进程，单机</p><p>kill-signal<br>信号是一条从一个进程发往另一个进程的整形消息<br>面向消息，单向，进程必须有相同的用户ID，单机</p><p>Internet sockets<br>字节流通过socket进行传输，从一个进程到另一个进程<br>面向消息，面向流，双向传输，可以在无关进程中使用，可通过网络传输</p><p>Named Sockets<br>命名socket,使用文件名作为地址而不是主机名－端口号对<br>面向消息，面向流，双向传输，可以在无关进程中使用，单机</p><p>Named Pipes(FIFOs)<br>命令管道工作方式类似于常规管道，但是可以连接两个无关进程<br>单向，面向流，可以连接无关进程，单机</p><p>File Locks<br>文件锁<br>面向消息，多个无关进程可同时交互，单机</p><p>Shared Memory<br>每个进程有自己的数据空间，进程可以通过shmget shmat调用来创建可以被多个进程共享的内存段<br>面向随即访问，多个无关进程同时交互，单机</p><p>Semaphores<br>信号量是系统级的变量，程序之间可以通过信号量进行通信<br>面向消息，多个无关进程同时交互，单机</p><p>Message Queues<br>消息队列工作原理类似FIFO<br>面向消息，单向传输，单机</p><p>Files<br>文件可以被多个进程在同一时刻打开<br>面向随即访问，多个无关进程同时交互，网络文件系统(NFS)可以支持跨机器的多进程通信</p><h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * shm_ts.c</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * the time server using shared memory, a bizarre application</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TIME_MEM_KEY 99</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SEG_SIZE ((size_t)100)</span></span><br><span class="line"></span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> seg_id;</span><br><span class="line">    <span class="keyword">char</span> * mem_ptr, *ctime();</span><br><span class="line">    <span class="keyword">long</span> now;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create a shared memory segment</span></span><br><span class="line">    seg_id = shmget(TIME_MEM_KEY, SEG_SIZE, IPC_CREAT|<span class="number">0777</span>);</span><br><span class="line">    <span class="keyword">if</span> (seg_id == <span class="number">-1</span>) </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"error"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// attach to it and get a pointer to where it attaches</span></span><br><span class="line">    mem_ptr = shmat(seg_id, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (mem_ptr == (<span class="keyword">void</span> *)<span class="number">-1</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"error"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// run for a minute</span></span><br><span class="line">    <span class="keyword">for</span> (n = <span class="number">0</span>; n &lt; <span class="number">60</span>; n++)</span><br><span class="line">    &#123;</span><br><span class="line">        time(&amp;now);</span><br><span class="line">        <span class="built_in">strcpy</span>(mem_ptr, ctime(&amp;now));</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// remove it</span></span><br><span class="line">    shmctl(seg_id, IPC_RMID, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * shm_tc.c</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TIME_MEM_KEY 99</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SEG_SIZE ((size_t)100)</span></span><br><span class="line"></span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> seg_id;</span><br><span class="line">    <span class="keyword">char</span> * mem_ptr, *ctime();</span><br><span class="line">    <span class="keyword">long</span> now;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create a shared memory segment</span></span><br><span class="line">    seg_id = shmget(TIME_MEM_KEY, SEG_SIZE, <span class="number">0777</span>);</span><br><span class="line">    <span class="keyword">if</span> (seg_id == <span class="number">-1</span>) </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"error"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// attach to it and get a pointer to where it attaches</span></span><br><span class="line">    mem_ptr = shmat(seg_id, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (mem_ptr == (<span class="keyword">void</span> *)<span class="number">-1</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"error"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Time is %s"</span>, mem_ptr);</span><br><span class="line"></span><br><span class="line">    shmdt(mem_ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;第15章-进程间通信-IPC&quot;&gt;&lt;a href=&quot;#第15章-进程间通信-IPC&quot; class=&quot;headerlink&quot; title=&quot;第15章　进程间通信(IPC)&quot;&gt;&lt;/a&gt;第15章　进程间通信(IPC)&lt;/h2&gt;&lt;p&gt;许多程序都包含一个或多个进程．进程间通过
      
    
    </summary>
    
    
      <category term="programming" scheme="http://yoursite.com/categories/programming/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
      <category term="C" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Unix-Linux编程实践教程-chapter14-thread</title>
    <link href="http://yoursite.com/2016/09/06/Unix-Linux%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5%E6%95%99%E7%A8%8B-chapter14-thread/"/>
    <id>http://yoursite.com/2016/09/06/Unix-Linux%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5%E6%95%99%E7%A8%8B-chapter14-thread/</id>
    <published>2016-09-06T14:05:56.000Z</published>
    <updated>2020-03-05T13:31:41.826Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第14章-线程机制-并发函数的使用"><a href="#第14章-线程机制-并发函数的使用" class="headerlink" title="第14章　线程机制:并发函数的使用"></a>第14章　线程机制:并发函数的使用</h2><p>执行线路即为程序的控制流程．pthreads的线程库允许程序在同一时刻运行多个函数</p><p>同时执行的各函数都拥有自己的局部变量，但共享所有的全局变量和动态分配的数据空间</p><p>当线程共享变量时，必须保证他们不会发生共享冲突．线程使用互斥锁保证在某一时刻只有<br>一个线程在对共享变量访问</p><p>线程间通过条件变量来互相通知和同步数据．一个线程挂起并等待着条件变量按照某种特定<br>方式变化，而另一个线程则发出信号使得条件变量发生变化</p><p>线程需要使用互斥量来避免对于共享资源操作函数的访问冲突．非重入的函数必须按照<br>这种方式进行保护</p><p>进程间可以通过管道　socket 信号　退出／等待以及运行环境来进行会话．线程因为是在<br>一个单独的进程中运行，共享全局变量，因此线程可以通过设置和读取这些全局变量来<br>进行通信，对共享内存的访问，既有用也危险</p><h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * test_mutex.c</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> times = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">pthread_mutex_t</span> lock = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">arg_set</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> t1, t2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    void * add();</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    pthread_create(&amp;t1, NULL, add, NULL);</span></span><br><span class="line"><span class="comment">    pthread_create(&amp;t2, NULL, add, NULL);</span></span><br><span class="line"><span class="comment">    pthread_join(t1, NULL);</span></span><br><span class="line"><span class="comment">    pthread_join(t2, NULL);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    printf("%d\n", total);</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> * <span class="title">add2</span><span class="params">(<span class="keyword">void</span> *)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">arg_set</span> <span class="title">a1</span>, <span class="title">a2</span>;</span></span><br><span class="line">    a1.count = <span class="number">0</span>;</span><br><span class="line">    a2.count = <span class="number">0</span>;</span><br><span class="line">    pthread_create(&amp;t1, <span class="literal">NULL</span>, add2, (<span class="keyword">void</span> *)&amp;a1);</span><br><span class="line">    pthread_create(&amp;t2, <span class="literal">NULL</span>, add2, (<span class="keyword">void</span> *)&amp;a2);</span><br><span class="line">    pthread_join(t1, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(t2, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, a1.count + a2.count);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// First method: add mutex</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">add</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; times; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;lock);</span><br><span class="line">        total++;</span><br><span class="line">        pthread_mutex_unlock(&amp;lock);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Second method: cal single</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">add2</span><span class="params">(<span class="keyword">void</span> * a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">arg_set</span> *<span class="title">arg</span> = <span class="title">a</span>;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; times; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        arg-&gt;count++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * test_mutex.c</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * pthread_cond_wait(pthread_cond_t * cond, pthread_mutex_t * mutex)</span></span><br><span class="line"><span class="comment"> *      使线程挂起直到另一个线程通过条件变量发出消息.先自动释放指定的锁，</span></span><br><span class="line"><span class="comment"> *      然后等待条件变量的变化</span></span><br><span class="line"><span class="comment"> * pthread_cond_signal(pthread_cond_t * cond)</span></span><br><span class="line"><span class="comment"> *      通过条件变量cond 发消息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> times = <span class="number">100000000</span>;</span><br><span class="line"><span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">pthread_mutex_t</span> lock = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"><span class="keyword">pthread_cond_t</span> flag = PTHREAD_COND_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">arg_set</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    <span class="keyword">int</span> times;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">arg_set</span> * <span class="title">mailbox</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> t1, t2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> * <span class="title">add2</span><span class="params">(<span class="keyword">void</span> *)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> reports_in = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">arg_set</span> <span class="title">a1</span>, <span class="title">a2</span>;</span></span><br><span class="line"></span><br><span class="line">    pthread_mutex_lock(&amp;lock);</span><br><span class="line"></span><br><span class="line">    a1.count = <span class="number">0</span>;</span><br><span class="line">    a1.times = <span class="number">10000000</span>;</span><br><span class="line">    a2.count = <span class="number">0</span>;</span><br><span class="line">    a2.times = <span class="number">1000</span>;</span><br><span class="line">    pthread_create(&amp;t1, <span class="literal">NULL</span>, add2, (<span class="keyword">void</span> *)&amp;a1);</span><br><span class="line">    pthread_create(&amp;t2, <span class="literal">NULL</span>, add2, (<span class="keyword">void</span> *)&amp;a2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (reports_in &lt; <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"MAIN: waiting for flag\n"</span>);</span><br><span class="line">        pthread_cond_wait(&amp;flag, &amp;lock);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"MAIN: I have the lock\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, mailbox-&gt;count);</span><br><span class="line">        total += mailbox-&gt;count;</span><br><span class="line">        <span class="keyword">if</span> (mailbox == &amp;a1)</span><br><span class="line">            pthread_join(t1, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (mailbox == &amp;a2)</span><br><span class="line">            pthread_join(t2, <span class="literal">NULL</span>);</span><br><span class="line">        mailbox = <span class="literal">NULL</span>;</span><br><span class="line">        pthread_cond_signal(&amp;flag);</span><br><span class="line">        reports_in ++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"total %d\n"</span>, total);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">add2</span><span class="params">(<span class="keyword">void</span> * a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">arg_set</span> *<span class="title">arg</span> = <span class="title">a</span>;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arg-&gt;times; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        arg-&gt;count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"COUNT: waiting to get lock\n"</span>);</span><br><span class="line">    pthread_mutex_lock(&amp;lock);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"COUNT: have lock\n"</span>);</span><br><span class="line">    <span class="keyword">if</span> (mailbox != <span class="literal">NULL</span>)</span><br><span class="line">        pthread_cond_wait(&amp;flag, &amp;lock);</span><br><span class="line">    mailbox = arg;</span><br><span class="line">    pthread_cond_signal(&amp;flag);</span><br><span class="line">    pthread_mutex_unlock(&amp;lock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;第14章-线程机制-并发函数的使用&quot;&gt;&lt;a href=&quot;#第14章-线程机制-并发函数的使用&quot; class=&quot;headerlink&quot; title=&quot;第14章　线程机制:并发函数的使用&quot;&gt;&lt;/a&gt;第14章　线程机制:并发函数的使用&lt;/h2&gt;&lt;p&gt;执行线路即为程序的控
      
    
    </summary>
    
    
      <category term="programming" scheme="http://yoursite.com/categories/programming/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
      <category term="C" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="Thread" scheme="http://yoursite.com/tags/Thread/"/>
    
  </entry>
  
</feed>
